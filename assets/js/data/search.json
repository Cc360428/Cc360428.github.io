[
  
  {
    "title": "docker-compose Install Yaml",
    "url": "/posts/docker-compose-install-all/",
    "categories": "DevOps, Docker",
    "tags": "LinuxTool, Docker",
    "date": "2024-05-21 12:48:54 +0800",
    





    
    "snippet": "consulversion: \"3\"services:  consul-server1:    image: hashicorp/consul:latest    container_name: consul-server1    restart: always    volumes:      - ${PWD}/config/server1.json:/consul/config/serv...",
    "content": "consulversion: \"3\"services:  consul-server1:    image: hashicorp/consul:latest    container_name: consul-server1    restart: always    volumes:      - ${PWD}/config/server1.json:/consul/config/server1.json:ro      - ${PWD}/config/certs/:/consul/config/certs/:ro    networks:      - consul    ports:      - \"9999:8500\"      - \"10001:8600/tcp\"      - \"10002:8600/udp\"    command: \"agent -bootstrap-expect=3\"  consul-server2:    image: hashicorp/consul:latest    container_name: consul-server2    restart: always    volumes:      - ${PWD}/config/server2.json:/consul/config/server2.json:ro      - ${PWD}/config/certs/:/consul/config/certs/:ro    networks:      - consul    command: \"agent -bootstrap-expect=3\"  consul-server3:    image: hashicorp/consul:latest    container_name: consul-server3    restart: always    volumes:      - ${PWD}/config/server3.json:/consul/config/server3.json:ro      - ${PWD}/config/certs/:/consul/config/certs/:ro    networks:      - consul    command: \"agent -bootstrap-expect=3\"  consul-client:    image: hashicorp/consul:latest    container_name: consul-client    restart: always    volumes:      - ${PWD}/config/client.json:/consul/config/client.json:ro      - ${PWD}/config/certs/:/consul/config/certs/:ro    networks:      - consul    command: \"agent\"networks:  consul:    driver: bridgeBrowser file sharefilebrowserversion: \"3\"services:  filebrowser:    restart: always    image: filebrowser/filebrowser:v2.29.0    container_name: filebrowser    ports: # 映射端口号      - \"80:80\"    volumes:      - /home/save/filebrowser/srv:/srv      - /home/save/filebrowser/database.db:/database.db      - /home/save/filebrowser/.filebrowser.json:/.filebrowser.jsoni    restart: 'always'minioversion: \"3\"services:  minio:    image: minio/minio    hostname: \"minio\"    ports:      - 10030:9000 # api 端口      - 10031:9001 # 控制台端口    environment:      MINIO_ACCESS_KEY: admin #管理后台用户名      MINIO_SECRET_KEY: minioadmin123 #管理后台密码，最小8个字符    volumes:      - ./data:/data #映射当前目录下的data目录至容器内/data目录      - ./config:/root/.minio/ #映射配置目录    command: server --console-address ':9001' /data #指定容器中的目录 /data    privileged: true    restart: alwaysgitlab-runnerversion: \"3\"services:  gitlab-runner:    image: gitlab/gitlab-runner:latest    container_name: gitlab-runner    volumes:      - /var/run/docker.sock:/var/run/docker.sock      - /home/save/gitlab-runner/config:/etc/gitlab-runner    environment:      - CI_SERVER_URL=https://gitlab-address.com      - RUNNER_REGISTRATION_TOKEN=token    restart: alwaysELKversion: \"3\"services:  elasticsearch:    image: elasticsearch:8.8.1    container_name: elasticsearch    environment:      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"    volumes:      - /home/save/elk/elasticsearch/data:/usr/share/elasticsearch/data # 数据文件      - /home/save/elk/elasticsearch/logs:/usr/share/elasticsearch/logs # 日志文件      - /home/save/elk/elasticsearch/plugins:/usr/share/elasticsearch/plugins # 日志文件      - /home/save/elk/elasticsearch/config:/usr/share/elasticsearch/config # 配置文件    ports:      - \"10011:9200\"      - \"10012:9300\"    restart: always  kibana:    image: kibana:8.8.1    container_name: kibana    environment:      I18N_LOCALE: zh-CN    volumes:      - /home/save/elk/kibana/config:/usr/share/kibana/config      - /home/save/elk/kibana/plugins:/usr/share/kibana/plugins      # - /home/save/elk/kibana/node_modules:/usr/share/kibana/node_modules    ports:      - 10013:5601    depends_on:      - elasticsearch    restart: always  logstash:    image: logstash:8.8.1    container_name: logstash    restart: always    volumes:      - /etc/localtime:/etc/localtime      - /home/save/elk/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml      - /home/save/elk/logstash/pipeline/logstash.conf:/usr/share/logstash/pipeline/logstash.conf:ro    ports:      - \"10014:5044\"      - \"10015:50000/tcp\"      - \"10015:50000/udp\"      - \"10016:9600\"    depends_on:      - elasticsearch    environment:      LS_JAVA_OPTS: \"-Xmx256m -Xms256m\"books viewfbreaderversion: \"3\"services:  fbreader:    image: akshmakov/fbreader    container_name: fbreader    volumes:      - ./books:/books # 将你的书籍目录挂载到容器中    environment:      - DISPLAY=:0 # 设置显示变量，这在模拟桌面环境中很重要    ports:      - \"8180:8080\" # 设置 VNC 或其他远程访问服务的端口    restart: unless-stoppedgotify-serverversion: \"3\"services:  gotify-server:    container_name: gotify-server    image: gotify/server    ports:      - \"10034:8004\"    environment:      TZ: \"Asia/Shanghai\"      GOTIFY_SERVER_PORT: 8004    volumes:      - ./data:/app/data      - /etc/hosts:/etc/hosts    restart: \"always\""
  },
  
  {
    "title": "CDN",
    "url": "/posts/CDN/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2024-04-28 12:48:54 +0800",
    





    
    "snippet": "CDN  CDN 是内容分发网络（Content Delivery Network）的缩写。它是一个由分布在全球各地的服务器网络组成的系统，用于在用户请求内容时快速交付网站、应用程序、音频、视频和其他互联网内容工作原理  网络架构：CDN 由多个位于全球各地的服务器节点组成，这些节点通常称为边缘服务器。这些服务器节点分布在地理位置上的关键位置，以便尽可能地靠近最终用户。  工作原理：当用户请...",
    "content": "CDN  CDN 是内容分发网络（Content Delivery Network）的缩写。它是一个由分布在全球各地的服务器网络组成的系统，用于在用户请求内容时快速交付网站、应用程序、音频、视频和其他互联网内容工作原理  网络架构：CDN 由多个位于全球各地的服务器节点组成，这些节点通常称为边缘服务器。这些服务器节点分布在地理位置上的关键位置，以便尽可能地靠近最终用户。  工作原理：当用户请求访问一个网站或者特定的内容时，CDN 系统会自动选择最接近用户的服务器节点来提供内容。这样做可以减少数据传输的距离，从而降低延迟和提高加载速度。  内容缓存：CDN 会将网站的静态内容（如图像、样式表、脚本等）缓存到其服务器节点上。当有用户请求相同内容时，CDN 会直接从缓存中提供，而不是从原始服务器获取，这样可以减轻原始服务器的负载。  负载均衡：CDN 能够智能地分配流量到其服务器节点，以确保网络负载均衡，避免某个节点过载。  内容优化：CDN 可以对内容进行优化，包括压缩、图片优化、缓存控制等，以提高传输效率和用户体验。  安全性：CDN 提供一定程度的安全性，包括 DDoS（分布式拒绝服务攻击）防护、SSL 证书支持等功能，以保护网站免受恶意攻击。  分布式存储：CDN 可以作为内容的分布式存储解决方案，确保内容的可靠性和高可用性原始服务有改变缓存  缓存过期策略：在设置 CDN 时，可以定义缓存内容的过期时间。一旦内容过期，CDN 会从原始服务器重新获取最新的内容。你可以根据内容的更新频率和重要性来设置合适的缓存过期策略。  缓存刷新：当内容发生变化时，你可以手动或自动触发 CDN 的缓存刷新机制，以更新缓存中的内容。这通常可以通过 CDN 提供的管理界面或 API 来完成。  版本化 URL 或文件名：一种常见的做法是使用版本化的 URL 或文件名来更新内容。每当内容发生变化时，你可以更新 URL 或文件名，这样 CDN 会将其视为新的资源，并在用户请求时获取最新版本。  Cache-Control 头：通过在原始服务响应的 HTTP 头中包含 Cache-Control 头，可以控制 CDN 对内容的缓存策略。例如，通过设置”Cache-Control: no-cache”，可以指示 CDN 不缓存该内容，而是在每次请求时从原始服务器获取。  Purge API：大多数 CDN 提供了 Purge API，允许你针对特定的 URL 或内容进行缓存清除操作，以便立即更新缓存中的内容优势/劣势      优势          提高网站性能：CDN 通过将内容缓存在分布式的边缘节点上，使得用户能够从离他们最近的服务器获取内容，从而减少了加载时间和延迟，提高了网站的性能和响应速度。      提高可用性：由于 CDN 将内容分发到多个服务器上，即使其中一个服务器出现故障，仍然可以从其他服务器获取内容，提高了网站的可用性和稳定性。      减轻原始服务器负载：CDN 可以缓存静态内容并直接响应用户请求，减轻了原始服务器的负载，提高了网站的承载能力。      全球覆盖：CDN 的服务器节点分布在全球各地，可以为全球用户提供更快速和稳定的访问体验。      安全性增强：CDN 提供一些安全功能，如 DDoS 防护、SSL 加密等，有助于保护网站免受网络攻击和数据泄露。            劣势          成本：CDN 服务通常需要支付费用，尤其是对于大型网站或应用来说，这可能是一个显著的成本。      配置复杂性：对于初学者来说，配置和管理 CDN 可能会有一定的学习曲线，特别是在处理缓存更新和缓存失效时。      隐私和安全风险：将内容分发到 CDN 可能会引入一些隐私和安全风险，尤其是对于一些敏感数据或个人信息的网站。      依赖第三方服务：使用 CDN 意味着你的网站依赖于第三方服务提供商，如果服务提供商出现故障或问题，可能会影响到你的网站正常运行。      可能增加复杂性：在某些情况下，CDN 的引入可能会增加网站的复杂性，特别是在跨地区和动态内容的处理上。        综合来看，CDN 在提高网站性能、可用性和安全性方面具有明显的优势，但也需要注意其可能带来的成本和配置管理方面的挑战。"
  },
  
  {
    "title": "Kubernetes Work CMD",
    "url": "/posts/k8s-work-cmd/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2024-03-16 12:23:54 +0800",
    





    
    "snippet": "Work CMD  work cmdgenerate#!/bin/bashKUBECONFIG=ind_dev:ind_dev_local:vn_dev:vn_dev_local kubectl config view --flatten &gt;./configKUBECONFIG=ind_dev:ind_dev_local:vn_dev:vn_dev_local kubectl conf...",
    "content": "Work CMD  work cmdgenerate#!/bin/bashKUBECONFIG=ind_dev:ind_dev_local:vn_dev:vn_dev_local kubectl config view --flatten &gt;./configKUBECONFIG=ind_dev:ind_dev_local:vn_dev:vn_dev_local kubectl config view --flatten &gt;~/.kube/configcmd#!/bin/bashkubectl config get-contexts        # 列出所有上下文kubectl config use-context ind_dev # 切换上下文kubectl config view                # 验证配置#  # 创建新的上下文# kubectl config set-context &lt;context-name&gt; --cluster=&lt;cluster-name&gt; --user=&lt;user-name&gt; --namespace=&lt;namespace&gt;# # 配置集群# kubectl config set-cluster &lt;cluster-name&gt; --server=&lt;api-server-url&gt; --certificate-authority=&lt;ca-file&gt;kubectl rollout restart deployment ferry -n commonkubectl rollout restart deployment yxx -n gameskubectl rollout restart deployment game-gate -n gameskubectl rollout restart deployment tienlenkubectl rollout restart deployment tienlen-aikubectl get pods --sort-by=.metadata.namekubectl get pods --sort-by=.status.phasekubectl get pods --sort-by=.status.startTimekubectl get pods --sort-by=.spec.nodeNamekubectl describe pod ferry-6dddddd849-km9ffkubectl describe node k8s-master1kubectl describe service ferrykubectl describe deployment ferrykubectl get events --field-selector involvedObject.name=ferry,involvedObject.namespace=gameshelm install bonus-texas .helm repo add vietnam --username username --password password https://urlkubectl set image deployment/ferry ferry=images:v1-0-1 -n common"
  },
  
  {
    "title": "MySQL Select Leetcode",
    "url": "/posts/mysql-select/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2024-01-09 23:21:48 +0800",
    





    
    "snippet": "查询可回收且低脂的产品      元数据    Create table If Not Exists Products (product_id int, low_fats ENUM('Y', 'N'), recyclable ENUM('Y','N'));Truncate table Products;insert into Products (product_id, low_fats, r...",
    "content": "查询可回收且低脂的产品      元数据    Create table If Not Exists Products (product_id int, low_fats ENUM('Y', 'N'), recyclable ENUM('Y','N'));Truncate table Products;insert into Products (product_id, low_fats, recyclable) values ('0', 'Y', 'N');insert into Products (product_id, low_fats, recyclable) values ('1', 'Y', 'Y');insert into Products (product_id, low_fats, recyclable) values ('2', 'N', 'Y');insert into Products (product_id, low_fats, recyclable) values ('3', 'Y', 'Y');insert into Products (product_id, low_fats, recyclable) values ('4', 'N', 'N');            解释          product_id: 是该表的主键（具有唯一值的列）      low_fats: 是枚举类型，取值为以下两种 (‘Y’, ‘N’)，其中 ‘Y’ 表示该产品是低脂产品，’N’ 表示不是低脂产品      recyclable: 是枚举类型，取值为以下两种 (‘Y’, ‘N’)，其中 ‘Y’ 表示该产品可回收，而 ‘N’ 表示不可回收            题解    select product_id from Products where low_fats = 'Y' and recyclable = 'Y';      寻找用户推荐人      元数据    Create table If Not Exists Customer (id int, name varchar(25), referee_id int);Truncate table Customer;insert into Customer (id, name) values ('1', 'Will');insert into Customer (id, name) values ('2', 'Jane');insert into Customer (id, name, referee_id) values ('3', 'Alex', '2');insert into Customer (id, name) values ('4', 'Bill');insert into Customer (id, name, referee_id) values ('5', 'Zack', '1');insert into Customer (id, name, referee_id) values ('6', 'Mark', '2');            解释          referee_id 推荐 ID      在 SQL 中，id 是该表的主键列      该表的每一行表示一个客户的 id、姓名以及推荐他们的客户的 id      找出那些 没有被 id = 2 的客户 推荐 的客户的姓名            题解: &lt;&gt;    select name from Customer where referee_id != 2 or referee_id is NULL;SELECT name FROM Customer WHERE NOT referee_id &lt;=&gt; 2;      大的国家  元数据Create table If Not Exists World (name varchar(255), continent varchar(255), area int, population int, gdp bigint);Truncate table World;insert into World (name, continent, area, population, gdp) values ('Afghanistan', 'Asia', '652230', '25500100', '20343000000');insert into World (name, continent, area, population, gdp) values ('Albania', 'Europe', '28748', '2831741', '12960000000');insert into World (name, continent, area, population, gdp) values ('Algeria', 'Africa', '2381741', '37100000', '188681000000');insert into World (name, continent, area, population, gdp) values ('Andorra', 'Europe', '468', '78115', '3712000000');insert into World (name, continent, area, population, gdp) values ('Angola', 'Africa', '1246700', '20609294', '100990000000');      解释          name 是该表的主键（具有唯一值的列）      这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值      如果一个国家满足下述两个条件之一，则认为该国是 大国 ：                  面积至少为 300 万平方公里（即，3000000 km2），或者          人口至少为 2500 万（即 25000000）                    编写解决方案找出 大国 的国家名称、人口和面积            题解    select name,population,area from World where area &gt;= 3000000 or population &gt;= 25000000;      文章预览 1      元数据    Create table If Not Exists Views (article_id int, author_id int, viewer_id int, view_date date);Truncate table Views;insert into Views (article_id, author_id, viewer_id, view_date) values ('1', '3', '5', '2019-08-01');insert into Views (article_id, author_id, viewer_id, view_date) values ('1', '3', '6', '2019-08-02');insert into Views (article_id, author_id, viewer_id, view_date) values ('2', '7', '7', '2019-08-01');insert into Views (article_id, author_id, viewer_id, view_date) values ('2', '7', '6', '2019-08-02');insert into Views (article_id, author_id, viewer_id, view_date) values ('4', '7', '1', '2019-07-22');insert into Views (article_id, author_id, viewer_id, view_date) values ('3', '4', '4', '2019-07-21');insert into Views (article_id, author_id, viewer_id, view_date) values ('3', '4', '4', '2019-07-21');        解释          此表可能会存在重复行。（换句话说，在 SQL 中这个表没有主键）      此表的每一行都表示某人在某天浏览了某位作者的某篇文章。      请注意，同一人的 author_id 和 viewer_id 是相同的。      请查询出所有浏览过自己文章的作者      结果按照 id 升序排列            题解    select distinct author_id as id from Views where author_id = viewer_id order by id;      Other      元数据            解释      题解          "
  },
  
  {
    "title": "MySQL Select Base",
    "url": "/posts/mysql-select-base/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2024-01-09 23:20:48 +0800",
    





    
    "snippet": "MySQL Select Base  基本的 SQL 语法：了解 SQL 的基本语法结构，包括 SELECT、FROM、WHERE、GROUP BY、ORDER BY 等关键字的使用方法  表的创建和管理：理解如何创建表，定义列的数据类型，以及如何管理表的结构，包括添加、删除、修改列等操作  索引：了解索引的概念以及如何在表上创建索引，以提高查询性能  聚合函数：掌握聚合函数如 COUNT、...",
    "content": "MySQL Select Base  基本的 SQL 语法：了解 SQL 的基本语法结构，包括 SELECT、FROM、WHERE、GROUP BY、ORDER BY 等关键字的使用方法  表的创建和管理：理解如何创建表，定义列的数据类型，以及如何管理表的结构，包括添加、删除、修改列等操作  索引：了解索引的概念以及如何在表上创建索引，以提高查询性能  聚合函数：掌握聚合函数如 COUNT、SUM、AVG、MIN、MAX 等的使用，以便对数据进行统计和计算  GROUP BY 子句：学习如何使用 GROUP BY 子句对数据进行分组，并结合聚合函数进行分组统计  HAVING 子句：了解 HAVING 子句的作用，它与 WHERE 子句的区别，以及在 GROUP BY 后进行条件过滤的用法  连接（JOIN）：学习不同类型的连接操作，如 INNER JOIN、LEFT JOIN、RIGHT JOIN 等，以及它们在查询中的应用  子查询：掌握如何在 SELECT 语句中嵌套使用子查询来实现复杂的查询逻辑  函数：熟悉 MySQL 提供的各种函数，包括数学函数、日期函数、字符串函数等，以及它们在查询中的应用  模糊查询：了解如何使用 LIKE 关键字进行模糊匹配，以及通配符的使用方法，如 %和 _  排序和分页：掌握 ORDER BY 子句的使用，以对查询结果进行排序，并了解 LIMIT 子句的用法，以实现分页查询  数据类型转换和格式化：了解如何对查询结果进行数据类型转换和格式化，以满足特定的输出需求基本 SQL 语法  SELECT：指定要检索的列或表达式  FROM：指定要从中检索数据的表或视图  WHERE：指定条件，以过滤检索的行  GROUP BY：按照指定的列对检索的数据进行分组  HAVING：对分组后的结果进行条件过滤  ORDER BY：指定结果的排序顺序  LIMIT（在一些数据库系统中）：限制返回的行数      例子          假设我们有一个名为 orders的表，其中包含了订单信息，包括订单号、客户 ID、订单日期和订单金额等字段。我们想要检索每个客户的订单总金额，并按照订单总金额降序排列，只显示订单总金额大于 1000 的客户，最多显示前 10 个客户的结果。下面是相应的 SQL 查询：        SELECT customer_id, SUM(order_amount) AS total_amountFROM ordersGROUP BY customer_idHAVING total_amount &gt; 1000ORDER BY total_amount DESCLIMIT 10;                      解释                  SELECT customer_id, SUM(order_amount) AS total_amount：我们选择了客户 ID 和订单金额的总和，并使用 AS 关键字给总金额取了一个别名 total_amount          FROM orders：我们从 orders 表中检索数据          GROUP BY customer_id：我们按照客户 ID 进行分组，以计算每个客户的订单总金额          HAVING total_amount &gt; 1000：我们使用 HAVING 子句来过滤总金额大于 1000 的客户          ORDER BY total_amount DESC：我们按照订单总金额的降序排列结果          LIMIT 10：最后，我们使用 LIMIT 子句限制结果集的大小为 10，只显示前 10 个客户的结果                    运算符            运算符      名称      示例                  +      加法      SELECT 5 + 3; 结果为 8              -      减法      SELECT 10 - 4; 结果为 6              *      乘法      SELECT 7 * 6; 结果为 42              /      除法      SELECT 15 / 3; 结果为 5              %      取模      SELECT 17 % 5; 结果为 2              =      等于      SELECT * FROM users WHERE age = 25;              &lt;&gt;      不等于      SELECT * FROM users WHERE age &lt;&gt; 25;              &gt;      大于      SELECT * FROM users WHERE age &gt; 25;              &lt;      小于      SELECT * FROM users WHERE age &lt; 25;              &gt;=      大于等于      SELECT * FROM users WHERE age &gt;= 25;              &lt;=      小于等于      SELECT * FROM users WHERE age &lt;= 25;              AND      逻辑与      SELECT * FROM users WHERE age &gt; 25 AND gender = 'M';              OR      逻辑或      SELECT * FROM users WHERE age &gt; 25 OR gender = 'F';              NOT      逻辑非      SELECT * FROM users WHERE NOT age &gt; 25;              BETWEEN      在某个范围内      SELECT * FROM users WHERE age BETWEEN 20 AND 30;              IN      在某个集合内      SELECT * FROM users WHERE age IN (25, 30, 35);              LIKE      模糊匹配      SELECT * FROM users WHERE name LIKE 'J%';              IS NULL      是否为 NULL      SELECT * FROM users WHERE email IS NULL;              IS NOT NULL      是否不为 NULL      SELECT * FROM users WHERE email IS NOT NULL;        例子SELECT    users.id,    users.name,    users.age,    users.gender,    users.email,    (users.age + 5) AS future_age,    (users.age - 3) AS past_age,    (users.age * 2) AS double_age,    ROUND(users.age / 3, 2) AS third_age,    (users.age % 2) AS odd_or_even,    CASE        WHEN users.age = 25 THEN 'Twenty-five'        WHEN users.age &gt; 25 THEN 'Older than twenty-five'        ELSE 'Younger than twenty-five'    END AS age_category,    CASE        WHEN users.gender = 'M' THEN 'Male'        WHEN users.gender = 'F' THEN 'Female'        ELSE 'Unknown'    END AS gender_text,    CONCAT(users.name, ' (', users.gender, ')') AS name_and_genderFROM    usersWHERE    users.age BETWEEN 20 AND 30    AND users.gender IN ('M', 'F')    AND users.email IS NOT NULL    AND (users.name LIKE 'J%' OR users.name LIKE 'S%')ORDER BY    users.age DESCLIMIT 10;      解释          算术运算符: +、-、*、/、%      比较运算符: =、&lt;&gt;、&gt;、&lt;、&gt;=、&lt;=      逻辑运算符: AND、OR、NOT      范围运算符: BETWEEN      集合运算符: IN      模糊匹配运算符: LIKE      NULL 检测运算符: IS NULL、IS NOT NULL      字符串连接运算符: CONCAT()      数学函数: ROUND()      条件表达式: CASE ... WHEN ... THEN ... ELSE ... END        这个查询从 users 表中选择特定的列,对它们进行各种运算,并根据条件进行过滤和排序,最后返回前 10 条结果。聚合函数            聚合函数      描述      示例                  COUNT(DISTINCT column_name)      统计指定列中不同值的个数      SELECT COUNT(DISTINCT customer_id) FROM orders;              SUM(DISTINCT column_name)      计算指定列中不同值的总和      SELECT SUM(DISTINCT order_amount) FROM orders;              AVG(DISTINCT column_name)      计算指定列中不同值的平均值      SELECT AVG(DISTINCT salary) FROM employees;              VAR_POP(column_name)      计算总体方差      SELECT VAR_POP(sales_amount) FROM orders;              VAR_SAMP(column_name)      计算样本方差      SELECT VAR_SAMP(sales_amount) FROM orders;              STDEV_POP(column_name)      计算总体标准差      SELECT STDEV_POP(sales_amount) FROM orders;              STDEV_SAMP(column_name)      计算样本标准差      SELECT STDEV_SAMP(sales_amount) FROM orders;              BIT_AND(column_name)      计算指定列中所有值的按位与      SELECT BIT_AND(status) FROM orders;              BIT_OR(column_name)      计算指定列中所有值的按位或      SELECT BIT_OR(status) FROM orders;              BIT_XOR(column_name)      计算指定列中所有值的按位异或      SELECT BIT_XOR(status) FROM orders;            例子          假设我们有一个名为 sales 的表,其中包含以下字段              id: 销售订单 ID      product: 产品名称      amount: 销售金额              status: 销售状态(1 表示已完成, 0 表示未完成)        SELECT    product,    COUNT(*) AS total_orders,    SUM(amount) AS total_sales,    AVG(amount) AS avg_sale_amount,    VAR_POP(amount) AS population_variance,    VAR_SAMP(amount) AS sample_variance,    STDEV_POP(amount) AS population_std_dev,    STDEV_SAMP(amount) AS sample_std_dev,    BIT_AND(status) AS all_completed,    BIT_OR(status) AS any_completed,    BIT_XOR(status) AS mix_of_completed_and_notFROM    salesGROUP BY    product;                            解释                  product: 产品名称          total_orders: 每个产品的总订单数          total_sales: 每个产品的总销售额          avg_sale_amount: 每个产品的平均销售额          population_variance: 每个产品销售额的总体方差          sample_variance: 每个产品销售额的样本方差          population_std_dev: 每个产品销售额的总体标准差          sample_std_dev: 每个产品销售额的样本标准差          all_completed: 每个产品是否所有订单都已完成(1 表示是, 0 表示否)          any_completed: 每个产品是否有任何订单已完成(1 表示是, 0 表示否)          mix_of_completed_and_not: 每个产品是否存在既有已完成又有未完成的订单(1 表示是, 0 表示否)                    Group By &amp; Group By 子句            用途      示例                  根据一个或多个列对结果集进行分组      SELECT department, COUNT(*) AS num_employees FROM employees GROUP BY department;              与聚合函数结合使用,对分组数据进行统计      SELECT product, SUM(sales_amount) AS total_sales FROM sales GROUP BY product;              对分组结果进行筛选      SELECT category, MAX(sales_amount) AS max_sales FROM sales GROUP BY category HAVING max_sales &gt; 1000;              对分组结果进行排序      SELECT department, AVG(salary) AS avg_salary FROM employees GROUP BY department ORDER BY avg_salary DESC;              嵌套多个 GROUP BY 子句进行多层分组      SELECT country, city, COUNT(*) AS num_customers FROM customers GROUP BY country, city;              与 ROLLUP 或 CUBE 一起使用进行分组结果汇总      SELECT category, product, SUM(sales_amount) AS total_sales FROM sales GROUP BY ROLLUP(category, product);            例子          假设我们有一个名为 sales 的数据表,其包含以下字段:              id: 销售订单 ID      product: 产品名称      category: 产品类别      customer: 客户名称      amount: 销售金额      date: 销售日期        SELECT    category,    product,    customer,    DATE_FORMAT(date, '%Y-%m') AS sales_month,    COUNT(*) AS total_orders,    SUM(amount) AS total_sales,    AVG(amount) AS avg_sale_amountFROM    salesGROUP BY    category, product, customer, DATE_FORMAT(date, '%Y-%m')ORDER BY    total_sales DESCLIMIT 10;                      解释                  category: 产品类别          product: 产品名称          customer: 客户名称          sales_month: 销售月份          total_orders: 每个产品-客户-月份组合的总订单数          total_sales: 每个产品-客户-月份组合的总销售额          avg_sale_amount: 每个产品-客户-月份组合的平均销售额                            查询结果会按照总销售额降序排列,取前 10 条记录      HAVING 子句  HAVING 子句是用来对 GROUP BY 子句产生的分组结果进行筛选的,它通常与聚合函数一起使用。它的作用是在聚合操作之后对数据进行过滤。  例子SELECT    department,    COUNT(*) AS num_employeesFROM    employeesGROUP BY    departmentHAVING    num_employees &gt; 10;  解释  GROUP BY department 将数据按照部门进行分组。  COUNT(*) 统计每个部门的员工数量。  HAVING num_employees &gt; 10 对分组结果进行筛选,只保留员工数量大于 10 人的部门。      HAVING 子句的常见用法包括:          对分组结果进行过滤,保留满足条件的分组      配合聚合函数使用,对分组数据进行过滤      与 WHERE 子句配合使用,先对原始数据进行过滤,再对分组结果进行过滤            使用 HAVING 子句时需要注意以下几点:          HAVING 子句必须在 GROUP BY 子句之后使用。      HAVING 子句中可以使用聚合函数,但 WHERE 子句中不能使用聚合函数。      HAVING 子句的条件表达式可以引用 GROUP BY 子句中的字段。      Join            Join 类型      定义      优点      缺点                  Inner Join      只返回两个表中都存在的记录      简单高效,可以快速找到匹配数据      会丢失未匹配的记录              Left Join      返回左表的所有记录,即使右表中没有匹配的记录      可以保留左表的所有记录      可能会返回大量 NULL 值              Right Join      返回右表的所有记录,即使左表中没有匹配的记录      可以保留右表的所有记录      可能会返回大量 NULL 值              Outer Join      返回左表和右表中所有的记录,即使两表中没有匹配的记录      可以保留两个表中的所有记录      可能会返回大量 NULL 值              Cross Join      返回左表和右表中所有记录的笛卡尔积      可以快速生成大量数据用于测试      当表的数据量很大时,结果集会非常庞大,可能会导致性能问题        例子-- Inner JoinSELECT u.name, o.order_date, o.total_amountFROM users uINNER JOIN orders oON u.id = o.user_id;-- Left JoinSELECT u.name, o.order_date, o.total_amountFROM users uLEFT JOIN orders oON u.id = o.user_id;-- Right JoinSELECT u.name, o.order_date, o.total_amountFROM users uRIGHT JOIN orders oON u.id = o.user_id;-- Outer JoinSELECT u.name, o.order_date, o.total_amountFROM users uFULL OUTER JOIN orders oON u.id = o.user_id;-- Cross JoinSELECT u.name, o.order_date, o.total_amountFROM users uCROSS JOIN orders o;子查询      子查询的基本用法          子查询是指在一个 SQL 语句中嵌入另一个 SQL 语句。子查询可以出现在 SELECT、FROM、WHERE 或 HAVING 子句中。            一些常见的子查询用法如下:          单行子查询: 返回单个值,可以在 WHERE 子句中使用比较运算符比如 =、&lt;、&gt;等。      多行子查询: 返回多个值,可以在 WHERE 子句中使用 IN、NOT IN、EXISTS、NOT EXISTS 等。      相关子查询: 子查询引用了外部查询的列,子查询的执行依赖于外部查询。      标量子查询: 子查询返回单个值,可以在 SELECT 语句的选择列表中使用。      表子查询: 子查询返回一个虚拟表,可以在 FROM 子句中使用。            使用子查询时需要注意的事项          子查询的执行顺序: 在 SQL 语句执行时,子查询先于外部查询执行。      子查询返回值的类型和数量: 单行子查询返回单个值,多行子查询返回多个值。需要确保子查询返回的数据类型和数量与外部查询的要求相匹配。      性能问题: 复杂的子查询可能会影响查询性能,可以考虑使用连接或临时表等替代方案。      子查询嵌套层数: 过多的嵌套子查询可能会降低查询效率,建议控制在 3-4 层以内。      避免无限循环: 当子查询引用了外部查询的列时,需要小心避免无限循环。            例子  -- 查找所有销售额高于平均销售额的订单SELECT    order_id,    total_amountFROM    ordersWHERE    total_amount &gt; (        SELECT            AVG(total_amount)        FROM            orders    );函数日期函数            函数名称      功能      示例                  CURRENT_DATE()      返回当前日期      SELECT CURRENT_DATE();              CURRENT_TIME()      返回当前时间      SELECT CURRENT_TIME();              CURRENT_TIMESTAMP()      返回当前日期和时间      SELECT CURRENT_TIMESTAMP();              DATE(expr)      从日期或日期时间表达式中提取日期部分      SELECT DATE(‘2023-05-23 10:30:45’);              TIME(expr)      从日期或日期时间表达式中提取时间部分      SELECT TIME(‘2023-05-23 10:30:45’);              YEAR(date)      返回日期中的年份      SELECT YEAR(‘2023-05-23’);              MONTH(date)      返回日期中的月份      SELECT MONTH(‘2023-05-23’);              DAY(date)      返回日期中的天数      SELECT DAY(‘2023-05-23’);              HOUR(time)      返回时间中的小时数      SELECT HOUR(‘10:30:45’);              MINUTE(time)      返回时间中的分钟数      SELECT MINUTE(‘10:30:45’);              SECOND(time)      返回时间中的秒数      SELECT SECOND(‘10:30:45’);              DATEDIFF(date1, date2)      返回两个日期之间的天数差      SELECT DATEDIFF(‘2023-05-23’, ‘2023-05-01’);              TIMEDIFF(time1, time2)      返回两个时间之间的差      SELECT TIMEDIFF(‘10:30:45’, ‘08:20:15’);              DATE_FORMAT(date, format)      将日期格式化为指定格式      SELECT DATE_FORMAT(‘2023-05-23’, ‘%Y-%m-%d’);      字符串            函数名称      功能      示例                  CONCAT(str1, str2, …)      连接多个字符串      SELECT CONCAT(‘Hello’, ‘, ‘, ‘World!’);              SUBSTRING(str, pos, len)      从字符串中提取子字符串      SELECT SUBSTRING(‘Hello World’, 7, 5);              LENGTH(str)      返回字符串长度      SELECT LENGTH(‘Hello World’);              LOWER(str)      将字符串转换为小写      SELECT LOWER(‘Hello World’);              UPPER(str)      将字符串转换为大写      SELECT UPPER(‘Hello World’);              TRIM(str)      去除字符串两端的空白字符      SELECT TRIM(‘ Hello World ‘);              REPLACE(str, from_str, to_str)      替换字符串中的子字符串      SELECT REPLACE(‘Hello World’, ‘World’, ‘MySQL’);              STRCMP(str1, str2)      比较两个字符串的大小      SELECT STRCMP(‘Apple’, ‘Banana’);              INSTR(str, substr)      返回子字符串在字符串中首次出现的位置      SELECT INSTR(‘Hello World’, ‘World’);              REVERSE(str)      反转字符串      SELECT REVERSE(‘Hello World’);              LPAD(str, len, padstr)      在左侧用指定字符串填充字符串至指定长度      SELECT LPAD(‘Hello’, 10, ‘0’);              RPAD(str, len, padstr)      在右侧用指定字符串填充字符串至指定长度      SELECT RPAD(‘Hello’, 10, ‘0’);      数字相关            函数名称      功能      示例                  ABS(x)      返回数字的绝对值      SELECT ABS(-10);              CEILING(x)      返回大于或等于指定数字的最小整数      SELECT CEILING(3.14);              FLOOR(x)      返回小于或等于指定数字的最大整数      SELECT FLOOR(3.14);              ROUND(x, d)      将数字四舍五入为指定小数位数      SELECT ROUND(3.14159, 2);              TRUNCATE(x, d)      将数字截断为指定小数位数      SELECT TRUNCATE(3.14159, 2);              MOD(x, y)      返回 x 除以 y 的余数      SELECT MOD(10, 3);              POWER(x, y)      返回 x 的 y 次方      SELECT POWER(2, 3);              SQRT(x)      返回数字的平方根      SELECT SQRT(16);              EXP(x)      返回 e 的 x 次方      SELECT EXP(2);              LOG(x)      返回数字的自然对数      SELECT LOG(10);              LOG10(x)      返回数字的常用对数      SELECT LOG10(100);              RAND()      返回 0 到 1 之间的随机数      SELECT RAND();      模糊查询            查询方式      描述      示例                  LIKE      使用通配符 % 和 _ 进行模糊匹配      SELECT * FROM users WHERE name LIKE 'John%'&lt;br&gt;查找所有名字以”John”开头的用户              REGEXP      使用正则表达式进行模糊匹配      SELECT * FROM users WHERE name REGEXP '^John'&lt;br&gt;查找所有名字以”John”开头的用户              FULLTEXT      对文本类型字段进行全文搜索      SELECT * FROM articles WHERE MATCH(title, content) AGAINST('MySQL')&lt;br&gt;查找标题或内容包含”MySQL”的文章              CONCAT()      将多个字段拼接后进行模糊查询      SELECT * FROM users WHERE CONCAT(first_name, ' ', last_name) LIKE '%John%'&lt;br&gt;查找姓名中包含”John”的用户              INSTR()      判断字符串是否包含指定子串      SELECT * FROM products WHERE INSTR(name, 'iPhone') &gt; 0&lt;br&gt;查找名称中包含”iPhone”的产品              SUBSTRING()      提取字符串的子串进行匹配      SELECT * FROM users WHERE SUBSTRING(email, 1, 5) = 'john@'&lt;br&gt;查找邮箱前缀为”john@”的用户        例子      假设我们有一个名为 products 的表,其中包含以下字段:          id: 产品 ID      name: 产品名称      description: 产品描述      category: 产品分类              现在我们需要查找所有名称包含”iPhone”、分类为”手机”、并且描述中包含”5G”的产品。        SELECT    id,    name,    description,    categoryFROM    productsWHERE    name LIKE '%iPhone%'    AND category = '手机'    AND description LIKE '%5G%'                            解释                  name LIKE '%iPhone%': 使用 LIKE 操作符进行模糊匹配,查找名称中包含”iPhone”的产品。          category = '手机': 精确匹配分类为”手机”的产品。          description LIKE '%5G%': 使用 LIKE 操作符查找描述中包含”5G”的产品。                    排序和分页SELECT    id,    name,    description,    categoryFROM    productsWHERE    name LIKE '%iPhone%'    AND category = '手机'    AND description LIKE '%5G%'ORDER BY    id DESCLIMIT    10 OFFSET 20      解释          WHERE 子句: 与前面的示例相同,用于进行模糊查询      ORDER BY id DESC: 按照产品 ID 倒序排列结果集      LIMIT 10 OFFSET 20: 实现分页功能,取第 21-30 条记录(第 3 页,每页 10 条)        这样我们就可以在满足业务查询条件的基础上,对结果集进行排序和分页展示。这在实际开发中非常有用,可以让用户体验更加流畅  排序可以使用 ORDER BY 子句,支持多个字段,并可以指定升序(ASC)或降序(DESC)  分页可以使用 LIMIT 和 OFFSET 子句组合实现,LIMIT 指定每页显示的记录数,OFFSET 指定跳过的记录数分页计算公式  计算          总记录数：totalRecord      每页最大记录数：maxResult      totalPage = (totalRecord + maxResult -1) / maxResult;      其中 maxResult - 1 就是 totalRecord / maxResult 的最大的余数        动态          select * from table limit （page-1）*20,20;      当页面传递过来 page 为 1 时查询 0~20，当 page 为 2 时查询 20~40 以此类推，求正确公式公式。      select * from table order by id asc limit (page-1)*20,20;      条件 &amp; 循环条件语句      IF 语句:    IF condition THEN    statement_list[ELSEIF condition THEN    statement_list][ELSE    statement_list]END IF;        DELIMITER //CREATE PROCEDURE check_age(IN user_age INT)BEGIN    IF user_age &lt; 18 THEN        SELECT 'Minor';    ELSEIF user_age &gt;= 18 AND user_age &lt; 65 THEN        SELECT 'Adult';    ELSE        SELECT 'Senior';    END IF;END //DELIMITER ;            CASE 语句    CASE case_expression    WHEN when_expression THEN statement_list    [WHEN when_expression THEN statement_list] ...    [ELSE statement_list]END CASE;        SELECT   name,   CASE gender       WHEN 'M' THEN 'Male'       WHEN 'F' THEN 'Female'       ELSE 'Unknown'   END AS gender_textFROM users;      循环语句      WHILE 循环:    [begin_label:] WHILE search_condition DO    statement_listEND WHILE [end_label];        DELIMITER //CREATE PROCEDURE print_numbers(IN max_num INT)BEGIN    DECLARE i INT DEFAULT 1;    WHILE i &lt;= max_num DO        SELECT i;        SET i = i + 1;    END WHILE;END //DELIMITER ;            REPEAT 循环:    [begin_label:] REPEAT    statement_listUNTIL search_conditionEND REPEAT [end_label];        DELIMITER //CREATE PROCEDURE print_even_numbers(IN max_num INT)BEGIN    DECLARE i INT DEFAULT 2;    REPEAT        SELECT i;        SET i = i + 2;    UNTIL i &gt; max_num    END REPEAT;END //DELIMITER ;            LOOP 循环    [begin_label:] LOOP    statement_list    [LEAVE label]END LOOP [end_label];        DELIMITER //CREATE PROCEDURE print_numbers_with_break(IN max_num INT)BEGIN    DECLARE i INT DEFAULT 1;    numbers_loop: LOOP        IF i &gt; max_num THEN            LEAVE numbers_loop;        END IF;        SELECT i;        SET i = i + 1;    END LOOP numbers_loop;END //DELIMITER ;      "
  },
  
  {
    "title": "MySQL Base",
    "url": "/posts/mysql-base/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2024-01-09 23:19:48 +0800",
    





    
    "snippet": "MySQL  MySQL 是一个开源的关系型数据库管理系统，广泛应用于 Web 应用程序的开发中。它提供了一个强大的、稳定的、高效的、可扩展的数据库解决方案，能够满足从小型网站到大型企业级应用的各种需求。  特点  关系型数据库管理系统（RDBMS）：MySQL 是一种关系型数据库管理系统，它采用了关系模型来组织数据。数据存储在表中，表之间通过外键关联，形成了数据之间的关系。  开源性：My...",
    "content": "MySQL  MySQL 是一个开源的关系型数据库管理系统，广泛应用于 Web 应用程序的开发中。它提供了一个强大的、稳定的、高效的、可扩展的数据库解决方案，能够满足从小型网站到大型企业级应用的各种需求。  特点  关系型数据库管理系统（RDBMS）：MySQL 是一种关系型数据库管理系统，它采用了关系模型来组织数据。数据存储在表中，表之间通过外键关联，形成了数据之间的关系。  开源性：MySQL 是开源软件，可以免费获取和使用。这使得它成为许多开发者和企业的首选数据库解决方案之一。  跨平台性：MySQL 可以在多种操作系统上运行，包括 Windows、Linux、Mac 等，因此具有很好的跨平台性。  多用户支持：MySQL 支持多用户同时访问数据库，可以设置不同的权限和访问级别，确保数据的安全性和完整性。  SQL（Structured Query Language）支持：MySQL 使用 SQL 作为操作数据库的标准语言。通过 SQL，用户可以执行各种操作，包括数据的查询、插入、更新、删除等。  性能优化：MySQL 在设计和实现上对性能进行了优化，可以处理大规模的数据和高并发访问。它支持多种存储引擎，如 InnoDB、MyISAM 等，用户可以根据实际需求选择合适的存储引擎来优化性能。  事务支持：MySQL 支持事务，保证了数据的一致性和可靠性。用户可以使用事务来批量执行操作，并在需要时进行回滚或提交。  数据备份和恢复：MySQL 提供了备份和恢复数据库的工具和机制，可以定期备份数据库，以防止数据丢失或损坏，并在需要时进行数据恢复。  可扩展性：MySQL 是一个可扩展的数据库系统，可以通过添加更多的服务器节点来扩展数据库的性能和容量。它支持主从复制、分区、分片等技术来实现数据库的水平和垂直扩展。  社区支持和生态系统：MySQL 拥有庞大的用户社区和开发者社区，用户可以在社区中获取到丰富的资源、文档和支持。此外，MySQL 生态系统也非常丰富，有许多第三方工具和插件可以与 MySQL 集成，扩展其功能和应用场景。事务            特性      描述                  原子性（Atomicity）      事务是一个不可分割的工作单位，要么全部执行成功，要么全部失败回滚。              一致性（Consistency）      事务执行前后数据库的完整性约束不会被破坏，即使事务执行失败也不会导致数据处于不一致的状态。              隔离性（Isolation）      多个事务同时执行时，各个事务之间是相互隔离的，一个事务的执行不会受到其他事务的影响。              持久性（Durability）      事务一旦提交，其结果将会被永久保存在数据库中，并且不会被回滚。即使发生系统崩溃，数据库系统也能够通过日志等方式恢复数据，保证事务的持久性。      关系型数据库  关系型数据库是一种结构化的数据库，它使用了关系模型来组织和管理数据。关系型数据库的核心概念是表、行和列，数据以表的形式存储，每个表由多行（记录）组成，每行包含了多个列（字段）。这种组织方式使得数据之间的关系变得清晰和易于管理。  表（Table）：表是关系型数据库中的基本单位，用于存储特定类型的数据。每个表由一系列行和列组成，行代表记录，列代表字段。表可以有不同的列，每列具有特定的数据类型，如整数、字符、日期等。  行（Row）：行也称为记录或元组，代表表中的一个实体或数据项。每行包含了一组相关的数据，每个字段对应一个数据值。行之间的顺序一般没有特定意义，可以通过主键来唯一标识和区分各行。  列（Column）：列是表的结构化部分，用于定义每个记录的属性。每列具有特定的数据类型和约束，如整数、字符、日期、唯一性约束、非空约束等。列名通常用于标识和访问特定的数据项。  主键（Primary Key）：主键是表中用于唯一标识每行记录的一列或一组列。主键必须是唯一的，且不能为空。通过主键可以快速定位和访问表中的特定记录，保证数据的完整性和一致性。  外键（Foreign Key）：外键是表中的一列，它建立了与其他表之间的关联关系。外键用于指定一个表中的数据与另一个表中的数据之间的关系，通过外键可以实现表之间的引用完整性约束。  关系（Relationship）：关系是指表之间的联系和连接。通过外键建立的关联关系可以帮助我们在多个表之间进行数据查询和操作，实现数据的关联和一致性。  SQL（Structured Query Language）：SQL 是关系型数据库管理系统用于操作数据的标准语言。通过 SQL，用户可以执行各种操作，包括数据的查询、插入、更新、删除等，以及表的创建、修改、删除等管理操作。  事务（Transaction）：事务是一系列数据库操作的集合，它要么全部执行成功，要么全部失败，具有原子性、一致性、隔离性和持久性（ACID 特性）。  范式（Normalization）：范式是用于设计关系型数据库模式的一组规范化原则，旨在减少数据冗余和提高数据的存储效率。通过范式化设计，可以确保数据库的数据结构合理和标准化。数据引擎            存储引擎      特点      优点      缺点      适用场景                  InnoDB      支持事务、行级锁、外键约束      数据完整性强，支持高并发      内存消耗较大，性能相对较低      事务处理型应用，如电子商务平台、金融系统等              MyISAM      不支持事务、支持全表锁、查询性能较快      查询性能好，适用于读操作较多的场景      不支持事务、容易出现表级锁、不适合高并发写入      读操作较多、写操作较少的应用，如博客、新闻网站等              Memory      将数据存储在内存中，快速的数据访问速度      读写速度极快，适用于临时表和缓存数据      数据不持久化，服务器重启后数据丢失      临时表、缓存数据等需要快速访问的临时性数据存储              CSV      将数据存储在 CSV 文件中      适用于导入/导出数据到 CSV 文件      不支持事务、不支持索引、不适合大规模数据操作      导入/导出数据到 CSV 文件              Archive      高压缩比，适用于数据归档和备份等场景      压缩比高，适用于归档和备份数据      不支持事务、不支持索引、不适合频繁读写操作      数据归档、备份等场景              Blackhole      写入的数据被丢弃，适用于数据复制和转发      用于数据复制和转发      不保存数据，仅用于数据转发      数据复制、数据转发等场景              NDB Cluster      分布式存储和高可用性特性      提供高可用性和水平扩展能力，适用于分布式存储      配置和管理复杂，性能相对较低      需要高可用性和水平扩展能力的分布式存储场景      SQL 语言            分类      简称      描述                  DDL (Data Definition Language)      定义      用于定义、修改和删除数据库对象（表、索引等）的语言。包括 CREATE、ALTER、DROP 等命令。              DML (Data Manipulation Language)      操作      用于对数据库中的数据进行操作的语言。包括 INSERT、UPDATE、DELETE 等命令。              DQL (Data Query Language)      查询      用于从数据库中检索数据的语言。主要命令是 SELECT。              DCL (Data Control Language)      控制      用于控制数据库访问权限和用户管理的语言。包括 GRANT、REVOKE 等命令。              TCL (Transaction Control Language)      事务      用于管理数据库事务的语言。包括 COMMIT、ROLLBACK、SAVEPOINT 等命令。      索引            索引类型      特点      优势      劣势      适用场景                  B-Tree 索引      支持精确查找和范围查找，适用于大多数查询      支持范围查询、排序和分组等操作      查询的效率受数据量和索引列的数据分布影响      WHERE 子句中的条件查询，等值查询、范围查询等操作              哈希索引      适用于等值查询，具有快速的查找速度      查找速度快      不支持范围查询、排序和分组等操作      内存中的临时表和内存表              全文索引      用于全文搜索，支持文本内容的快速检索      支持对文本内容进行全文搜索和相关性排序      不适用于精确匹配和排序      需要进行全文搜索的场景，如博客、论坛等包含大量文本内容的应用              空间索引      用于对空间数据进行查询，支持空间对象的查询      支持距离查询、相交查询等空间操作      不适用于非空间数据      地图应用、位置服务等需要处理空间数据的应用场景      字符集            字符集      描述      优点      缺点                  UTF-8      可变长度的 Unicode 编码方式，支持多种语言字符集合      支持多国语言字符集，适用于国际化应用      部分字符占用多个字节存储空间，可能导致存储空间浪费              GBK      国家标准 GB 2312-80 的扩展，支持简体中文字符集      支持中文字符集，存储效率高      不支持多国语言字符集，无法满足国际化应用需求              Latin1      西欧字符集，支持西欧语言的字符集合      存储效率高，适用于只需要支持西欧语言的应用      不支持多国语言字符集，无法满足国际化应用需求              UTF8MB4      UTF-8 的超集，支持四字节的 Unicode 字符，包括 emoji 表情符号等      支持更广泛的字符集，适用于需要存储 emoji 表情符号等四字节 Unicode 字符的应用      相比 UTF-8，存储空间消耗较大              UTF16      Unicode 编码方式，每个字符占用 16 位（两个字节）      支持较多的字符集，存储效率较高      相比 UTF-8，存储空间消耗较大      数据类型            数据类型      描述      存储范围      大小      Go                  INT      整数类型，通常用于存储整数值      -2147483648 到 2147483647      4 字节      int32              BIGINT      大整数类型，用于存储较大的整数值      -9223372036854775808 到 9223372036854775807      8 字节      int64              FLOAT      单精度浮点数类型，用于存储小数值      精度为大约 7 位小数      4 字节      float32              DOUBLE      双精度浮点数类型，用于存储双精度小数值      精度为大约 15 位小数      8 字节      float64              DECIMAL(M, D)      定点数类型，用于存储精确的小数值      小数位数最大为 M，总位数最大为 M+2      依赖于 M 和 D      Decimal              CHAR(N)      定长字符串类型，用于存储固定长度的字符串      最大长度为 N      最大为 N 字节      string              VARCHAR(N)      变长字符串类型，用于存储可变长度的字符串      最大长度为 N      最大为 N 字节      string              TEXT      变长字符串类型，用于存储较长的文本数据      最大长度为 65,535 字节      最大为 65,535 字节      string              DATE      日期类型，用于存储日期值      ‘1000-01-01’ 到 ‘9999-12-31’      3 字节      time.Time              TIME      时间类型，用于存储时间值      ‘-838:59:59’ 到 ‘838:59:59’      3 字节      time.Time              DATETIME      日期时间类型，用于存储日期和时间值      ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’      8 字节      time.Time              TIMESTAMP      时间戳类型，用于存储日期和时间值      ‘1970-01-01 00:00:01’ 到 ‘2038-01-19 03:14:07’      4 字节      time.Time              BOOLEAN      布尔类型，用于存储逻辑值      TRUE 或 FALSE      1 字节      bool      主键&amp;外键            特点      主键      外键                  定义      用于唯一标识表中的每一行数据的字段，每张表只能有一个主键      用于建立表与表之间的关联关系，指向另一张表的主键或唯一键              唯一性      主键值在表中必须唯一，不允许为空      外键值可以为空，可以重复，但必须与关联表的主键值相对应              数据类型      通常为数值类型或字符串类型，与业务无关      与关联表的主键数据类型一致              作用      保证表中每一行数据的唯一性，可以用于快速定位数据      建立表与表之间的关联关系，确保数据的一致性和完整性              定义方式      可以在表的创建过程中使用 PRIMARY KEY 关键字来定义主键      通常在表的创建过程中使用 FOREIGN KEY 关键字来定义外键              示例      用户表中的用户 ID 字段可以作为主键，保证每个用户 ID 的唯一性      订单表中的用户 ID 字段可以作为外键，与用户表中的用户 ID 建立关联      其他类似的数据库  在数据处理方案中，有几种与 MySQL 类似的关系型数据库管理系统。这些系统在某些方面可能与 MySQL 有相似的特性和功能，但也可能在某些方面有所不同。以下是几种常见的与 MySQL 类似的数据处理方案：  MariaDB：MariaDB 是 MySQL 的一个分支，它由 MySQL 的原始开发者创建，旨在保持与 MySQL 的兼容性，并提供一些新的功能和改进。因此，MariaDB 在很多方面与 MySQL 非常相似，用户可以轻松地迁移和使用 MariaDB。  PostgreSQL：PostgreSQL 是另一个流行的开源关系型数据库管理系统，与 MySQL 相比，它在一些方面提供了更丰富和更高级的功能，如支持更复杂的数据类型、更强大的事务支持、更灵活的权限管理等。尤其在处理复杂数据结构和需要高级特性的应用场景下，PostgreSQL 往往是一个很好的选择。  SQLite：SQLite 是一个轻量级的嵌入式关系型数据库管理系统，与 MySQL 不同，它不是一个独立的数据库服务器，而是直接嵌入到应用程序中，以库的形式提供。SQLite 适用于一些轻量级的应用场景，如移动应用、桌面应用等，它的特点是简单、易于使用，并且不需要单独的服务器进程。  Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它与 MySQL 相比在某些方面有所不同，比如更紧密地集成到 Microsoft 的生态系统中、提供更多的企业级特性和服务等。Microsoft SQL Server 通常用于 Windows 平台上的企业应用程序。"
  },
  
  {
    "title": "开发脚本",
    "url": "/posts/redis-py-utils/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-12-01 11:32:25 +0800",
    





    
    "snippet": "redis 获取所有 key 并且打印输出import redisimport datetime# 设置 Redis 连接参数host = '172.12.12.189'port = 6000password = ''db = 12  # 指定要扫描的数据库编号pattern = '2016:hide:*'  # 匹配以 '2016:' 开头的键# 创建 Redis 客户端redis_cli...",
    "content": "redis 获取所有 key 并且打印输出import redisimport datetime# 设置 Redis 连接参数host = '172.12.12.189'port = 6000password = ''db = 12  # 指定要扫描的数据库编号pattern = '2016:hide:*'  # 匹配以 '2016:' 开头的键# 创建 Redis 客户端redis_client = redis.Redis(host=host, port=port, password=password, db=db)# 切换到指定的数据库redis_client.select(db)def get_hide(redis_client, keys, output_file):    # 打开文件以追加写入    with open(output_file, 'a') as file:        for key in keys:            values = redis_client.hmget(key, \"W\", \"L\")            w = int(values[0]) if values[0] is not None else None            l = int(values[1]) if values[1] is not None else None            split_value = key.split(\":\")            if w is not None and l is not None:                r = w / l                file.write(f\"playerId: {split_value[2]} groupId: {split_value[3]} win: {w} lose: {l} r: {r}\\n\")                print(f\"playerId: {split_value[2]} groupId: {split_value[3]} win: {w} lose: {l} r: {r}\")# 扫描并打印以 '2016:' 开头的键matching_keys = redis_client.scan_iter(match=pattern, count=1000)matching_keys = [key.decode() for key in matching_keys]# 获取当前时间current_time = datetime.datetime.now()# 将当前时间格式化为字符串formatted_time = current_time.strftime(\"%Y%m%d%H%M%S\")get_hide(redis_client, matching_keys, f\"hide_{formatted_time}.txt\")日志分析import osimport refrom collections import defaultdictdef search_files(directory, pattern):    matches = []    for root, dirs, files in os.walk(directory):        for file in files:            file_path = os.path.join(root, file)            try:                with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:                    matches.extend(re.findall(pattern, f.read()))            except UnicodeDecodeError:                print(f\"Error decoding file: {file_path}\")    return matchesdef rate(directory, pattern):    results = defaultdict(dict)    matches = search_files(directory, pattern)    for match in matches:        pId, C, W, L, rate = match        results[pId].update({\"C\": C, \"W\": W, \"L\": L, \"rate\": round(float(rate), 4)})    return resultsdef jackpot_buy(directory, pattern):    results = defaultdict(int)    matches = search_files(directory, pattern)    for match in matches:        pId, number = match        results[pId] += int(number)    return resultsdef jackpot_win(directory, pattern):    results = defaultdict(int)    matches = search_files(directory, pattern)    for match in matches:        pId, win = match        results[pId] += int(win)    return resultsdef jackpot_win_type(directory, pattern, output_file):    matches = search_files(directory, pattern)    with open(output_file, 'w', encoding='utf-8') as f_out:        for match in matches:            cardType, winType, number = match            result = f\"cardType: {cardType} winType: {winType} number: {number}\\n\"            f_out.write(result)def merge_data(rates, jackpot_buy, jackpot_win):    merged_data = defaultdict(dict)    for pId, data in rates.items():        merged_data[pId].update(data)    for pId, buy in jackpot_buy.items():        merged_data[pId]['buy'] = buy    for pId, win in jackpot_win.items():        merged_data[pId]['win'] = win    return merged_datadef write_to_file(data, output_file):    with open(output_file, 'w', encoding='utf-8') as f:        for pId, values in data.items():            line = f\"pId: {pId} {' '.join(f'{key}: {value}' for key, value in values.items())}\\n\"            f.write(line)rate_search = r\"PlayerExit pId:(\\d+) C:(\\d+) W:(\\d+) L:(\\d+) rate:([\\d.]+)\"jackpot_buy_search = r\"BugJp:(\\d+) number:(\\d+)\"jackpot_win_search = r\"pId:(\\d+) jpWin:(\\d+)\"jackpot_win_type_search = r\"JackpotWinType cardType:(\\d+) winType:(\\d+) number:(\\d+)\"# jackpotjackpot_win_type(\"./logs/bonustexas_a_1/\", jackpot_win_type_search, \"./all/1-jackpot_win_type.txt\")jackpot_win_type(\"./logs/bonustexas_a_2/\", jackpot_win_type_search, \"./all/2-jackpot_win_type.txt\")jackpot_win_type(\"./logs/bonustexas_a_3/\", jackpot_win_type_search, \"./all/3-jackpot_win_type.txt\")jackpot_win_type(\"./logs/bonustexas_a_4/\", jackpot_win_type_search, \"./all/4-jackpot_win_type.txt\")directory_1 = './logs/bonustexas_a_1/'  # 当前目录路径output_file_1 = './all/1-all.txt'  # 输出文件名directory_2 = './logs/bonustexas_a_2/'  # 当前目录路径output_file_2 = './all/2-all.txt'  # 输出文件名directory_3 = './logs/bonustexas_a_3/'  # 当前目录路径output_file_3 = './all/3-all.txt'  # 输出文件名directory_4 = './logs/bonustexas_a_4/'  # 当前目录路径output_file_4 = './all/4-all.txt'  # 输出文件名rates_data_1 = rate(directory_1, rate_search)jackpot_buy_data_1 = jackpot_buy(directory_1, jackpot_buy_search)jackpot_win_data_1 = jackpot_win(directory_1, jackpot_win_search)merged_data = merge_data(rates_data_1, jackpot_buy_data_1, jackpot_win_data_1)write_to_file(merged_data, output_file_1)rates_data_2 = rate(directory_2, rate_search)jackpot_buy_data_2 = jackpot_buy(directory_2, jackpot_buy_search)jackpot_win_data_2 = jackpot_win(directory_2, jackpot_win_search)merged_data = merge_data(rates_data_2, jackpot_buy_data_2, jackpot_win_data_2)write_to_file(merged_data, output_file_2)rates_data_3 = rate(directory_3, rate_search)jackpot_buy_data_3 = jackpot_buy(directory_3, jackpot_buy_search)jackpot_win_data_3 = jackpot_win(directory_3, jackpot_win_search)merged_data = merge_data(rates_data_3, jackpot_buy_data_3, jackpot_win_data_3)write_to_file(merged_data, output_file_3)rates_data_4 = rate(directory_4, rate_search)jackpot_buy_data_4 = jackpot_buy(directory_4, jackpot_buy_search)jackpot_win_data_4 = jackpot_win(directory_4, jackpot_win_search)merged_data = merge_data(rates_data_4, jackpot_buy_data_4, jackpot_win_data_4)write_to_file(merged_data, output_file_4)Git Pull#!/bin/bashfunction check_and_pull_git_repositories() {    for repo in $(find \"$1\" -type d -name '.git'); do        repo_dir=$(dirname \"$repo\")        # 切换到Git仓库所在的目录        cd \"$repo_dir\" || continu e        # 执行git pull命令        if ! git pull; then            echo \"执行git pull时出错：$repo_dir\"        fi    done}# 指定要检查的目录directory_to_check=\"/tmp\"check_and_pull_git_repositories \"$directory_to_check\"Grafana 配置备份import osimport requestsimport jsondef export_dashboard_config(grafana_url, api_key, folder_path):    # 设置API请求头    headers = {        'Authorization': f'Bearer {api_key}',        'Content-Type': 'application/json'    }    # 发送API请求获取仪表盘列表    response = requests.get(f'{grafana_url}/search', headers=headers)    if response.status_code == 200:        dashboards = response.json()        # 遍历仪表盘列表        for dashboard in dashboards:            dashboard_uid = dashboard['uid']            dashboard_title = dashboard['title']            # 发送API请求获取仪表盘配置            response = requests.get(f'{grafana_url}/dashboards/uid/{dashboard_uid}', headers=headers)            if response.status_code == 200:                dashboard_data = response.json()                # 提取仪表盘配置                dashboard_config = dashboard_data['dashboard']                # 在这里执行导出仪表盘配置的操作                export_dashboard(dashboard_config, folder_path, dashboard_title)def export_dashboard(dashboard_config, folder_path, dashboard_title):    # 创建文件夹（如果不存在）    if not os.path.exists(folder_path):        os.makedirs(folder_path)    # 生成导出文件路径    file_path = os.path.join(folder_path, f'{dashboard_title}.json')    # 将仪表盘配置保存到文件    with open(file_path, 'w') as f:        json.dump(dashboard_config, f, indent=4)# 调用函数并传入Grafana URL、API密钥和文件夹路径grafana_url = 'http://localhost/api'api_key = 'api'folder_path = 'path'export_dashboard_config(grafana_url, api_key, folder_path)"
  },
  
  {
    "title": "Kubernetes Services",
    "url": "/posts/services/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2023-11-24 10:47:54 +0800",
    





    
    "snippet": "Base      服务类型：                  ClusterIP：                  类型：内部服务          集群内部可访问的虚拟 IP。          仅在集群内部可路由。          默认服务类型。          使用选择器将流量路由到匹配的 Pod。          适用于在集群内部进行内部通信的服务。           ...",
    "content": "Base      服务类型：                  ClusterIP：                  类型：内部服务          集群内部可访问的虚拟 IP。          仅在集群内部可路由。          默认服务类型。          使用选择器将流量路由到匹配的 Pod。          适用于在集群内部进行内部通信的服务。                            NodePort                  类型：外部服务          在每个节点上公开一个固定的端口。          外部流量可以通过节点的 IP 地址和 NodePort 访问服务。          使用选择器将流量路由到匹配的 Pod。          适用于需要从集群外部访问服务的情况。          端口范围：30000-32767                            LoadBalancer：                  类型：外部服务          在云平台上创建外部负载均衡器（如 AWS ELB、GCP Load Balancer 等）。          外部负载均衡器将流量路由到服务。          外部负载均衡器通常会分配一个外部 IP 地址。          使用选择器将流量路由到匹配的 Pod。          适用于需要负载均衡和从集群外部访问服务的情况。                            ExternalName：                  类型：外部服务          提供了对集群外部服务的访问。          将服务映射到集群外部的 CNAME 记录。          不执行任何代理或负载均衡功能。          适用于需要将集群内部服务与集群外部服务进行关联的情况。                      服务选择器（Selectors）：服务使用标签选择器来确定它所关联的后端 Pod。标签选择器允许您定义一组标签，并且只有带有匹配标签的 Pod 才会被服务路由到。  Pod 发现：服务通过与后端 Pod 的标签选择器匹配来发现和管理 Pod。当新的 Pod 被创建或现有的 Pod 发生变化时，服务会自动更新其代理规则，确保流量正确路由到新的 Pod。  端口映射：服务将外部流量路由到后端 Pod 的特定端口上。您可以定义服务的端口和目标端口，其中端口是客户端访问服务的入口，目标端口是服务转发流量到后端 Pod 的端口。  会话亲和性：通过在服务上启用会话亲和性，可以确保来自同一客户端的请求始终被路由到相同的后端 Pod。这对于需要保持会话状态的应用程序非常有用。  Headless 服务：Headless 服务允许直接访问后端 Pod 的 IP 地址，而不是通过虚拟 IP 进行访问。这对某些特定的应用程序和服务发现机制非常有用。  服务代理（Service Proxy）：每个节点上的 kube-proxy 组件负责实现服务的代理功能，它维护了服务和 Pod 之间的网络规则，并将流量正确路由到后端 Pod。Kubernetes 服务提供了一种抽象层，使得应用程序的网络访问更加灵活和可靠。通过使用标签选择器、端口映射和服务类型，您可以根据应用程序需求定义和配置服务，并将流量路由到后端 Pod。Error      端口冲突错误：当您尝试创建一个服务时，如果所选的端口已经被其他服务占用，将会出现端口冲突错误。          解决方法：选择一个未被占用的端口或者检查是否存在重复的服务定义。确保每个服务都使用唯一的端口。            选择器错误：服务的选择器用于标识要与之关联的 Pod。如果选择器与 Pod 的标签不匹配，服务将无法正确路由流量。          解决方法：确保服务的选择器与 Pod 的标签匹配。检查服务和 Pod 的标签定义，确保它们具有相同的键和值。            缺少目标端口错误：在服务配置中，如果未正确指定目标端口，将无法将流量正确路由到 Pod。          解决方法：确保在服务配置中指定了正确的目标端口，以便流量正确路由到 Pod 上运行的应用程序。            防火墙或网络策略错误：如果防火墙或网络策略限制了对服务的访问，可能导致服务不可访问。          解决方法：检查防火墙规则和网络策略，确保允许对服务的访问。如果使用云平台，确保负载均衡器或入口控制器的配置正确。            服务类型错误：选择错误的服务类型可能会导致无法实现预期的流量路由或外部访问。          解决方法：根据需求选择正确的服务类型。ClusterIP 用于集群内部通信，NodePort 用于外部访问，LoadBalancer 用于云平台负载均衡，ExternalName 用于将服务映射到外部域名。            清单文件语法错误：在编写服务配置的清单文件时，语法错误可能导致服务无法正确部署。          解决方法：仔细检查清单文件的语法，确保正确使用缩进、冒号和连字符等符号。您可以使用 kubectl apply命令的 --dry-run选项来检查清单文件的语法错误。      "
  },
  
  {
    "title": "Kubernetes Pod",
    "url": "/posts/pod/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2023-11-24 10:46:54 +0800",
    





    
    "snippet": "Base  容器组合：Pod 是一个逻辑上的容器组合，可以包含一个或多个容器。这些容器在 Pod 内部共享相同的命名空间和网络，可以通过 localhost 相互通信。Pod 内的容器通常协同工作，处理应用程序的不同部分或服务。  网络和 IP 地址：每个 Pod 都有一个唯一的 IP 地址，用于在集群内部或集群外部进行访问。Pod 内的所有容器共享相同的网络命名空间，它们可以使用相同的 I...",
    "content": "Base  容器组合：Pod 是一个逻辑上的容器组合，可以包含一个或多个容器。这些容器在 Pod 内部共享相同的命名空间和网络，可以通过 localhost 相互通信。Pod 内的容器通常协同工作，处理应用程序的不同部分或服务。  网络和 IP 地址：每个 Pod 都有一个唯一的 IP 地址，用于在集群内部或集群外部进行访问。Pod 内的所有容器共享相同的网络命名空间，它们可以使用相同的 IP 地址和端口空间进行通信。这使得容器之间的通信更加简单，可以使用本地主机地址（localhost）进行通信。  存储和卷：Pod 可以使用存储卷（Volume）来共享和持久化数据。存储卷可以附加到 Pod 中的一个或多个容器，并提供持久化的文件系统或数据卷。这使得多个容器可以通过共享卷进行文件共享或数据交换。  生命周期管理：Pod 有一个生命周期，它从创建状态开始，经过运行状态，最终终止。Pod 的生命周期由 Kubernetes 控制器（如 Deployment）管理。控制器负责创建和销毁 Pod，确保 Pod 的期望状态与实际状态一致。  调度和节点：Pod 需要被调度到 Kubernetes 集群中的某个节点上才能运行。调度器（Scheduler）负责根据节点的资源、亲和性和其他策略将 Pod 分配给合适的节点。Pod 可以在不同的节点上进行迁移和重新调度。  健康检查：Kubernetes 提供了健康检查机制，用于监测 Pod 的健康状态。Liveness 探针用于检测容器是否存活，如果容器失败，则会重新启动容器。Readiness 探针用于检测容器是否准备好接收流量，如果容器未准备好，则不会将流量路由到该容器。  控制器和副本：Pod 可以由不同类型的控制器管理，例如 Deployment、StatefulSet、DaemonSet 等。这些控制器负责确保 Pod 的副本数量和状态与期望的配置一致。控制器还支持自动伸缩、滚动更新和故障恢复等功能。  多容器模式：Pod 支持多容器模式，其中多个容器可以在同一个 Pod 内运行。这些容器共享相同的资源和网络，并可以协同工作。多容器模式适用于共享文件、共享环境变量、辅助边车容器等场景。Pod 是 Kubernetes 中最基本的部署单元，它提供了容器之间共享资源、协同工作和紧密集成的环境。Pod 的设计目标是支持微服务架构和容器化应用程序的部署需求。READYPod 的 READY 状态（就绪状态）表示 Pod 中的容器是否已经准备好接收请求。READY 列通常以 X/Y的格式显示，其中 X表示当前已经就绪的容器数量，Y表示 Pod 中总容器数量。以下是一些可能的 READY 状态及其解释：      0/1：Pod 中的一个容器已经创建，但尚未就绪。          处理方法：检查容器的日志和事件，确定容器为何无法就绪。可能的原因包括应用程序启动失败、依赖项缺失或配置问题等。            1/1：Pod 中的一个容器已经就绪并运行。          表示该 Pod 中的所有容器都已经成功启动，并且已准备好接收请求。            2/2：Pod 中的所有容器都已经就绪并运行。          如果 Pod 中有多个容器，READY 状态中的数字表示已经就绪的容器数量和总容器数量。      如果 Pod 的 READY 状态不是预期的状态，可能需要检查以下几个方面：  容器的启动命令和配置是否正确。  容器所需的资源（如 CPU、内存）是否足够。  Pod 中的容器之间是否存在依赖关系，需要确保所有相关容器都已经就绪。  如果使用了 Init Container（初始化容器），确保 Init Container 已经成功完成并退出。  检查 Pod 的事件和日志，以获取更多关于就绪状态的信息。Status      Running（运行中）：          表示 Pod 正在运行，并且所有容器都处于运行状态。      这是预期的健康状态，表示 Pod 正常运行。            Succeeded（已成功）：          表示 Pod 中的所有容器已成功完成任务并退出。      适用于执行一次性作业的 Pod，如批处理任务。            Pending（等待中）：          错误原因：Pod 正在等待调度到节点上，并且尚未开始运行。      处理方法：确保有足够的节点资源（CPU、内存等）可供调度 Pod，并且没有其他问题阻止 Pod 的调度。可以通过 kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt; 命令查看 Pod 的详细描述，了解导致等待的具体原因。            Failed（失败）：          表示 Pod 中的一个或多个容器已经退出，并且至少有一个容器以非零状态退出。      可能的原因包括应用程序错误、依赖项问题或配置错误。            Unknown（未知）：          表示无法获取 Pod 的状态信息。      可能的原因包括与 Pod 所在节点的通信问题或 Kubernetes 控制平面故障。            CrashLoopBackOff（容器崩溃循环）：          错误原因：容器启动后立即崩溃，并在循环中重新启动。      处理方法：查看容器的日志（kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;）以获取有关容器崩溃的详细信息。修复容器内部的问题，例如应用程序错误、依赖项缺失等。            ContainerCreating（容器创建中）：          错误原因：Pod 的容器正在创建中，可能由于镜像拉取、初始化等操作导致的延迟。      处理方法：检查 Pod 所在节点的网络连接，确保可以访问所需的镜像仓库。确保 Pod 的镜像名称和凭证配置正确。如果问题持续存在，可能需要检查节点资源（如磁盘空间）是否充足。            ImagePullBackOff（镜像拉取失败）：          错误原因：Pod 无法拉取所需的容器镜像。      处理方法：检查 Pod 指定的镜像名称和标签是否正确，确保可以从所在节点的容器运行环境访问到镜像仓库。验证镜像仓库凭证是否正确配置。            ErrImagePull（镜像拉取错误）：          错误原因：Pod 无法拉取所需的容器镜像。      处理方法：检查 Pod 指定的镜像是否存在、镜像仓库地址是否正确，以及节点是否具有访问镜像仓库的网络连接。验证镜像名称、标签和仓库地址是否正确。      Pod 的状态（Status）在 Kubernetes 中描述了 Pod 的当前状态。以下是一些常见的 Pod 状态及其解释："
  },
  
  {
    "title": "Kubernetes Deploymen",
    "url": "/posts/deployment/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2023-11-24 10:46:54 +0800",
    





    
    "snippet": "Base      副本集（ReplicaSet）: Deployment 使用副本集来确保指定数量的 Pod 副本在集群中运行。副本集定义了 Pod 的模板和副本数量，并负责监控 Pod 的运行状态。如果 Pod 发生故障或被删除，副本集将自动创建新的 Pod 来替换它。        声明式配置: Deployment 使用声明式的方式来定义应用程序的部署状态。您可以编写一个 Deplo...",
    "content": "Base      副本集（ReplicaSet）: Deployment 使用副本集来确保指定数量的 Pod 副本在集群中运行。副本集定义了 Pod 的模板和副本数量，并负责监控 Pod 的运行状态。如果 Pod 发生故障或被删除，副本集将自动创建新的 Pod 来替换它。        声明式配置: Deployment 使用声明式的方式来定义应用程序的部署状态。您可以编写一个 Deployment 配置文件，描述应用程序的期望状态，包括副本数量、容器镜像、环境变量、资源限制等。Kubernetes 将根据配置文件的定义来创建和管理 Pod 副本。        滚动更新: Deployment 支持滚动更新应用程序的新版本。您可以更新 Deployment 的配置文件，例如更新容器镜像的版本，然后 Kubernetes 会逐步创建新的 Pod 副本并停止旧的 Pod 副本，以实现平滑的应用程序更新。        回滚操作: 如果应用程序更新后出现问题，Deployment 允许您回滚到先前的稳定版本。您可以使用 Deployment 的回滚功能，将应用程序回滚到以前的配置状态，以恢复应用程序的正常运行。        扩缩容: Deployment 允许您根据负载情况对应用程序进行弹性扩缩容。通过调整 Deployment 的副本数量，可以增加或减少运行中的 Pod 副本数量，以适应不同的流量需求。        自愈能力: 如果 Pod 副本发生故障或节点发生故障，Deployment 会自动替换故障的 Pod，并确保应用程序的可用性和稳定性。  "
  },
  
  {
    "title": "Rust Tools",
    "url": "/posts/rust-tools/",
    "categories": "Language, Rust",
    "tags": "Server, Rust",
    "date": "2023-11-06 11:58:36 +0800",
    





    
    "snippet": "Cargo  Cargo 是 Rust 的构建工具和包管理器。它用于创建、构建、测试和发布 Rust 项目，以及管理项目的依赖关系。      示例：创建一个新的 Rust 项目并构建它。    cargo new my_projectcd my_projectcargo build      Cargo Clippy  Cargo Clippy 是一个 Rust 静态分析工具，用于检测和纠...",
    "content": "Cargo  Cargo 是 Rust 的构建工具和包管理器。它用于创建、构建、测试和发布 Rust 项目，以及管理项目的依赖关系。      示例：创建一个新的 Rust 项目并构建它。    cargo new my_projectcd my_projectcargo build      Cargo Clippy  Cargo Clippy 是一个 Rust 静态分析工具，用于检测和纠正潜在的代码问题和风格建议。      示例：运行 Clippy 来检查代码。    cargo clippy      Cargo Fmt  Cargo Fmt 是 Rust 的代码格式化工具，用于自动格式化 Rust 代码，以确保代码风格的一致性。      示例：使用 Cargo Fmt 格式化 Rust 代码。    cargo fmt      Cargo Miri  Cargo Miri 是 Rust 的直译器，用于执行 Rust 代码并检测潜在的内存安全问题。      示例：使用 Miri 运行 Rust 代码来检查内存安全性。    cargo miri run      Clippy Driver  Clippy Driver 是 Clippy 静态分析工具的驱动程序，用于运行 Cargo Clippy 并提供代码建议和检测。      示例：使用 Clippy Driver 运行 Clippy 来检查代码。    clippy-driver      RLS (Rust Language Server)  RLS 是 Rust 的语言服务器，为 Rust 编辑器提供了代码补全、导航、重构和文档功能，以增强 Rust 开发体验。  示例：在支持 RLS 的 Rust 编辑器中使用 RLS 功能。Rust GDB (GNU Debugger)  Rust GDB 是 Rust 的 GDB 调试器，用于调试 Rust 程序。      示例：使用 GDB 调试 Rust 程序。    rust-gdb your_program      Rust GDBGUI  Rust GDBGUI 是 Rust 的图形用户界面 (GUI) 调试器，用于通过图形界面进行 Rust 程序的调试。  示例：使用 Rust GDBGUI 来调试 Rust 程序。Rust LLDB (LLVM Debugger)  Rust LLDB 是 Rust 的 LLDB 调试器，类似于 GDB，用于调试 Rust 代码。      示例：使用 LLDB 调试 Rust 程序。    rust-lldb your_program      Rustc  Rustc 是 Rust 的编译器，用于将 Rust 源代码编译成可执行文件或库。      示例：使用 rustc 编译 Rust 程序。    rustc your_program.rs      Rustdoc  Rustdoc 是 Rust 的文档生成工具，用于生成 Rust 代码的文档，包括标准库和用户编写的文档。      示例：生成 Rust 代码的文档。    rustdoc your_program.rs      Rustfmt  Rustfmt 是 Rust 的代码格式化工具，用于自动格式化 Rust 代码，以确保代码风格的一致性。      示例：使用 rustfmt 格式化 Rust 代码。    rustfmt your_program.rs      Rustup  Rustup 是 Rust 工具链的安装和管理工具，用于安装、升级和管理 Rust 的不同版本，以及管理工具链组件。      示例：使用 rustup 安装 Rust 工具链或切换 Rust 版本。    rustup install stable      "
  },
  
  {
    "title": "Rust",
    "url": "/posts/rust/",
    "categories": "Language, Rust",
    "tags": "Server, Rust",
    "date": "2023-11-06 10:58:36 +0800",
    





    
    "snippet": "系统环境配置  vim /etc/profile 追加export CARGO_HOME=$HOME/.cargoexport RUSTUP_HOME=$HOME/.rustupexport RUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-staticexport RUSTUP_UPDATE_ROOT=http://mirrors.ust...",
    "content": "系统环境配置  vim /etc/profile 追加export CARGO_HOME=$HOME/.cargoexport RUSTUP_HOME=$HOME/.rustupexport RUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-staticexport RUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustupexport PATH=\"$HOME/.cargo/bin:$PATH\"配置源  cd ～.cargo  touch config      vim config    [source.crates-io]replace-with = 'rsproxy-sparse'[source.rsproxy]registry = \"https://rsproxy.cn/crates.io-index\"[source.rsproxy-sparse]registry = \"sparse+https://rsproxy.cn/index/\"[registries.rsproxy]index = \"https://rsproxy.cn/crates.io-index\"[net]git-fetch-with-cli = true      基本命令rustc  rustc --version  rustup update stable  rustc main.rscargo  cargo --version  cargo run  cargo check  cargo build  cargo build --release 发布版本  cargo update  cargo tree  cargo doc  cargo publish 推送 io 包管理目录基本变量fn main() {    let nub = 5; // 不可变    println!(\"{}\", nub);    // nub = 10; // cannot assign twice to immutable variable 不可以变    let mut nub2 = 10;    /*    如果不加着一行会报错 nub2    = help: maybe it is overwritten before being read?    = note: `#[warn(unused_assignments)]` on by default    */    println!(\"{}\", nub2);    nub2 = 11;    println!(\"{}\", nub2)}常量  不可以使用 mut，常量永远都是不可变的  声明常量使用 const 关键字，它的类型必须被标注  常量可以在任何作用域内进行声明，包括全局作用域  常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值const LANGUAGE: &amp;'static str = \"Rust\";const NOT_FOUNT: i32 = 404;fn main() {    const DAY: i32 = 1;    println!(\"{}\", DAY);    println!(\"{}\", NOT_FOUNT);    println!(\"{}\", LANGUAGE);}覆盖（Shadowing）  demo1fn main() {    let x = 8;    println!(\"{}\", x);    let x = x + 1;    println!(\"{}\", x);    let x = x * 2;    println!(\"{}\", x);}/*8918*/  demo2fn main() {    let ss = \"   \"; // str    let aa = ss.len(); // usize    println!(\"{}\", aa)}数据类型  整数溢出          u8 的值时 0-255，如果设置 u8 的值设置了 256                  在变异模式下 build 情况下运行时会 panic          在发布模式下 -- release 不会panic 会执行环绕操作;                          256=0              257=1                                            基础展示fn main() {    // ********************类型********************    // 常规声明    let nub: i32 = 5;    // 后缀声明    let an_integer = 5i32;    // 自动推导类型    let x = 42; // x has type i32    let y = 1.0; // y has type f64    println!(\"整型 {} {} {} {}\", nub, an_integer, x, y);    // ********************bool********************    let t = true;    let f: bool = false;    println!(\"bool {} {}\", t, f);    // ********************char********************    let x = 'x';    let two_hearts = '💕';    println!(\"char {} {}\", x, two_hearts);}            Data Type      Description      Example                  i8      8-bit signed integer      let num: i8 = -5;              i16      16-bit signed integer      let num: i16 = -200;              i32      32-bit signed integer      let num: i32 = -2000;              i64      64-bit signed integer      let num: i64 = -200000;              i128      128-bit signed integer      let num: i128 = -2000000000;              u8      8-bit unsigned integer      let num: u8 = 5;              u16      16-bit unsigned integer      let num: u16 = 200;              u32      32-bit unsigned integer      let num: u32 = 2000;              u64      64-bit unsigned integer      let num: u64 = 200000;              u128      128-bit unsigned integer      let num: u128 = 2000000000;              f32      32-bit floating-point      let num: f32 = 3.14;              f64      64-bit floating-point      let num: f64 = 3.14159265359;              bool      Boolean (true or false)      let is_true: bool = true;              char      Unicode character      let ch: char = 'A';              str      String (slice of UTF-8 characters)      let s: &amp;str = \"Hello, Rust!\";        数字可读性          数字可以加上前缀 0x、0o、0b 分别表示十六进制数、八进制数、二进制数      为了改善数字的可读性，可以在数字类型之间加上下划线(_)，比如： 1_000 等同于 1000， 0.000_001 等同于 0.000001      fn main() {    println!(\"{}\", 0xABCDEFu32);    println!(\"{}\", 0o12345670i32);    println!(\"{}\", 0b00110011u32);    println!(\"{}\", 1_000_000u32);}/*112593752739128511000000*/数组  栈内存API      创建数组：          let arr: [T; N] = [value1, value2, ...];: 创建一个包含指定类型 T 和大小 N 的数组，其中元素的值初始化为指定的值。            访问数组元素：          使用方括号 [] 和索引来访问数组元素。例如：let element = arr[index];            数组长度：          数组的长度可以通过 .len() 方法获取：let len = arr.len();            数组迭代：          你可以使用 iter() 方法来迭代数组的元素：          for element in arr.iter() {      // 处理每个元素  }            查找元素：          使用 .contains() 方法检查数组是否包含特定元素。返回 bool 值。例如：let contains_value = arr.contains(&amp;value);            数组切片：          你可以使用切片来获取数组的一部分元素。例如，获取前两个元素：let slice = &amp;arr[0..2];            比较数组：          使用 == 运算符来比较两个数组是否相等。例如：if arr1 == arr2 { /* 数组相等 */ }            数组排序：          你可以使用 .sort() 方法对数组进行排序。要求数组的元素类型实现了 Ord trait。例如：arr.sort();            查找最大值和最小值：          使用 .iter().max() 和 .iter().min() 方法来查找数组中的最大值和最小值。            数组转换为向量（Vec）：          使用 .to_vec() 方法将数组转换为动态大小的向量。例如：let vec = arr.to_vec();            数组转换为切片：          数组可以通过引用转换为切片：let slice: &amp;[T] = &amp;arr;        请注意，由于数组的大小是固定的，所以很多向量操作（如添加和删除元素）在数组上不可用。如果你需要更灵活的数据结构，可以考虑使用 Rust 的 Vec 类型，它支持动态大小。examplefn main() {    // 创建一个包含5个整数的数组    let mut numbers: [i32; 5] = [1, 2, 3, 4, 5];    for value in numbers.iter() {        println!(\"number {}\", value)    }    println!(\"第一个值：{}\", numbers[0]);    println!(\"最后一个值：{}\", numbers[numbers.len() - 1]);    numbers[2] = 100; // 如果修改的话，需要把numbers 的改为 mut 可变即可    println!(\"number 2 -&gt; {}\", numbers[2]);    numbers.sort(); //    println!(\"Reversed Sorted Numbers {:?}\", numbers);    let value = 202;    let contains = numbers.contains(&amp;value);    println!(\"contains -&gt; {}\", contains);    numbers.sort_by(|a, b| b.cmp(a));    println!(\"Reversed Sorted Numbers {:?}\", numbers);    let max_value = numbers.iter().max();    let mut max: i32 = 0;    match max_value {        Some(&amp;max_value) =&gt; {            max = max_value;            println!(\"The maximum number in the array is: {}\", max_value);        }        None =&gt; {            println!(\"The array is empty.\");        }    }    println!(\"max --&gt; {}\", max);    let numbers1 = [1, 2, 3, 4, 0];    // 需要数量相等    if numbers == numbers1 {        println!(\"== true\")    } else {        println!(\"== false\")    }    // 转为向量    let mut numbers1 = numbers1.to_vec();    numbers1.push(1);    // 创建一个动态数组    let mut array_run = vec![1, 2, 3];    println!(\"before {}\", array_run.len());    array_run.push(199); // 向向量中添加元素    println!(\"after {}\", array_run.len());    for value in array_run.iter() {        println!(\"array_run {}\", value)    }}元组（Tuples）  元组（Tuple）是 Rust 中的一种复合数据类型，它可以包含不同类型的值，并且是一个不可变的数据结构。元组是有序的，意味着你可以访问和操作元组中的元素，但一旦创建，元组的内容不能被修改fn main() {    let person = (\"Cc\", 1997_06_12, 168.9);    println!(\"{:?}\", person);    println!(\"{}\", person.0);    println!(\"{}\", person.2);    // 解构元组    let (name, age, height) = person;    println!(\"Name: {}\", name);    println!(\"Age: {}\", age);    println!(\"Height: {} feet\", height);    // 使用元组作为函数返回值    println!(\"{:?}\", get_person())}fn get_person() -&gt; (String, i32, f64) {    return (\"Cc\".to_string(), 11, 9.3);}切片  允许你引用集合（数组、向量、字符串等）的一部分元素而不需要复制整个集合。切片是不可变的，因此不能修改集合的内容，但它们允许你安全地访问集合的子集fn main() {    let numbers = [1, 2, 3, 4, 5];    // 创建一个切片，包含数组的前三个元素    let slice = &amp;numbers[0..3];    // 访问切片元素    for number in slice {        println!(\"Number: {}\", number);    }    // 切片也可以使用简化的语法    let short_slice = &amp;numbers[..2]; // 从开头到索引2（不包括2）    let rest_slice = &amp;numbers[2..]; // 从索引2到末尾    println!(\"{:?} {:?} \", short_slice, rest_slice);    // 字符串切片    let text = \"Hello, Rust!\";    let text_slice = &amp;text[7..11]; // 创建一个包含 \"Rust\" 的字符串切片    println!(\"Text slice: {}\", text_slice);}数组和切片的区别在 Rust 中，数组（Array）和切片（Slice）是两种不同的数据结构，它们有一些重要的区别：可变性 1  数组是固定大小的并且不可变的数据结构。一旦创建，数组的大小和内容都不能更改。  切片是可变大小的，但是切片本身是不可变的。你可以创建一个新的切片来引用相同的数据，并且可以改变切片的大小，但不能更改切片的内容。大小  数组具有固定的大小，一旦定义，其大小不能改变。  切片可以具有可变的大小，可以根据需要引用不同大小的数据。内存分配  数组通常在栈上分配内存，因为它们是固定大小的。  切片引用的数据可以在栈上或堆上分配，取决于切片引用的数据的生存期和所有权关系。索引  数组的元素可以通过索引访问，索引从 0 开始。  切片的元素也可以通过索引访问，使用与数组相同的语法。传递和所有权  数组通常是通过值传递的，这意味着在将数组传递给函数时会复制整个数组。  切片通常通过引用传递，这意味着在将切片传递给函数时，只传递了对数据的引用，而不复制数据。这提高了性能并减少了内存开销。可变性 2  数组中的元素不能被更改，因为数组是不可变的。  切片可以是不可变的，也可以是可变的。可变切片允许修改引用的数据。      下面是一个示例来说明数组和切片之间的差异：    fn main() {    // 创建一个数组    let array = [1, 2, 3, 4, 5];    // 创建一个切片，引用数组的一部分    let slice = &amp;array[1..4];    println!(\"Array: {:?}\", array);    println!(\"Slice: {:?}\", slice);}        注意，切片是对数组的引用，因此在切片中的元素修改会影响原始数组。但是，切片本身是不可变的，因此它的大小和内容不能更改。这是数组和切片之间的一些关键区别。函数  语法fn function_name(parameter1: Type1, parameter2: Type2) -&gt; ReturnType {    // 函数体，包含执行的代码    // 可选的 return 语句用于返回值    // 最后一个表达式的值将作为返回值}  例子fn main() {    add(\"Cc\");    println!(\"{}\", foo(1));}fn add(name: &amp;str) {    println!(\"{}\", name)}fn foo(x: i32) -&gt; i32 {    x + 1}if &amp; forfn main() {    let number = 42;    let is_rainy = true;    let option = Some(10);    let result = 15;    // if 表达式    if number &lt; 0 {        println!(\"Number is negative\");    } else if number == 0 {        println!(\"Number is zero\");    } else {        println!(\"Number is positive\");    }    // if let 表达式（用于模式匹配）    if let Some(value) = option {        println!(\"Option has a value: {}\", value);    } else {        println!(\"Option is None\");    }    // match 表达式（用于更复杂的模式匹配）    match result {        1 =&gt; {            println!(\"Result is 1\")        }        2 | 3 =&gt; println!(\"Result is 2 or 3\"),        4..=10 =&gt; println!(\"Result is between 4 and 10 (inclusive)\"),        _ =&gt; println!(\"Result is something else\"),    }    // while 循环    let mut i = 0;    while i &lt; 5 {        println!(\"While loop: i is {}\", i);        i += 1;    }    // loop 循环    let mut j = 0;    loop {        if j &gt;= 5 {            break;        }        println!(\"Loop: j is {}\", j);        j += 1;    }    // for 循环    let numbers = [1, 2, 3, 4, 5];    for number in numbers.iter() {        println!(\"For loop: Number is {}\", number);    }    // 条件表达式    let weather = if is_rainy { \"rainy\" } else { \"sunny\" };    println!(\"Weather is {} today.\", weather);}特性所有权Stack（栈） &amp; Heap（堆）  Rust 中，Stack（栈）和 Heap（堆）是两个重要的内存区域，它们用于存储不同类型的数据，栈和堆代码在运行时可供使用的内存      Stack（栈）          栈中的数据都必须占用已知固定的大小      以放入值的顺序存储值并以相反顺序取出值      后进先出 （last in ，first out）      增加数据叫做进栈（pushing onto the stack）      移出数据叫做出栈（popping off the stack）            Heap（堆）          在编译时大小未知或大小可能变化的数据，要改为存储堆上      堆是缺乏组织的：当想堆放入数据      内存分配器（memory allocator）在堆的某处找到一块足够大的空位，标记已为使用，并返回一个表示该位未知地址的指针（pointer）      以上这个过程称作在堆上分配内存（allocating on the heap）有时简称为分配（allocating）将数据推入栈中并不被认为是分配            总结          指向放入堆中的数据是已知并且固定大小的      将指针放到栈上，不过当实际数据是，必须访问指针            区别          入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间，其位置总是在栈顶      在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备      访问堆上的数据比访问栈上的数据要慢，因为通过指针来访问            例子  fn main() {    // Stack 上的整数    let x = 5;    let y = x; // 整数是 Copy 类型，值被复制，不会转移所有权    println!(\"x: {}, y: {}\", x, y);    // Heap 上的字符串    let s1 = String::from(\"Hello\");    let s2 = s1; // 字符串不是 Copy 类型，所有权被移动    // 编译错误，s1 不再有效    // println!(\"s1: {}\", s1);    // 正确，s2 拥有字符串    println!(\"s2: {}\", s2);}  在上述示例中，我们创建了整数 x 和字符串 s1。整数是 Copy 类型，因此在将 x 的值复制给 y 后，x 仍然有效。但是，字符串不是 Copy 类型，当将 s1 的所有权移交给 s2 时，s1 不再有效，所有权被转移。这展示了 Stack 和 Heap 上数据的不同行为。要在 Heap 上存储数据，你需要使用 Box、Rc、Arc 等智能指针或内置的数据类型（如 String 和 Vec），它们负责分配和管理 Heap 上的内存。这允许你在 Rust 中有效地管理动态分配的数据，同时保持内存安全。规则  每个值都有一个变量，这个变量是该值的所有者  每个值同时只能右一个所有者  当所有者超出作用域（scope）时，该值将被删除函数所有权函数参数和所有权传递：      所有权的移动：当将具有所有权的值传递给函数时，所有权将从调用方移动到函数内部，调用方将不再拥有该值。    fn take_ownership(s: String) {    // s 拥有 String 的所有权    println!(\"Value: {}\", s);}fn main() {    let s1 = String::from(\"Hello\");    take_ownership(s1); // 所有权被移动到函数    // 编译错误，s1 不再有效    // println!(\"Value: {}\", s1);}            借用：函数可以通过借用（引用）来使用值，而不获取其所有权。不可变引用允许多个部分同时访问值，但不能修改它。    fn borrow(s: &amp;String) {    // s 是 String 的不可变引用    println!(\"Value: {}\", s);}fn main() {    let s1 = String::from(\"Hello\");    borrow(&amp;s1); // 借用 s1，不移动所有权    // 正确，s1 仍然有效    println!(\"Value: {}\", s1);}            可变借用：使用可变引用可以在函数内修改值。  fn modify(s: &amp;mut String) {    s.push_str(\", World\");}fn main() {    let mut s1 = String::from(\"Hello\");    modify(&amp;mut s1); // 使用可变引用修改 s1    println!(\"Value: {}\", s1);}函数返回值和所有权传递：      返回值的所有权：函数可以返回拥有值的所有权，从函数内部移动到调用方。    fn create_string() -&gt; String {    let s = String::from(\"Hello from function\");    s // 所有权被移动到调用方}fn main() {    let s1 = create_string(); // 接收返回值的所有权    println!(\"Value: {}\", s1);}            返回引用：函数也可以返回引用，而不是所有权。    fn get_length(s: &amp;String) -&gt; usize {    s.len() // 返回引用}fn main() {    let s1 = String::from(\"Hello\");    let len = get_length(&amp;s1); // 返回引用，不移动所有权    println!(\"Length: {}\", len);}      Structstruct Person {    name: String,    age: u32,}impl Person {    fn new(name: String, age: u32) -&gt; Person {        Person { name, age }    }    fn get_reference(&amp;self) -&gt; &amp;Person {        self    }    fn update_name(&amp;mut self, new_name: String) {        self.name = new_name;    }    fn say_hello(&amp;self) {        println!(            \"Hello, my name is {} and I'm {} years old.\",            self.name, self.age        );    }}struct Rectangle(u32, u32);impl Rectangle {    fn area(&amp;self) -&gt; u32 {        self.0 * self.1    }}fn main() {    let mut person1 = Person {        name: String::from(\"Cc\"),        age: 26,    };    println!(\"{} {}\", person1.name, person1.age);    person1.name = String::from(\"Holly\");    person1.say_hello();    let mut super_cc = Person::new(String::from(\"Super\"), 18);    let reference = &amp;mut super_cc;    reference.update_name(String::from(\"SuperCC\"));    super_cc.say_hello();    let s = super_cc.get_reference();    s.say_hello();    let rectangle = Rectangle(5, 10);    println!(\"Area: {}\", rectangle.area());}枚举#[derive(Debug)]enum TrafficLight {    Red,    // Yellow,    // Green,}#[derive(Debug)]enum Coin {    Penny,    Nickel,    Dime,    Quarter(UsState),}#[derive(Debug)]enum UsState {    // Alabama,    // Alaska,    NewYork,}impl Coin {    fn value(&amp;self) -&gt; u8 {        match self {            Coin::Penny =&gt; 1,            Coin::Nickel =&gt; 5,            Coin::Dime =&gt; 10,            Coin::Quarter(_) =&gt; 25,        }    }}fn main() {    let red = TrafficLight::Red;    let coin = Coin::Quarter(UsState::NewYork);    println!(\"{:?} {:?}\", red, coin);    match coin {        Coin::Penny =&gt; println!(\"It's a penny!\"),        Coin::Nickel =&gt; println!(\"It's a nickel!\"),        Coin::Dime =&gt; println!(\"It's a dime!\"),        Coin::Quarter(ref state) =&gt; println!(\"It's a quarter from {:?}\", state),    }    println!(\"{}\", coin.value());}// 定义一个函数，用于执行除法操作，可能返回 Some 包含结果，或者 None 表示除法失败。fn divide(dividend: f64, divisor: f64) -&gt; Option&lt;f64&gt; {    if divisor == 0.0 {        None // 如果除数为零，返回 None 表示除法失败。    } else {        Some(dividend / divisor) // 否则返回 Some 包含除法结果。    }}fn main() {    // 调用 divide 函数，进行两次除法操作。    let result1 = divide(10.0, 2.0); // 10.0 / 2.0，成功。    let result2 = divide(5.0, 0.0); // 5.0 / 0.0，失败，除数为零。    // 使用 match 表达式来处理 divide 函数的返回值 result1。    match result1 {        Some(value) =&gt; println!(\"Result 1: {}\", value), // 如果除法成功，打印结果。        None =&gt; println!(\"Result 1: Division by zero!\"), // 如果除法失败，打印错误消息。    }    // 使用 match 表达式来处理 divide 函数的返回值 result2。    match result2 {        Some(value) =&gt; println!(\"Result 2: {}\", value), // 如果除法成功，打印结果。        None =&gt; println!(\"Result 2: Division by zero!\"), // 如果除法失败，打印错误消息。    }}Package/Crate/Modulepackage  可以自定义包  Cargo.toml[package]name = \"rust_cc\"version = \"0.1.0\"edition = \"2021\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[lib]name = \"mylib\"path = \"src/mylib.rs\"[[bin]]name = \"myapp\"path = \"src/main.rs\"[dependencies]  mylib.rspub fn add_numbers(a: i32, b: i32) -&gt; i32 {    a + b}  main.rsfn main() {    let result = mylib::add_numbers(5, 3);    println!(\"Result: {}\", result);}lib 使用  test_lib.rs// 定义一个函数，将两个数字相加pub fn add_numbers(a: i32, b: i32) -&gt; i32 {    a + b}// 定义一个结构体pub struct Person {    pub name: String,    pub age: u32,}// 实现结构体的方法impl Person {    // 打印个人信息    pub fn print_info(&amp;self) {        println!(\"姓名: {}\", self.name);        println!(\"年龄: {}\", self.age);    }}  main.rsmod test_lib;use test_lib::{add_numbers, Person};fn main() {    // 使用自定义库中的函数    let result = add_numbers(5, 3);    println!(\"相加结果: {}\", result);    // 使用自定义库中的结构体和方法    let person = Person {        name: String::from(\"Alice\"),        age: 30,    };    person.print_info();}CrateModule模块（Module）是 Rust 中用于组织和管理代码的一种机制。通过模块，可以将相关的函数、结构体、枚举以及其他项组织在一起，形成一个逻辑上的单元。模块有助于提高代码的可读性、可维护性和重用性。在 Rust 中，模块可以嵌套，形成层级结构。模块可以包含其他模块，从而创建一个模块树。这种层级结构提供了命名空间的概念，防止命名冲突，并允许在不同的模块中定义同名的项。模块的定义使用 mod 关键字，后跟模块名称，例如 mod my_module。模块定义通常放在单独的文件中，文件名与模块名称相匹配，并使用 .rs 扩展名supersuper 关键字在 Rust 中用于访问父模块中的项。它主要用于以下两个方面：      访问父模块中的函数、结构体、常量等：当在子模块中需要访问父模块中定义的项时，可以使用 super 关键字。通过 super 关键字，我们可以在子模块中引用父模块的项，并使用它们的功能。        解决命名冲突：在 Rust 中，模块可以嵌套，并形成层次结构。在这种情况下，可能会发生命名冲突，即在不同层级的模块中存在相同名称的项。使用 super 关键字可以明确指定要访问的是父模块中的项，而不是当前模块或子模块中的同名项。  在使用 super 关键字时，需要注意以下几点：      super 关键字只能在模块内部使用，用于指代父模块。        super 关键字后面需要紧跟两个冒号 ::，用于指定要访问的父模块中的项。        可以多次使用 super 关键字来访问更高层级的父模块中的项。例如，super::super::module1::function() 可以用于访问父模块的父模块中的函数。        父模块中的项必须是公共的（使用 pub 关键字修饰），以便在子模块中能够访问。  通过使用 super 关键字，我们可以在模块层次结构中导航，并在需要时访问父模块中的项。这有助于代码的组织和重用，并解决命名冲突的问题。例子  main.rsmod module1;mod module2;fn main() {    module1::module1::hello_module1();    module2::module2::hello_module2();    let person = module2::module2::Person::new(\"John\", 25);    println!(\"Name: {}\", person.name);    println!(\"Age: {}\", person.age);    module2::module2::print_parent_message();}  module1.rspub mod module1 {    pub fn hello_module1() {        println!(\"Hello from module1!\");    }}  module1.rspub mod module2 {    pub fn hello_module2() {        println!(\"Hello from module2!\");    }    // 声明公共结构体    pub struct Person {        pub name: String,        pub age: u32,    }    pub mod super_test {        pub const MESSAGE: &amp;str = \"Hello from parent module!\";    }    pub fn print_parent_message() {        print!(            \"Message from parent module: {}\",            super::module2::super_test::MESSAGE        );    }    impl Person {        pub fn new(name: &amp;str, age: u32) -&gt; Person {            Person {                name: String::from(name),                age,            }        }    }}use在 Rust 中，use关键字有几种不同的写法，可以根据具体的需求选择适合的形式      导入单个项：    use path::to::module::Item;              这种写法将特定的项（函数、结构体、枚举等）从指定的模块路径导入到当前作用域中。可以在后续代码中直接使用导入的项。            导入多个项：    use path::to::module::{Item1, Item2, Item3};              这种写法可以同时导入多个项，每个项之间用逗号分隔。            导入整个模块：    use path::to::module::*;              这种写法使用通配符*导入指定模块中的所有项。需要注意，使用通配符导入会将模块中的所有项都引入到当前作用域，可能会引起命名冲突，因此需要谨慎使用。            使用as关键字进行重命名：    use path::to::module::Item as RenamedItem;              这种写法将导入的项进行重命名，使其在当前作用域中使用不同的名称。这在解决命名冲突或者简化使用时很有用。            在函数内使用局部作用域：    fn my_function() {    use path::to::module::Item;    // 在函数内部临时导入特定项}              这种写法将use语句放在函数内部，仅在该函数内部的局部作用域中有效。这可以避免全局作用域中的命名冲突。      集合Vector  基本数据同类型fn main() {    println!(\"第一种方式 new\");    let mut vec_new: Vec&lt;i32&gt; = Vec::new();    vec_new.push(1);    vec_new.push(34);    for v_value in vec_new.iter() {        println!(\"{} \", v_value)    }    match vec_new.get(1) {        Some(vec_new) =&gt; println!(\"vec_new get index == {}\", vec_new),        None =&gt; println!(\"index error\"),    }    println!(\"vec_new len {}\", vec_new.len());    println!(\"\\n第二种方式 宏\");    let mut vec_h = vec![1, 3, 55];    vec_h.push(120);    for v_value in vec_h.iter() {        println!(\"{} \", v_value)    }    println!(\"{}\", vec_h[0]);    println!(\"vec_h len {}\", vec_h.len());    println!(\"\");    vec_new.remove(0);    vec_h.remove(0);    println!(\"vec_new len {}\", vec_new.len());    println!(\"vec_h len {}\", vec_h.len());    println!(\"\\n遍历方式\");    for element in &amp;vec_new {        println!(\"{}\", element);    }    let mut vec_x = Vec::new();    vec_x.push(\"Cc\");    vec_x.push(\"Holly\");    println!(\"{:?}\", vec_x);}  不同类型–枚举// #[derive(Debug)]enum Element {    Integer(i32),    Int(i32),    Float(f64),    Text(String),}fn main() {    let mut v_new: Vec&lt;Element&gt; = Vec::new();    v_new.push(Element::Integer(10));    v_new.push(Element::Int(100));    v_new.push(Element::Float(10.11));    v_new.push(Element::Text(String::from(\"Super\")));    for element in &amp;v_new {        match element {            Element::Integer(value) =&gt; println!(\"{}\", value),            Element::Int(value) =&gt; println!(\"{}\", value),            Element::Float(value) =&gt; println!(\"{}\", value),            Element::Text(value) =&gt; println!(\"{}\", value),        }    }    // println!(\"{:?}\", v_new);    let v_t = vec![        Element::Integer(1),        Element::Int(100),        Element::Float(10.11),        Element::Text(String::from(\"Super\")),    ];    for element in &amp;v_t {        match element {            Element::Integer(value) =&gt; println!(\"{}\", value),            Element::Int(value) =&gt; println!(\"{}\", value),            Element::Float(value) =&gt; println!(\"{}\", value),            Element::Text(value) =&gt; println!(\"{}\", value),        }    }    // println!(\"{:?}\", v_t)}  在运行（\"{:?}\"）运行失败原因，必须增加#[derive(Debug)]原因          在 Rust 中，#[derive(Debug)]是一个用于自动生成实现 Debug trait 的属性（Attribute）Debug trait 是一个用于打印调试信息的特征，它提供了一个默认的格式化输出在你的代码中，通过在 Element 枚举上添加#[derive(Debug)]，你告诉编译器自动生成实现 Debug trait 的代码这样做的好处是，在使用 println!宏打印 v_new 和 v_t 时，可以使用{:?}格式化符号来打印整个 Vec 及其中的元素。如果没有添加#[derive(Debug)]，println!宏将无法直接打印 Vec 和枚举类型，因为它们默认情况下没有实现 Debug trait。通过添加#[derive(Debug)]，Rust 编译器会自动为你的类型生成一个合适的调试输出，使得你可以方便地打印和调试你的代码。需要注意的是，Debug trait 是标准库提供的，它通常用于调试目的。如果你希望自定义打印的格式，可以实现自己的 Debug trait 方法。      StringHashMap"
  },
  
  {
    "title": "clash",
    "url": "/posts/linux-vpn-clash/",
    "categories": "DevOps, Software",
    "tags": "LinuxTool, Software",
    "date": "2023-10-10 08:06:01 +0800",
    





    
    "snippet": "docker-composeversion: \"3\"services:  clash:    container_name: clash    image: dreamacro/clash    restart: always    volumes:      - ./config/:/root/.config/clash      - ./ui:/ui:ro # 仪表盘 Volume 映射...",
    "content": "docker-composeversion: \"3\"services:  clash:    container_name: clash    image: dreamacro/clash    restart: always    volumes:      - ./config/:/root/.config/clash      - ./ui:/ui:ro # 仪表盘 Volume 映射    ports:      - \"7890:7890\" # HTTP      - \"7891:7891\" # Socket      - \"9090:9090\" # ui配置文件  config/config.yaml# HTTP 代理监听端口port: 7890# SOCKS5 代理监听端口socks-port: 7891# 允许本地连接的 IP 地址和 CIDR 子网掩码allow-lan: truelocal-address: \"0.0.0.0\"external-ui: /uiexternal-controller: \"0.0.0.0:9090\"# 拦截所有 DNS 请求，使用特定的 DNS 服务器dns:  enable: true # set true to enable dns (default is false)  ipv6: false # default is false  listen: 0.0.0.0:53  # enhanced-mode: fake-ip # or redir-host  # fake-ip-range: 198.18.0.1/16 # if you don't know what it is, don't change it  nameserver:    - 172.13.0.7    - 172.13.0.8  fallback: # concurrent request with nameserver, fallback used when GEOIP country isn't CN    - 114.114.114.114    - tcp://1.1.1.1    - 8.8.8.8    - 8.8.4.4  # fallback-filter:  #   geoip: true # default  #   ipcidr: # ips in these subnets will be considered polluted  #     - 240.0.0.0/4# 代理服务器配置proxies:  - name: \"vless\"    type: vless    server: server    port: port    uuid: uuid    alterId: 0 # 和服务端一样即可    tls: true  - name: \"test\"    type: ss    server: ip    port: port    cipher: aes-256-gcm    password: \"password\"    udp: false# 规则集配置rules:  # - DOMAIN.www.baidu.com,DIRECT  # 默认规则，将其余流量路由到代理  - MATCH,test  - IP-CIDR,192.168.0.0/16,DIRECT  - IP-CIDR,10.0.0.0/8,DIRECT  - IP-CIDR,172.16.0.0/12,DIRECT  - IP-CIDR,172.12.0.0/12,DIRECT  - IP-CIDR,127.0.0.0/8,DIRECT  - IP-CIDR,100.64.0.0/10,DIRECT  - IP-CIDR,224.0.0.0/4,DIRECT  # 通过域名匹配，将指定域名的流量路由到代理  # - DOMAIN-SUFFIX,google.com,test  # # 拦截广告域名，不发送请求  # - DOMAIN-KEYWORD,ad.,REJECT  # 允许局域网流量直接连接，不走代理# 代理模式mode: Ruleui  clash-dashboard：ui  yacd-dashboard：conf"
  },
  
  {
    "title": "C#",
    "url": "/posts/C/",
    "categories": "Language, CSharp",
    "tags": "Server, CSharp",
    "date": "2023-10-06 10:58:40 +0800",
    





    
    "snippet": "简介C# 是一种多范式编程语言，主要用于开发 Microsoft 平台上的应用程序。C# 具有以下功能和用途：  Windows 应用程序开发：C# 是开发 Windows 桌面应用程序的首选语言之一。你可以使用 C# 和 .NET 框架创建功能丰富的 Windows 应用程序，包括图形用户界面 (GUI)、数据库连接、文件处理等。  Web 应用程序开发：C# 可以用于开发 Web 应用程...",
    "content": "简介C# 是一种多范式编程语言，主要用于开发 Microsoft 平台上的应用程序。C# 具有以下功能和用途：  Windows 应用程序开发：C# 是开发 Windows 桌面应用程序的首选语言之一。你可以使用 C# 和 .NET 框架创建功能丰富的 Windows 应用程序，包括图形用户界面 (GUI)、数据库连接、文件处理等。  Web 应用程序开发：C# 可以用于开发 Web 应用程序，包括 ASP.NET 和 ASP.NET Core。你可以使用 C# 构建动态、交互式的网站和 Web 服务，处理用户请求、数据库操作、身份验证等。  移动应用程序开发：C# 可以用于开发移动应用程序，包括使用 Xamarin 开发跨平台移动应用程序。你可以使用 C# 编写代码，并将其部署到 iOS、Android 和 Windows Phone 等平台上。  游戏开发：C# 在游戏开发领域非常流行。你可以使用 Unity 游戏引擎和 C# 创建各种类型的游戏，包括 2D 和 3D 游戏。C# 提供了丰富的游戏开发 API 和工具，使得游戏开发变得更加简单和高效。  数据库应用程序开发：C# 可以与各种数据库系统集成，包括 Microsoft SQL Server、Oracle、MySQL 等。你可以使用 C# 进行数据库连接、查询和数据操作，构建数据库应用程序和数据驱动的应用程序。  云应用程序开发：C# 可以用于开发云应用程序，包括使用 Microsoft Azure 平台构建的云服务和应用程序。你可以使用 C# 编写逻辑和数据处理代码，利用云平台的弹性和可扩展性。"
  },
  
  {
    "title": "Spark",
    "url": "/posts/spark/",
    "categories": "Language, Spark",
    "tags": "Server, Spark",
    "date": "2023-10-06 10:58:36 +0800",
    





    
    "snippet": "简介Apache Spark 是一个开源的大数据处理框架，它提供了高性能、通用的集群计算引擎，能够处理大规模数据集的并行计算任务。Spark 的主要功能和应用包括：  批处理：Spark 提供了强大的批处理功能，可以高效地处理大规模的数据集。它支持使用高级的数据操作和转换算子，如过滤、映射、聚合等，以及复杂的数据分析和处理任务。  实时流处理：Spark Streaming 是 Spark ...",
    "content": "简介Apache Spark 是一个开源的大数据处理框架，它提供了高性能、通用的集群计算引擎，能够处理大规模数据集的并行计算任务。Spark 的主要功能和应用包括：  批处理：Spark 提供了强大的批处理功能，可以高效地处理大规模的数据集。它支持使用高级的数据操作和转换算子，如过滤、映射、聚合等，以及复杂的数据分析和处理任务。  实时流处理：Spark Streaming 是 Spark 的流处理组件，可以处理实时数据流。它支持将实时数据流划分为小批次数据，并在每个批次上执行批处理操作，从而实现了近实时的流处理能力。  机器学习：Spark 提供了机器学习库（MLlib），包含了各种常见的机器学习算法和工具，如分类、回归、聚类、推荐系统等。这些算法可以在分布式环境下运行，利用 Spark 的并行计算能力，处理大规模的机器学习任务。  图计算：Spark 图计算库（GraphX）提供了用于处理图结构数据的算法和工具。它支持常见的图计算操作，如图的遍历、图的聚合、图的连接等，用于解决图结构数据分析和 Apache Spark 是一个开源的大数据处理框架，它提供了高性能、通用的集群计算引擎，能够处理大规模数据集的并行计算任务。Spark 的主要功能和应用包括：  批处理：Spark 提供了强大的批处理功能，可以高效地处理大规模的数据集。它支持使用高级的数据操作和转换算子，如过滤、映射、聚合等，以及复杂的数据分析和处理任务。  实时流处理：Spark Streaming 是 Spark 的流处理组件，可以处理实时数据流。它支持将实时数据流划分为小批次数据，并在每个批次上执行批处理操作，从而实现了近实时的流处理能力。  机器学习：Spark 提供了机器学习库（MLlib），包含了各种常见的机器学习算法和工具，如分类、回归、聚类、推荐系统等。这些算法可以在分布式环境下运行，利用 Spark 的并行计算能力，处理大规模的机器学习任务。  图计算：Spark 图计算库（GraphX）提供了用于处理图结构数据的算法和工具。它支持常见的图计算操作，如图的遍历、图的聚合、图的连接等，用于解决图结构数据分析和计算任务。  SQL 查询和数据集处理：Spark 提供了对结构化数据的支持，可以通过 Spark SQL 进行 SQL 查询和数据集处理。它支持常见的 SQL 查询操作，如过滤、聚合、连接等，并提供了 DataFrame 和 Dataset API，用于灵活地处理和转换结构化数据。"
  },
  
  {
    "title": "Scala",
    "url": "/posts/scala/",
    "categories": "Language, Scala",
    "tags": "Server, Scala",
    "date": "2023-10-06 10:58:36 +0800",
    





    
    "snippet": "简介Scala 是一种功能强大的编程语言，具有以下特性和用途：  面向对象编程：Scala 是一种完全面向对象的语言，支持类、对象、继承、多态等面向对象的概念。你可以使用 Scala 编写可重用、模块化的代码，并利用面向对象的设计模式来构建复杂的应用程序。  函数式编程：Scala 提供了丰富的函数式编程特性，包括高阶函数、匿名函数、不可变数据结构等。函数式编程的优势在于它可以使代码更具表达...",
    "content": "简介Scala 是一种功能强大的编程语言，具有以下特性和用途：  面向对象编程：Scala 是一种完全面向对象的语言，支持类、对象、继承、多态等面向对象的概念。你可以使用 Scala 编写可重用、模块化的代码，并利用面向对象的设计模式来构建复杂的应用程序。  函数式编程：Scala 提供了丰富的函数式编程特性，包括高阶函数、匿名函数、不可变数据结构等。函数式编程的优势在于它可以使代码更具表达力、可组合性和可测试性。  并发编程：Scala 内置了对并发编程的支持。它提供了 Actor 模型和并发集合等机制，使得编写高效的并发程序变得更加容易。  表达力和简洁性：Scala 具有简洁、优雅的语法，可以大大减少代码量。它支持函数链式调用、模式匹配、类型推断等特性，使代码更加精炼和易读。  与 Java 互操作性：Scala 运行在 Java 虚拟机上，可以与现有的 Java 代码和库无缝集成。这意味着你可以利用 Scala 的特性来扩展或改进现有的 Java 项目，或者与 Java 开发人员共享代码和资源。  数据处理和分析：Scala 在数据处理和分析领域广泛应用。它提供了强大的集合库和函数式编程特性，使得处理大规模数据集变得更加高效和方便。此外，Scala 还与流行的大数据处理框架（如 Apache Spark）紧密集成，提供了易于使用的 API。"
  },
  
  {
    "title": "Kubernetes Manager",
    "url": "/posts/kubectl/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2023-09-21 14:48:38 +0800",
    





    
    "snippet": "helm命令警告WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/cc/.kube/configWARNING: Kubernetes configuration file is world-readable. This is insecure. Locat...",
    "content": "helm命令警告WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /Users/cc/.kube/configWARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /Users/cc/.kube/config      处理方法      chmod g-rw ~/.kube/config  chmod o-r ~/.kube/config      repohelm repo add ind-games --username username --password password url # 添加库helm repo list # 查看repo列表helm repo update # 更新全部helm repo update ind-games # 更新指定 (推荐)helm search repo ind-games # 搜索全部helm search repo ind-games | grep bonus-texas # 搜索筛选指定helm cm-push bonus-texas-0.0.21.tgz ind-games # 推送压缩包helm cm-push &lt;dir&gt; ind-games # 推送文件helm cm-push . ind-games # 推送当前文件plugin (插件管理)helm plugin install https://github.com/chartmuseum/helm-pushCharthelm lint # 查看chart语法是否正确helm template --debug # 本地渲染helm install bonus-texas . --dry-run --debug # 服务器渲染模板的好方法，然后返回生成的清单文件helm list -n games # 已部署的listApplistion Mangerhelm pull ind-games/bonus-texas # pull 压缩包helm pull ind-games/bonus-texas --untar # pull 并且解压helm install &lt;dir&gt; -n games # installhelm uninstall bonus-texas -n game # uninstall# 更新应用helm upgrade -i bonus-texas ind-games/bonus-texas -f games.yaml -n gameshelm upgrade -i bonus-texas &lt;dir&gt; -f games.yaml -n gameshelm upgrade -i bonus-texas . -f games.yaml -n gameskubeclt      关键字说明          resource-type                  pod          deployment          service                    service-type                  ClusterIP          NodePort          LoadBalancer          ExternalName                      安装 kubectl      登录到 Kubernetes 集群中          获取 cat /root/kuber/config      放入到目标机器的 ~/.kube/config            查看版本    kubectl versionkubectl get nodes        设置环境  export KUBECONFIG=\"/etc/kubernetes/admin.conf\"      多环境设置                  注意配置(考虑到每个都会是 kubernetes.admin，需要做修改)            server: https://172.13.5.11:6443  name: ind-devcontexts:- context:    cluster: ind-dev    user: ind-dev  name: ind-devcurrent-context: ind-devkind: Configpreferences: {}users:- name: ind-dev  user:                    KUBECONFIG=indonesia_dev:indonesia_dev_local_test kubectl config view --flatten &gt; config      把生成文件替换 ~/.kube/config      基本命令kubectl configkubectl config get-contexts # 列出所有上下文kubectl config use-context &lt;context-name&gt; # 切换上下文kubectl config view # 验证配置 # 创建新的上下文kubectl config set-context &lt;context-name&gt; --cluster=&lt;cluster-name&gt; --user=&lt;user-name&gt; --namespace=&lt;namespace&gt;# 配置集群kubectl config set-cluster &lt;cluster-name&gt; --server=&lt;api-server-url&gt; --certificate-authority=&lt;ca-file&gt;kubectl get# podkubectl get pods -Akubectl get pods -n &lt;namespace&gt;kubectl get pods -n &lt;namespace&gt; -o wide &lt;pod&gt;# serviceskubectl get serviceskubectl get service -n &lt;namespace&gt;kubectl get service bonus-texas -n games# deploymentskubectl get deploymentskubectl get deployments -n &lt;namespace&gt;# nodekubectl get nodes# configmapskubectl get configmapskubectl get configmaps -n &lt;namespace&gt;# Secretskubectl get secretskubectl get secrets  -n &lt;namespace&gt;# Persistent Volumes (pv)kubectl get pv# otherkubectl get pods,deployment,replicaset# 查询关联后的节点kubectl get endpointskubectl port-forward（转发）kubectl port-forward mongo-75f59d57f4-4nd6q 28015:27017kubectl logkubectl logs ferry-6cb8d5697c-tdbzc -n gameskubectl logs -f ferry-6cb8d5697c-tdbzc -n gameskubectl logs -f ferry-6cb8d5697c-tdbzc --tail= 10 -n gameskubectl rolloutkubectl rollout history deployment/ferry -n common # 查看历史记录kubectl rollout undo deployment/ferry -n common  # 回滚到上次部署kubectl rollout undo deployment/ferry --to-revision=2 -n common # 回滚到指定版本kubectl rollout status -w deployment/ferry -n common # 查看是否会滚成功kubectl rollout restart deployment/ferry -n common # 轮替重启kubectl scale （伸缩）kubectl scale --replicas=2 deployment/ferry -n common # 伸缩到几个副本# 当前的一个副本修改成1个副本kubectl scale --current-replicas=2 --replicas=1 deployment/ferry -n commonkubectl scale --replicas=3 -f ferry.yaml # 文件修改kubectl scale --replicas=5 rc/a rc/b rc/c # 多个控制kubectl topkubectl top pod -n games # 查看资源使用状况kubectl describekubectl describe pod ferry-6cb8d5697c-tdbzc -n common # 查看pods详情kubectl describe configmap hall-customize -n huoys | more # 查看配置kubectl exec  kubectl exec -it &lt;pod-name&gt; -- &lt;command&gt; [flags]kubectl exec -it my-pod -- /bin/bashkubectl exec -it my-pod -- cat /var/log/my-log.logkubectl exec -it my-pod --container=my-container -- /bin/bash# 在特定命名空间中执行命令kubectl exec -it my-pod -n my-namespace -- /bin/bashkubectl set# 设置镜像kubectl set image deployment/my-deployment my-container=my-image:v2# 设置环境变量kubectl set env deployment/my-deployment ENV_VARIABLE=value# 设置标签kubectl set labels pod/my-pod new-label=value# 设置资源限制kubectl set resources deployment/my-deployment --limits=cpu=1,memory=512Mi# 设置镜像仓库凭证kubectl set image-credentials secret/my-secret registry=https://registry.example.com# 设置部署策略kubectl set strategy deployment/my-deployment rollingkubeclt expose  --name=&lt;service-name&gt;：服务名字  --port=&lt;port&gt;：服务的端口  --target-port=&lt;target-port&gt;:要映射到后端 Pod 的目标端口kubectl expose &lt;resource-type&gt; &lt;resource-name&gt; --type=&lt;service-type&gt; --name=&lt;service-name&gt; --port=&lt;port&gt; --target-port=&lt;target-port&gt;kubectl expose deployment my-nginx --type=ClusterIP --name=my-nginx-service --port=80 --target-port=80kubectl expose pod my-app --type=NodePort --name=my-app-service --port=8080 --target-port=80kubectl expose deployment my-nginx --type=LoadBalancer --name=my-nginx-service --port=80 --target-port=80kubectl expose pod my-pod --type=ClusterIP --name=my-headless-service --cluster-ip=Nonekubectl edit  编辑前先备份好kubectl edit &lt;resource-type&gt; &lt;resource-name&gt;kubectl craete      my-pod.yaml    apiVersion: v1kind: Podmetadata:name: my-podspec:containers:  - name: nginx    image: nginx        kubectl create &lt;resource-type&gt; &lt;resource-name&gt; [flags]  kubectl create pod my-pod --image=nginx  kubectl create service clusterip my-service --tcp=80:80 --pod=my-pod  kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2  kubectl create namespace my-namespace  kubectl create deployment my-deployment --image=nginx --replicas=3  # 使用 from-file 创建 可以是文件和目录  kubectl create configmap configmap-name --from-file=configmap*.yamlkubectl labelkubectl label &lt;resource-type&gt; &lt;resource-name&gt; &lt;label-key&gt;=&lt;label-value&gt; [flags]# 添加kubectl label pod my-pod environment=developmentkubectl label node my-node zone=us-west-1kubectl label service my-service app=my-app# 覆盖kubectl label pod my-pod environment=production --overwrite# 删除kubectl label pod my-pod environment-# 查看kubectl get pods --show-labelskubectl replace  kubectl replace -f &lt;configuration-file&gt;  可能中断服务  会删除现有的创建新的      my-pod.yaml    apiVersion: v1kind: Podmetadata:  name: my-podspec:  containers:    - name: nginx      image: nginx:1.18        kubectl replace -f my-pod.yamlkubectl patch  对 Kubernetes 资源进行部分更新kubectl patch &lt;resource-type&gt; &lt;resource-name&gt; [flags]kubectl patch pod my-pod -p '{\"metadata\":{\"labels\":{\"app\":\"my-app\"}}}'kubectl patch deployment my-deployment -p '{\"spec\":{\"replicas\":3}}'kubectl patch service my-service -p '{\"spec\":{\"ports\":[{\"port\":8080}]}}'kubectl patch configmap my-configmap -p '{\"data\":{\"key3\":\"value3\"}}'调度kubectl cordon node-name # 将 node-name 节点设置为不可调度模式kubectl drain node-name # 将当前运行的 node-name 节点上容器驱离kubectl uncordon node-name # 执行完维护后，将节点重新加入调度创建、删除、运行kubectl run &lt;name&gt; --image=&lt;container-image&gt;kubectl apply -f &lt;configuration-file&gt;kubectl delete &lt;resource-type&gt; &lt;resource-name&gt;Kubernetes 工作原理  参考地址kubectl 使用介绍  官方文档  官方文档备忘清单[root@idn ~]# kubectl --helpkubectl controls the Kubernetes cluster manager. Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/Basic Commands (Beginner):  create        创建资源  expose        将控制器、服务、部署或pod暴露未新的Kubernetes服务  run           在集群上运行一个特定的镜像  set           设置对象的特定功能Basic Commands (Intermediate):  explain       Documentation of resources  get           显示一个活多个资源  edit          编辑服务的资源  delete        按照文件名、资源名和名称资源、标签选择器删除资源Deploy Commands:  rollout       管理资源推出  scale         为deployment、replicaset controller 设置新的大小  autoscale     自动缩放 Deployment 、replicaset 或 Replication ControllerCluster Management Commands:  certificate   修改证书资源  cluster-info  显示集群信息  top           显示资源（cpu/内存/储存）使用情况  cordon        警戒线将节点标记为不可调度  uncordon      将节点标记为可调度  drain         移除节点，准备维护；容器驱离  taint         更新一个或多个节点上污点Troubleshooting and Debugging Commands:  describe      显示特定资源或资源组的详细信息  logs          打印pod中容器的日志  attach        附加到正在运行的容器  exec          在容器中执行命令  port-forward  将一个或多个本地端口转发到一个pod  proxy         运行一个到Kubernetes Api 服务代理  cp            在容器之间复制文件和目录  auth          检查授权Advanced Commands:  diff          将要应用的版本的Diff实时版本  apply         按照文件名或者目录标准输入将配置应用到资源  patch         补丁修改，更新资源字段  replace       使用配置文件或stdin 来替换资源  wait          在一个或多个资源上等待一个条件（不常用）  convert       在不同的API版本之间转换配置文件  kustomize     从目录或远程url 构建 kustomization 目标Settings Commands:  label         更新资源上的标签  annotate      更新资源上的注释  completion    为指定的shell(bash OR zsh) 输出完全代码Other Commands:  alpha         Commands for features in alpha  api-resources 在服务器上打印支持的API资源  api-versions  在服务端上打印支持API版本，以‘组/版本’的形式  config        修改 Kubernetes 文件  plugin        提供与插件交互的使用程序  version       打印客户端与服务端的版本信息Usage:  kubectl [flags] [options]Use \"kubectl &lt;command&gt; --help\" for more information about a given command.Use \"kubectl options\" for a list of global command-line options (applies to all commands).node  在生产过程中会遇到服务资源不足情况，需要增加新的服务器对应用系统进行水平扩展以实现扩容，在 Kubernetes 中加一个 node 只需要在 node 节点上安装 docker 、kubelet 、kube-proxy 服务，给 kubelet 和 kube-proxy 启动启动参数重 master rul 指定 Kubernetes 集群 master 地址。kubelet 会自动注册机制，新的 node 会自动加入到 Kubernetes 集群中"
  },
  
  {
    "title": "OperatingSystemsError",
    "url": "/posts/OperatingSystemsError/",
    "categories": "Cc, SelfStudy, ComputerBasics",
    "tags": "SelfStudy",
    "date": "2023-09-21 13:57:01 +0800",
    





    
    "snippet": "操作系统概论复习章节第一章  与分时系统相比，实时系统具有以下特点（1）多路性（2）独立性（3）及时性（4）交互性（5）可靠性  核心扩展技术的核心思想就是将软件构件动态地下载到内核中，以达到改变操作系统行为的日的  层次结构的基本思想是将操作系统分解为多个小的、容易理解的层，系统功能被隔离在不同层中，每一层提供对系统功能的部分抽象，然后采用单向调用的顺序，形成一连里彼此连续的对系统功能的抽...",
    "content": "操作系统概论复习章节第一章  与分时系统相比，实时系统具有以下特点（1）多路性（2）独立性（3）及时性（4）交互性（5）可靠性  核心扩展技术的核心思想就是将软件构件动态地下载到内核中，以达到改变操作系统行为的日的  层次结构的基本思想是将操作系统分解为多个小的、容易理解的层，系统功能被隔离在不同层中，每一层提供对系统功能的部分抽象，然后采用单向调用的顺序，形成一连里彼此连续的对系统功能的抽象串，最终形成对整个系统的完整抽象第二章第三章第四章第五章选择题      文件的类型          正规文件：包含用户信息一般分为 ASCII 文件和二进制文件      目录文件：管理文件的系统文件      字符设备文件：和输入/输出有关用于串行 IO 类设备，如终端、打印机和网络等      块设备文件：磁盘类设备            死锁          处理死锁的基本方法有                  预防死锁          避免死锁          检测并解除死锁忽略死锁问题（即假定死锁不可能在系统内发生而忽略死锁）                          Linux 的伙伴系统          Linux 的伙伴系统算法把所有的空闲页框分组为 11 个块链表，每个块链表分别包含大小为 1、2、4、8、16、32、64、128、256、512 和1024 个连续的页框。对 1024 个页框的最大请求对应着 4MB 大小的连续页框            自调度算法          最常用的调度方式之一      最简单的一种调度方式      优点                  易移植          有利于提高 CPU 的利用率                          存储器的种类(CPU 寄存器保存最常用的数据)          靠近 CPU 的容量小、速度快的高速缓存存储器作为速度相对较慢、容量较大的主存中数据和指令子集的缓冲区。      主存暂时存放存储容量更大、速度更慢的磁盘上的数据      而这些磁盘常常又作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区            程序的链接          链接程序不属于操作系统的构成部分，但是它为操作系统提供可装入的程序模块              可以把链接分为静态链接和动态链接                  静态链接：                          在程序运行前，用链接程序将目标模块链接成一个完整的装入模块              静态链接程序的任务一是对逻辑地址进行修改，二是变换外部调用符号                                动态链接                          连续分配的类型          连续分配是指操作系统分配内存时，为每个进程分配一块物理地址连续的内存空间              单一连续区分配方式      固定分区分配方式      动态分区分配方式        内存分配主要任务是为每道程序分配内存空间      动态分区分配算法          首次适应算法      循环首次适应算法                  优点：空闲区分布均勾、查找开销较小          缺点：容易使系统缺之大空闲区                    最佳适应算法            分页管理          页表是系统为进程建立的数据结构，页表的作用是实现从页号到页框号的映射              页：将一个进程的逻辑地址空间分成若干个大小相等的片      页框或页顿：将物理内存空间分成与页大小相同的若干个存储      页内碎片：进程的最后一页一般装不满一个页框，而形成了不可利用的碎片            分页和分段的区别          分页和分段都属于离散分配方式，都要通过数据结构与硬件的配合来实现逻辑地址到物理地址的映射，但两者存在着很大的不同              页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段是按逻辑单位划分的，一个段含有一组意义相对完整的信息。引入分段的目的是为了方便程序员编程      页的大小是固定的。而段的大小不固定，取决于用户编写的程序和编译器      分页的地址空间是一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个数,如 2568。分段的地址空间是二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移            虚拟存储技术                  系统的特征                  离散性          多次性          对换性          虚拟性                            好处                  提高内存利用率          提高多道程序度          把逻辑地址空间和物理地址空间分开，使程序员不用关心物理内存的容量对编程的限制                          文件结构                  分类                  树形结构          无结构字节序列          固定长度记录序列                            无结构字节序列（流式文件）                  操作系统不知道也不关心文件内容是什么，操作系统所见到的就是字节，其任何含义由使用该文件的程序自行理解          在 UNIX 和 Windows 系统中都采用这种方式                          目录结构          文件目录的组织和管理是文件管理的一个重要方面，包括单层目录、两级和树形目录      树形目录                  优点：便于文件的分类，层次结构清晰，便于管理和保护，解决了重名问题，查找速度加快          缺点：查找一个文件按路径名逐层检查，由于每个文件都放在外存中，多次访问磁盘会影响速度，结构相对复杂                    每个目录项包含对应文件文件名 和 i 结点号            FAT 文件系统          AT 文件系统有 3 个版本：FAT-12.FAT-16 和 FAT-32，取决于用多少个二进制位存放号            DMA 控制方式          命令/状态寄存器（CR）用于接收从 CPU 发来的 VO 命令或有关控制信息、设备状态      内存地址寄存器（MAR）用于存放内存地址      数据计数器（DC）用于指示 DMA，本次向 CPU 发中断信号前要读或写数据的次数      数据寄存器（DR）用于暂存 DMA 传输中要输入或输出的数据            缓冲池          公共缓冲池既可用于输入，又可用于输出      其中至少包含 3 种类型的缓冲区、3 种缓冲队列和 4 种工作缓冲区            进程切换的步骤          进程切换使当前正在执行的进程成为被替换进程，出让其所使用的 CPU，以运行被进程调度程序选中的新进程              保存包括程序计数器和其他寄存器在内的 CPU 上下文环境      更新被替换进程的进程控制块      修改进程状态，把执行态改为就绪态或者阻塞态      将被替换进程的进程控制块移到就绪队列或阻塞队列      执行通过进程调度程序选择的新进程，并更新该进程的进程控制块      更新内存管理的数据结构      恢复被调度程序选中的进程的硬件上下文        进程控制块（PCB）：组织方式通常链接和索引两种      实时计算的概念          实时系统是支持实时计算的系统。实时计算的正确性不仅依赖于系统计算的逻辑结果，还依赖于产生正确结果的时间            实时系统的特点（在实时系统中，往往采取多级容错措施来保证系统安全和数据安全）          实时系统主要用于实时控制和实时信息处理领域      实时系统比分时系统要求有更高的可靠性      因为任何实时系统的错误都可能带来巨大的经济损失，甚至危及生命安全            操作系统中的用户接口（批处理用户接口）          脱机用户接口是为批处理作业的用户提供的            操作系统体系结构          简单的监控程序模型的经典代表是（FMS &amp; IBSYS）      动态可扩展结构模型的典型代表是 Harvard 大学的 VINO 操作系统      分层结构最经典的例子是 Dijkstra 的 THE 系统      客户/服务器模型的典型代表是卡内基梅隆大学研制的 Mach 操作系统、WindRiver 公司的 Vxworks 等        操作系统中最核心概念（进程），也是围绕进程展开的      进程控制块中的处理机状态信息          通用寄存器      指令计数器      程序状态字 PSW      用户栈指针。其中，指令计数器中存放了 CPU 要访问的下一条指令的地址            进程状态的转换          进程状态不能由阻塞态直接变为执行态，进程状态由阻塞态变为就绪态的过程称为唤醒过程由执行态变为阻塞态的过程称为阻塞过程              执行态                  -时间片用完-&gt;就绪态          -等待事件-&gt;阻塞态                    就绪态-进程调度-&gt;执行态      阻塞态-等待的事件发生-&gt;就绪态            程序顺序执行时具特点有：          顺序性      封闭性      可在线性            系统调用的类型          进程控制类系统调用：创建、撤销进程；获得、改变进程属性      文件操纵类系统调用：创建文件、删除文件、打开文件、关闭文件和读/写文件      设备管理类系统调用：请求、释放设备      通信类系统调用：打开、关闭连接，交换信息      信息维护类系统调用：返回系统当前日期、时间、版本号、用户数、空闲内存和磁盘空间大小等信息            操作系统内核的功能          中断处理、时钟管理和原语操作      操作系统内核的资源管理功能包括进程管理、存储器管理和设备管理            操作系统中的时钟          别称为实时时钟（RTC）                  也称 CMOS 时钟，是一块时钟芯片，靠电池供电，为计算机提供计时标准，是最原始、最底层的数据                    OS 时钟                  OS 时钟产生于 PC 主板上的定时/计数芯片，在开机时有效，由操作系统控制                          进程调度的功能          进程调度功能由操作系统内核的进程调度程序完成，在 Linux 内核中，进程调度功能的实现从调用内核函数 chedule（）开始。进程调度的功能是按照某种策略和算法从就绪态进程（在 Linux 中是可执行进程）中为当前空闲的 CPU 选择在其上运行的新进程            选择调度方式和算法的准则          周转时间短      响应时间快      截止时间的保证      系统吞吐量高      处理机利用率好        操作系统负责管理计算机的资源      other          系统开销=进程切换时间/时间片大小=10/200=5%      填空题  一般函数调用运行在用户态，系统调用运行在系统态  嵌入式系统时宿主于非计算机设备中的计算机系统  计算机的所有功能最终都是由硬件的操作来实现的  操作系统的四个特征中，并发是指允许两个或多个事件在同一时间间隔内发生；异步是指进程以不可预知的速度向前推进  引入工作集机制是为了能有效降低缺页率从而提高访存的时间效率  操作系统所管理的资源主要包括处理机、内存、设备和文件  多处理器系统中的成组调度方式有以下优点：一是减少线程切换，二是减少调度开销  目录文件有两种常见的结构：属性放在中目录项和放在中。i 节点  程序执行的局部性原理表现为时间和空间的局部性  将物理内存空间分成与页大小相同的若千个存储块，称为页框或页帧  当前进程的时间片是否用完是由操作系统的时钟机制进行检查的。当时间片为 0 时，该进程将放弃 CPU 转入就绪态  操作系统对计算机的资源进行有效的管理，其主要功能包括：处理机管理、内存管理设备管理、文件管理问答题      试简述 SPOOLing 系统的主要作用          提高了 I/O 速度      将独占设备改造为共享设备      实现了虚拟设备功能            处理死锁方法          预防死锁      避免死锁      检测（实时）并解除死锁      忽略死锁            线程可以分为哪两种？这两种线程在调度与切换速度上有什么不同？          线程可以分为用户级线程和内核级线程两类      内核级线程的调度由内核的线程调度程序完成，用户级线程则由用户线程包中的一个过程来完成      内核级线程切换慢，用户级线程切换快            某系统中有四个进程，它们进入系统的时间和需要服务的时间如题 表所示（表中数值均为十进制）                            进程          进入系统时间          需要服务时间                                      P1          0          100                          P2          10          60                          P3          25          25                          P4          35          40                                    （1）采用先来先服务调度算法（FCFS）时，填写题 37-2 表，并计算平均周转时间（四舍五入，保留小数点后两位）                  $开始运行时间=上一个结束时间$          $结束时间=上一个结束+需要服务时间$          $等待时间=开始运行时间-进入系统时间$          $周转时间=结束时间-进入系统时间$          $带权周转时间=周转时间/服务时间$                                                    进程              开始运行时间              结束时间              等待时间              周转时间              带权周转时间                                                          P1              0              100              0              100              1                                      P2              100              160              90              150              2.5                                      P3              160              185              135              160              6.4                                      P4              185              225              150              190              4.75                                                平均周转时间 $T=（100+150+160+190）/4=150 $                            （2）采用短进程优先调度算法（SPF）时，填写题 37-3 表，并计算平均周转时间（四舍五入，保留小数点后两位）                                            进程              开始运行时间              结束时间              等待时间              周转时间              带权周转时间                                                          P1              0              100              0              100              1                                      P2              165              225              155              215              3.58                                      P3              100              125              75              100              4                                      P4              125              165              90              130              3.25                                                平均周转时间 $T=（100+215+100+130）/4=136.25$                          简述连续分配文件存储方式的实现方法、优点和缺点          连续分配就是把每个文件作为一连串连续数据块存储在磁盘上              连续分配方式的优点是                  实现简单。记录每个文件用到的仅需两个信息：第 1 块的磁盘地址和文件的块数          读写操作性能好。因为数据块在磁盘中连续存放，所以文件读写时寻道时间很小                    连续分配方式的缺点是                  随着磁盘空间的分配与释放，磁盘会变得零碎，磁盘上会有很多空闲的连续形成的”空洞”，此时需要挑选大小合适的”空洞”存入文件，如果文件大小可变，则系统管理文件的存储会比较麻烦                          磁盘访问时间由哪三部分组成？对这三部分做一个简单的说明          磁盘访问时间由寻道时间、旋转延退时间和传输时间三部分组成      寻道时间是指把磁臂（磁头）移动到指定磁道上所经历的时间      旋转延退时间是指将指定扇区旋转到磁头下面所经历的时间      传输时间是指把数据从磁盘读出或者向磁盘写入数据时所经历的时间            设备分配通常有先来先服务和基于优先权的两种分配算法。简述它们的实现方法。          先来先服务的分配算法：当有多个进程对同一个设备提出 VO 请求时，该算法是根据进程对该设备提出请求的先后顺序将这些进程排成一个设备请求队列，设备分配程序总是先把设备分配给队首进程      基于优先权的分配算法：该算法对高优先权进程所提出的 VO 请求赋予高优先权，将优先权高的进程排在设备请求队列前面，而对于优先级相同的VO 请求，则按先来先服务原则排队，设备分配程序每次把备分配给队首进程            列出虚拟存储技术带来的 3 点好处          提高内存利用率      提高多道程序度      把逻辑地址空间和物理地址空间分开，使程序员不用关心物理内存的容量对编程的限制            除了I/O设备被启动时会引起中断之外，还有哪四种原因会引起中断？          人为设置中断      程序性事故      硬件故障      外部事件            程序的并发执行，有哪三个特点？为了对共享资源进行管理，操作系统引入了什么机制？          特点                  间断性          失去封闭性          不可再现性                    机制：引入了信号量机制      "
  },
  
  {
    "title": "运筹学基础（02375）",
    "url": "/posts/OperationsResearch/",
    "categories": "Cc, SelfStudy",
    "tags": "SelfStudy",
    "date": "2023-09-19 13:57:01 +0800",
    





    
    "snippet": "运筹学基础      公式概念          求和                  公式：$\\displaystyle \\sum ^n _{i=1}$ 简化 $\\sum$          例子：$\\displaystyle \\sum ^5 _{i=1} = 1+2+3+4+5 = 15$                    第一章  定性决策：基本上根据决策人员的主观经验或感受到的...",
    "content": "运筹学基础      公式概念          求和                  公式：$\\displaystyle \\sum ^n _{i=1}$ 简化 $\\sum$          例子：$\\displaystyle \\sum ^5 _{i=1} = 1+2+3+4+5 = 15$                    第一章  定性决策：基本上根据决策人员的主观经验或感受到的感觉或知识而制定的决策  定量决策：借助于某些正规的计量方法而做出的决策  混合性决策：必须运用定性和定量两种方法才能制定的决策  运筹学与管理决策：对于管理领域，运筹学也是对管理决策工作进行决策的计量方法  运筹学          运筹学是一门研究如何有效地组织和管理人机系统的科学      运筹学利用计划方法和有关多学科的要求，把复杂功能关系表示成数学模型，其目的是通过定量分析为决策和揭露新问题提供数量根据      第二章概论 2      预测          含义：预测就是对未来的不确定的事件进行估计或判断      预测是决策的基础，企业预测的目的就是为企业决策提供适当的数据或资料            预测方法的分类          经济预测：分为宏观经济预测（国民经济范围）和微观经济预测（单个实体经济、市场分析等）                  3-5 年是长期          1-3 年是中期          年内是短期          PS：如市场需求、市场占有率等                    科技预测：分为科学预测和技术预测                  30-50 年以上是长期          10-30 年是中期          5-10 是短期          PS：如新技术发明可能应用的领域、范围和速度、新工艺等                    社会预测：如人口增长预测、社会购买心理的预测等      军事预测：研究与战争、军事有关的问题            专家群          在社会环境和经济环境越来越复杂的情况下，管理者进行决策时，为了掌握社会环境和经济环境的各方面的变化和预测资料；需要听取专家或熟悉情况者的意见并希望在”专家群”中取得比较一致的意见而采取的定性预测方法            特尔斐法和专家小组法的区别          特尔斐 -&gt; 专家群、背对背，适用于长期或中期预测      专家小组 -&gt; 面对面，过程紧凑，适用于短期预测      计算公式式 2      简单滑动平均预测法                  横向比较法\\[\\displaystyle\\overline{x}=\\frac{x_1+x_2+...+x_n}{n}\\]\\[\\displaystyle\\overline{x}=\\frac{1.5+1.2+0.9+0.7+0.5}{5}=0.96\\]                    纵向比较法\\[\\displaystyle\\stackrel{ˆ}{x}_{t+1}=\\frac{x_t+x_{t-1}+x_{t-2}+...+x_{t-(n-1)}}{n}\\]                  加权平均数预测法                  横向比较法\\[\\overline{x}_w=\\frac{x_1w_1+x_2w_2+...+x_nw_n}{w_1+w_2+...+w_n}=\\frac{\\sum x_iw_i}{\\sum w_i}\\]                    纵向比较法\\[F_{i+1}=\\frac{x_iw_i+x_{i-1}w_{i-1}+x_{i-2}w_{i-2}+...+x_{i-(n-1)}w_{i-(n-1)}}{w_i+w_{i-1}+w_{i-2}+...+w_{i-(n-1)}}=\\frac{\\sum x_iw_i}{\\sum w_i}\\]                  回归模型预测法                  回归方程：$ y=a+bx $\\[b = \\frac{n\\sum xy - \\sum x \\sum y} {n\\sum x^2 - (\\sum x)^2}\\]\\[a = \\frac{\\sum y - b\\sum x } {n}\\]                    相关系数:\\[R=\\sqrt{\\frac{\\sum(\\hat{y_i}-\\overline y)^2}{\\sum(y_i-\\overline y)^2}}\\]                    回归偏差平方和\\[R=\\sum(\\hat{y_i}-\\overline y)^2\\]            第三章概论 3      决策的分类          按决策方法不同而分类：常规性和特殊性决策      按计划与控制的关系分类：计划性和控制性决策            三种决策类型的区别          一种自然状态、概率已知——确定条件下的决策      一个以上自然状态、概率未知——不确定条件下的决策      一个以上自然状态、概率已知——风险条件下的决策            在不同环境下的决策          确定条件下的决策                  只有一种自然状态                    不确定条件下的决策                  最大最大决策标准          最大最小决策标准          最小最大遗憾值决策标准          现实主义决策标准                    风险条件下的决策                  最大期望收益值标准          最小期望损失值标准                          决策树的结构  计算公式式 3      max    \\(max\\{ max[f(A_1,\\theta_1)],max[f(A_2,\\theta_1)],max[f(A_3,\\theta_1)]\\}\\)\\(= max \\{ 200000,160000,120000\\}\\)\\(= 200000\\)        min （反之）  第四章概论 4  库存的作用：库存的作用最基本的一个方面，就是保证工业企业的生产能够正常地、连续地、均衡地进行  库存费用分析：订货费=（年需要量/订货量）× 一次订货费，当企业的年需求量一定，每次的订货批量增加时，全年的订货费将会减少，库存费用=订货费+保管费，在保证正常供应条件下（不考虑缺货费用），随着订货量的增大，计划期限内（一般以年为限）采购次数减少，采购费用下降，但保管费用却相应上升  平均库存量：平均库存量等于批量大小的一半  经济订货量：经济订货量（the economic order quantity，缩写为 EOQ）是使总的存货费用达到最低的为某个台套或某个存货单元确定的最佳的订货批量。使保管和订货费用达到最小值的订货量计算公式 4      库存费用分析                  库存费用模型结构                              原材料费用模型库存费用\\(库存费用=订货费+保管费\\)\\(TC=P+C\\)                                半成品和成品库存费用\\(库存费用(TC)=工装调整费+保管费\\)\\(TC=S+C\\)                                      库存费用                  订货费用\\(订货费= \\frac{年需要量}{订货量}*一次订货费\\)\\(P=\\frac{D}{N}*P_0\\)          工装调整费\\(工装调整费= \\frac{年计划产量}{生成批量}*一次工装调整费\\)\\(S=\\frac{R}{N}*P_s\\)                      保管费\\(保管费= 平均库存量 * 单位物质保管费\\)\\[C = \\frac{1}{2} 2 * C_0\\]                                      保管费（存货套、单元 年度保管费用）\\[保管费=平均库存量*库存物资单价*保管费率\\]\\[C=\\frac{1}{2}N*R*C_i\\]                  平均库存的概念          $N$表示订货量大小              平均库存额\\(平均库存额=每个单元货每个套台的单位价格（库存物资单位）*平均库存量\\)\\(M=\\frac{1}{2}N*R\\)      第五章概论 5  线性规划：线性规划的基本特点是线性函数  约束条件：线性规划的模型结构中，决策对于实现目标的限制因素  最优解：图解法中，从可行解区域内找出满足目标函数的解  以原点为基础可行解，建立初始方案，列出单纯形表          一个基变量组只有一个通解、一个基解，基解可以是非负的(可行的)，也可以是有负的(不可行的)；对每个基变量组来说，特解都有无穷多个      线性规划模型中，基解要求所有的非基变量都等于 0      某个线性规划问题，若有最优解，那么这个最优解必定是某个基变量组的可行基解        约束方程的个数          约束方程的个数=基变量个数；非基变量=变量个数-约束方程的个数      初始单纯形表：初始单纯形表是由线型规划模型标准形式的系数矩阵转变成的，由于填入的是以原点为基础的可行解的系数      计算公式 5第六章概论 6  运输问题的解决步骤          求初始调运方案      对初始调运方案进行改进      求得最优方案        闭合回路法          在求解运输问题时，对运输表中各个空格寻求改进路线和计算改进指数的方法      闭合回路法先对各个空格寻求一条闭合的改进路线，然后再按每条改进路线计算每个空格的改进指数        需要量小于供应量的运输问题          需求点少，故虚设需求点      需求量少，故需求量=总供应量-总需求量      因为虚设，故其单位运费等于 0      第七章概论 7  网络图的分类          箭线式网络图：箭线代表活动（作业），以结点代表活动的开始和完成，由活动、结点和线路三个部分组成      结点式网络图：结点代表活动，以箭线表示各活动之间的先后承接关系        关键线路的特点          线路时差为 0      主要矛盾线      所需工时最长        线路：从网络的始点开始，顺着箭线的方向，中间经过互相连接的结点和箭线，到网络终点为止的连线  作业时间：网络图中，一定生产技术条件下，完成一项活动或一道工序所需时间  最乐观时间：网络图中，完成一项活动可能最短的时间  最可能时间：网络图中，正常条件下完成一项活动可能性最大的时间  最保守时间：最保守时间：完成一项活动可能最长的时间  活动的四个时间          最早开始时间：箭尾结点的最早开始时间      最早完成时间：最早开始时间+作业时间      最迟开始时间：箭尾结点的最迟完成时间      最迟完成时间：箭头结点的最迟完成时间      第八章概论 8  图的最基本的要素          点：表示要研究的对象      点之间的连线：表示对象之间的某种特定的关系      连通图：在网络图中，如果所有的点都可以通过相互之间的连线而连通，则这种图形称为连通图      树：在一个网络中，如果图形是连通且不含圈的，则这种图形称之为树      几种问题的解决方法                  最小枝杈树问题：普赖姆法或克鲁斯喀尔法          最短线路问题：最短路线法          最大流量问题：有向图解法，找出能在起点进入，并通过这个网络，在终点输出的最大流量          最佳订货批量问题：表格法、图解法、数学方法          最小枝杈树问题：在一个网络中，如果从一个起点出发到所有的点，找出一条或几条路线，以使在这样一些路线中所采用的全部支线的总长度最小，这种方法称之为最小枝杈树问题          网络图的几种常见问题模型                          网络路线问题：从入口到出口、最少时间，最短距离或最少费用              最大流量问题：流量最大、费用或时间最小              最小枝杈树问题：起点到所有点、长度最小、费用最小                                          第九章概论 9  概率向量的性质：          元素非负      元素总和为 1        概率矩阵：任意一个方阵，如果其各行都是概率向量，则该方阵称之为概率矩阵  马尔柯夫过程：在 20 世纪初（1907 年）俄国数学家马尔柯夫经过多次研究试验后发现：在某些事物的概率转换过程中，第 n 次试验的结果，常常由第 n-1 次试验的结果所决定  概率向量：任意一个向量，如果它内部的各个元素均为非负数，且总和等于 1，则该向量称之为概率向量  马尔柯夫分析：马尔柯夫分析的一个有趣的事实是：不管各式各样的生产者和供应者一开始占有的市场份额如何，最终平衡状态总是一样的第十章概论 10  盈亏平衡点：盈亏平衡点就是企业经营达到这一点时，总销售额和总成本完全相等，即总利润为 0  盈亏平衡分析：盈亏平衡分析是以所有成本都能分为固定的和可变（变动）的两个组成部分为前提的在这个前提下，总成本与销售量的关系是线性的  计划成本：在固定成本中，管理部门认为要达到预期目标所必须的费用，称之为计划成本  固定成本：在一定时期内不随企业产量的增减而变化的费用，称之为固定成本  可变成本：随着企业产品产量的增减而变化的费用，称之为可变成本  生产能力百分率：生产能力百分率，指盈亏平衡点销售量与总生产能力之比  变动费用线：变动费用线又可称为生产费用线。线上的任何一点都表示某一产量的固定费用与变动费用之和，即总生产费用。第十一章概论 11  蒙特卡洛方法：蒙特卡洛方法是应用随机数进行模拟试验的方法，它对要研究的系统进行随机观察抽样，通过对样本的观察统计，得到系统的参数值  模拟：模拟是一种定量的过程，它先为过程设计一个模型，然后再组织一系列的反复试验，以预测该过程全部时间里所发生的情况  随机数：每一个随机变量和相关的某个范围内累计频率序列数相应，这个累计频率数称之为随机数  排队论的两个分布          顾客到达——泊松（普阿松）分布      服务时间——负指数分布      练习练习 1  定量决策：借助于某些正规的计量方法而做出的决策，称之为定量决策  在应用运筹学方法进行决策的步骤中，最关键的是：收集数据练习 2      定性预测法          定性预测法适用于社会或经济环境发生了剧烈变化，或建立定量模型缺少的数据或资料的情况      也叫判断预测法在生产和经济活动中，常常会出现这样的情况，在这些情况下，人们的判断是唯一现实的预测方法。情况之一是由于建立某个定量模型缺少数据或资料            预测：对未来的不确定事情进行估计或判断        常用定性预测方法：特尔斐法和专家小组法        特尔斐法（希望在专家群中取得比较一致的方法）          专家发表意见是匿名      进行多次信息反馈      最后调研人员整理归纳专家的意见，将比较统一和特殊的意见一起交给有关部门，以供决策      需要经过几轮信息反馈，进行时间长，因适用于长期或中期预测            专家小组法（座谈会法）          专家小组法又称座谈会法，是在接受咨询的专家之间组成一个小组，面对面的进行讨论与碳商，最后对需要预测的课题得出比较一致的意见      适用于短期预测方法      "
  },
  
  {
    "title": "vim Plug Manager",
    "url": "/posts/vim-plug/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-09-18 11:32:25 +0800",
    





    
    "snippet": "安装curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim修改配置~/.vimrccall plug#begin('~/.vim/plugged')Plug 'vim-airline/vim-airline'P...",
    "content": "安装curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim修改配置~/.vimrccall plug#begin('~/.vim/plugged')Plug 'vim-airline/vim-airline'Plug 'vim-airline/vim-airline-themes'Plug 'itchyny/lightline.vim'Plug 'preservim/nerdtree'Plug 'tpope/vim-fugitive'Plug 'ryanoasis/vim-devicons'Plug 'tiagofumo/vim-nerdtree-syntax-highlight'Plug 'dense-analysis/ale'Plug 'fatih/vim-go'call plug#end()syntax enableset ts=4set showcmdset smartindentset clipboard=unnamedplusset undodir=/home/save/lcc/vim/undodirset expandtabset autoindentset numberset hlsearchset nocompatibleset backspace=indent,eol,start安装列表插件  打开终端  vim      进入命令行模式      :PlugInstall      插件其他操作  更新插件：:PlugUpdate  更新指定插件：:PlugUpdate NERDTree  恢复插件：:PlugSnapshot ~/vim-plug.list"
  },
  
  {
    "title": "C++Programming（04737）",
    "url": "/posts/C++/",
    "categories": "Cc, SelfStudy, C++",
    "tags": "SelfStudy",
    "date": "2023-08-21 13:57:01 +0800",
    





    
    "snippet": "C++Programming课本代码第一章 C++语言简介      C++语言的发展简史          C 语言是 C++ 语言的前身， 在进一步扩充和完善 C 语言的基础上得到了 C++语言。      用 C++语言写成的程序称为源程序， 源程序必须经过 C++编译程序翻译成机器语言才能执行      一般需要经过编辑 、编译 、连接 、运行            C++语言的特点...",
    "content": "C++Programming课本代码第一章 C++语言简介      C++语言的发展简史          C 语言是 C++ 语言的前身， 在进一步扩充和完善 C 语言的基础上得到了 C++语言。      用 C++语言写成的程序称为源程序， 源程序必须经过 C++编译程序翻译成机器语言才能执行      一般需要经过编辑 、编译 、连接 、运行            C++语言的特点(与 C 语言相比， C++语言的优点)          从程序运行的稳定性来说， C++语言更安全， 它支持过程化编程 、面向对象编程和泛型编程      C++语言可运行于多种平台上， 如 Windows 、MAC 操作系统及 UNIX 的多种版本      C++语言中加入了面向对象的概念， C++的程序结构与 C 语言的程序结构存在很大差别            基本的输入/输出                  C++ 类中对象                  cin：运算符为&gt;&gt;，用于键盘输入。函数 scanf()；输入流类 istream          cout：运算符为&lt;&lt;，用于屏幕输出。函数 printf()；输出流类 ostream                    流提取运算符和流插入运算符都是由两个连续的符号组成的，中间不能有其他符号      %c 是输岀单个字符的格式控制符。%s 是输出字符串的格式控制符      当使用当程序中用到 cin 和 cout 时，需要在程序中包含头文件&lt;iostream&gt;      语句以分号;结尾            头文件和命名空间          程序员还可以定义自己的头文件，并在程序中使用 #include 指令将其包含进来。通常，使用尖括号括住系统提供的头文件，使用双引号括住程序员自己定义的头文件                      常用的头文件有以下一些                  标准输入输出流：&lt;iostream&gt;          标准文件流：&lt;fstream&gt;          标准字符串处理函数：&lt;string&gt;          标准数学函数：&lt;cmath&gt;                            using 语句引用其他命名空间的标识符的语法格式有两种形式                  using 命名空间名::标识符;          using namespace 命名空间名                          强制类型转换运算符                  数据类型级别由低到高分别为：char→int→float→double。当不同类型的量进行混合算术运算时，系统自动进行合理的类型转换。编译器就会自动把低级类型向高级类型转换                    使用强制类型转换运算符 static_cast 或是 const_cast 进行转换                  static_cast 将一种数据类型转换成另一种数据类型，格式：static_cast&lt;类型名&gt;(表达式）static_cast 也可以省略。          const_cast 去除指针和引用的常量性，但不能去除变量的常量性。：const_cast&lt;类型名&gt;(表达式）                          函数参数的默认值          C++语言规定，提供默认值时必须按从右至左的顺序提供，即有默认值的形参必须在形参列表的 最后。如果有某个形参没有默认值，则它左侧的所有形参都不能有默认值      调用函数时，主调函数的实参与被调函数的形参按从左至右的顺序进行匹配对应。如果实参的个数与形参的个数相等，则它们一一对应。如果实参的个数 m 少于形参的个数 n，则函数原型形参表中最前面的 m 个形参与 m 个实参相对应，后面的 n-m 个形参则使用默认值进行初始化      无返回值函数：没有返回值的 return 语句只能用在返回类型是 void 的函数中。有返回值函数： return 语句的第二种形式提供了函数的结果。 只要函数的返回类型不是 void，则该函数内的每条 return 语句必须返回一个值            引用和函数参数的传递          引用相当于给变量起了一个别名。定义格式：类型名 &amp;引用名=同类型的某变量名;      在 C++中，函数调用时参数的传递有两种方式：传值和传引用。                  传值：实际上是传递对象的值。即将实参的值拷贝给形参。在函数执行过程中，都是对这个拷贝进行操作的，函数执行完毕返回后，形参的值并不拷贝回实参，也就是说函数内部对形参的改变不会影响到函数外实参的值。          传引用：传递对象的首地址值。函数调用时，实参对象名传递给形参对象名，形参对象名就成为实参对象名的别名，即形参是对应实参的引用，它们是等价的，代表同一个对象，也可以看作是将实参的地址传递给了形参                          const 与指针共同使用          可以简单地记住 const 的修饰规则：const 修饰其左侧的内容；如果 const 是本行的第一个标识符，则它修饰其右侧的内容              C++语言也可以使用 const 限定访问权限，const 修饰指针变量时，基本含义如下                  如果唯一的 const 位于符号*的左侧，表示指针所指数据是常量，数据不能通过本指针改变，但可以通过其他方式进行修改；指针本身是变量，可以指向其他的内存单元          如果唯一的 const 位于符号*的右侧，表示指针本身是常量，不能让该指针指向其他内存地址；指针所指的数据可以通过本指针进行修改          在符号*的左右各有一个 const 时，表示指针和指针所指数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容                          内联函数          引入了内联函数的目的：加快执行速度。定义内联函数时只需在函数头返回值类型的前面加上关键字 inline。      内联函数的适用情况：只有几条语句，且频繁调用的小函数。      在 C++中，除具有循环语句、switch 语句的函数不能说明为内联函数外，其他函数都可以说明为内联函数            函数的重载          函数重载：是指在程序的同一范围内声明几个功能类似的同名函数。即前提是函数名相同。可提高代码可读性。函数重载可使一个函数名具有多种功能，即具有多种形态，称这种特性为多态性。      实现函数的重载必须满足下列条件之一：                  参数表中对应的参数类型不同。          参数表中参数个数不同                          指针和动态内存分配          指针变量中保存的是一个地址，有时也称指针指向一个地址      使用 new 运算符动态申请的内存空间，需要在使用完毕释放。C++提供了 delete 运算符，用来释放动态分配的内存空间                  使用 new 运算符实现动态内存分配。p=new T; 其中，T 是任意类型名，p 是类型为 T*的指针。          使用 new 运算符还可以动态分配一个任意大小的数组：p=new T[N]; 其中，T 是任意类型名，p 是类型为 T*的指针，N 代表数组元素个数，可以是任何的值为正整数的表达式。          C++提供了 delete 运算符，用来释放动态分配的内存空间，基本用法：delete 指针                    当 delete 释放动态对象数组时，实现为 delete []ptr;      数组的下标从 0 开始，含 n 个元素的数组的下标范围是从 0〜n-1。            用 string 对象处理字符串          字符常量：用单引号括起来的单个字符或转义字符。字符串常量：用双引号括起来。      大小写字母 ASCII 码差 32。      string 类中的常用成员函数                  int size() const; 返回当前字符串的大小          int length() const; 返回当前字符串的长度          bool empty() const; 判定当前字符串是否为空          find();返回 str 在字符串中第一次出现的位置，如果没找到则返回-1          insert(); 在 p 位置插入字符串 S          append();将字符串 s 连接到当前字符串的结尾处          substr(); 返回从 pos 开始的 n 个字符组成的字符串                          C++语言的程序结构          程序中必须有且仅有一个主函数 main()，这是程序执行的总入口。      C++程序中，仍沿用 C 语言的注释风格，即注释有以下两种形式。                  从/*开始，到*/结束，这之间的所有内容都视作注释。          从//直到行尾，都是注释。                    第二章 面向对象的基础概念      结构化程序设计          在编写程序时，使用 3 种基本控制结构来构造程序      顺序、选择、循环基本控制结构            面向对象思想的提出          对象是类的一个实例。对象是类的一个具象，类是对象的一个抽象      面向对象技术把问题看成是相互作用的事物的集合，也就是对象的集合      对象特性：一是状态（也称为属性）；二是行为（也称为操作）。状态是指对象本身的信息，也称为属性；行为是对对象的操作      通过对事物的抽象找出同一类对象的共同属性（静态特征）和行为（动态特征），从而得到类的概念            面向对象程序设计的概念和特点          抽象：在面向对象的程序设计方法中，将同一类事物的共同特点概括出来。对象的特点包括两个方面：属性和操作。C++中使用对象名、属性和操作三要素来描述对象      封装：将对象的属性及实现细节隐藏起来，只给出如何使用的信息。将数据成员使用 private 关 键字定义，则产生封装性      继承：就是在编写一个新类的时候，以现有的类作为基础，使得新类从现有的类派生而来，从而达到代码扩充和代码复用的目的。原来的类是基类，也称为父类或超类。新类是派生类，也称为子类      多态：是指不同种类的对象都具有名称相同的行为，而具体行为的实现方式却有所不同            类的定义          标识符命名规则：字母、数字和下划线的组合，大小写敏感，但不能以数字开头，也不能和系统中使用的关键字完全相同      类中定义的数据和函数称为这个类的成员（数据成员和成员函数）              类体外函数定义的前面必须用类名::来限定，格式如下          返回值类型 类名::成员函数(参数列表)  {    成员函数的函数体  }                          程序结构          .h 文件是头文件      .cpp 文件是源程序文件      C 源程序文件编译而成的目标文件的扩展名是.obj      可执行代码的文件扩展名为.exe（这需要根据操作系统）            创建类对象的基本形式          使用类名 *对象指针名 = new 类名;创建对象时，调用无参的构造函数。如果这个构造函数是由编译器为类提供的，则类中成员变量不进行初始化      使用类名 *对象指针名 = new 类名();创建对象时，也调用无参的构造函数。如果这个构造函数是由编译器为类提供的，则对类中的成员变量进行初始化            访问对象的成员          使用对象：如果变量 a 为结构体对象，且结构体内有元素 b，那么可以使用 a.b 的方式访问元素。      使用指针：如果变量 a 为结构体指针，且结构体内有元素 b，那么可以使用 a-&gt;b 的方式访问元素。      使用引用：访问成员时仍使用点操作符，即引用名.成员名。            访问范围说明符的含义          private 私有的 使用它修饰的类的成员仅能在本类内被访问默认      public 公有的 使用它修饰的类的成员可以在程序的任何地方被访问      protected 保护的 它的作用介于 public 与 private 之间，使用它修饰的类的成员能在本类内及子类中被访问            标识符的作用域与可见性          函数原型作用域：在声明函数原型时形参的作用范围就是函数原型作用域，最小的作用域      局部作用域：程序中使用相匹配的一对大括号括起来的一段程序称为块。作用域局限在块内的称为局部作用域      类作用域：类可以被看成是一组有名字的成员的集合，类 X 的成员 m 具有类作用域，对 m                  访问方式有如下 3 种：                          直接访问成员 m              在类外，通过表达式 x.m 或者 X::m 来访问              在类外，可以通过 ptr-&gt;m 表达式来访问                                          命名空间作用域：在命名空间内部可以直接引用当前命名空间中声明的标识符，如果需要引用其他命名空间的标识符，需要使用下面的方式：命名空间名::标识符名      第三章 类和对象的进阶重点      构造函数函数          对于 C++中基本数据类型的变量，可以声明全局变量和函数内部的局部变量                  全局变量：如果没有进行初始化，则系统自动为其初始化为 0。这个工作在程序启动时完成          局部变量：系统不进行自动初始化，如果程序员没有设定，则是一个随机值                    构造函数的作用：完成对象的初始化工作（即创建对象）。构造函数是类中的特殊成员函数，它属于类的一部分      声明对象后，可以使用 new 运算符为对象进行初始化，此时调用的是对象所属类的构造函数            析构函数的定义          构造函数的函数名与类名相同，没有返回值。一个类的构造函数可以有多个，即构造函数允许重载。即这些构造函数之间的关系是重载关系      当类中没有定义任何构造函数时，系统会自动添加一个参数表为空、函数体也为空的构造函数，称为默认构造函数              定义构造函数的形式          类名::类名(行参1、行参2,....n)  {    x1 = 行参1；    x2 = 行参2;    xn = n;  }                          构造函数的使用          如果程序中声明了对象数组，即数组的每个元素都是一个对象      创建对象时，调用一次构造函数      对于指针，仅是说明了这个指针，并未与对象相关，所以并不调用构造函数      如果构造函数的定义中给出了参数的默认值，那么使用构造函数创建对象时，对应的实参是可以省略的。此时，使用默认值当作对应实参的值            复制构造函数          复制构造函数是构造函数的一种，也称为拷贝构造函数。它的作用是使用一个已存在的对象去初始化另一个正在创建的对象      复制构造函数只有一个参数，参数类型是本类的引用。即引用类自己      对于类 A 而言，复制构造函数的原型如下                  （格式一)：A::A(const A&amp;)          （格式二)：A::A(A&amp;)                          析构函数          与构造函数一样，析构函数也是成员函数的一种，它的名字也与类名相同，但要在类名前面加一个〜字符，以区别于构造函数      析构函数的特点：没有参数，也没有返回值。析构函数不可以多于一个，不会有重载的析构函数。默认析构函数的函数体为空。一个类中有且仅有一个析构函数      创建对象时自动调用构造函数，在对象消亡时自动调用析构函数            静态变量          static 用来声明静态变量      局部变量：块内定义的变量，从定义之处开始到本块结束处为止是局部变量的作用域      全局变量：指在所有花括号之外声明的变量，其作用域范围是全局可见的，即在整个项目文件内都有效            类的静态成员          类的静态成员有两种：静态成员变量和静态成员函数。      给静态成员变量赋初值的格式：类型 类名::静态成员变量=初值;      访问类静态成员格式                  类名::静态成员名          对象名.静态成员名          对象指针-&gt;静态成员名                    静态成员变量只有一份，被同类所有对象共享。甚至可以在还没有任何对象生成时就访问一个类的静态成员            常量成员和常引用成员          使用关键字 const 修饰的量称为常量      在对象被创建以后，其常量成员变量的值就不允许被修改，只可以读取其值。对于常量对象，只能调用常量函数      总之常量成员变量的值不能修改常量对象中的各个属性值均不能修改            友元          友元使用关键字 friend 标识      友元的概念破坏了类的封装性和信息隐藏，但有助于数据共享，能够提高程序执行的效率            友元函数          在友元函数内部可以直接访问本类对象的私有成员。      在类定义中，将一个全局函数声明为本类友元函数：friend 返回值类型 函数名(参数表);当有某类 A 的定义后，将类 A 的成员函数说明为本类的友元函数：friend 返回值类型 类 A::类 A 的成员函数名(参数表);      一个类的成员函数（包括构造函数和析构函数）可以通过使用 friend 说明为另一个类的友元，但友元函数本身并不是类的成员函数，但允许访问类中的所有成员      3 类的静态成员（重点）4 变量及对象的生存期和作用域5 常量成员与常引用成员6 成员对象和封闭类7 友元8 this 执政（难点）第四章 运算符重载重点1 运算符重载概念2 重载复制运算符3 重载流插入运算符和流提取运算符4 重载强制类型转换运算符5 重载自增、自减运算符第五章 类的继承与派生重点1 类的继承与派生2 访问控制3 派生类的构造函数和析构函数4 类之间关系5 多层次派生6 基类与派生类指针的互相转换第六章 多态与虚函数重点1 多态的基本概念2 多态实例3 多态的使用4 虚析构函数5 纯虚函数和抽象类第七章输入/输出流1 流类简介2 标准流对象3 控制 I/O 格式4 调用 cout 的成员函数5 调用 cin 的成员函数第七章文件操作1 文件基本概念和文件流类2 打开和关闭文件3 文件读写操作4 随机访问文件第七章函数模版与类模版1 函数模版2 类模版"
  },
  
  {
    "title": "OperatingSystems（02323）",
    "url": "/posts/OperatingSystems/",
    "categories": "Cc, SelfStudy, ComputerBasics",
    "tags": "SelfStudy",
    "date": "2023-08-21 13:57:01 +0800",
    





    
    "snippet": "操作系统概论  操作系统控制、内核、同步、通讯  操作系统调度、算法、死锁  存储、管理方式、分段存储  操作系统文件  操作系统设备管理第一章（操作系统简介）1、什么是操作系统  操作系统（Operating System OS），是一种复杂的软件系统，是不同代码、数据结构、输出初始化文件的集合，可执行      用户与硬件之间的接口          计算机硬件：处理器、内存储器、输入/...",
    "content": "操作系统概论  操作系统控制、内核、同步、通讯  操作系统调度、算法、死锁  存储、管理方式、分段存储  操作系统文件  操作系统设备管理第一章（操作系统简介）1、什么是操作系统  操作系统（Operating System OS），是一种复杂的软件系统，是不同代码、数据结构、输出初始化文件的集合，可执行      用户与硬件之间的接口          计算机硬件：处理器、内存储器、输入/输出模块      计算机软件：系统软件、应用软件      在裸机上加载的第一层软件      把操作系统定义为：操作系统是控制和管理计算机硬件的软件资源、是计算机用户与计算机硬件之间的接口            资源的管理者          处理机管理                  CPU 分配（调度）          提高利用率                    作业管理的功能      存储器管理      设备管理            总结          功能                  管理计算机硬件和软件资源          提供计算机用户与计算机硬件之间的接口          为应用程序的运行提供环境                    2、操作系统的发展      无操作系统          第一代（1745 ～ 1955）      电子管            单道处理操作系统          第二代（1955-1965）      晶体管使用磁性存储设备            多道程序系统          集成电路      1962 年 分时是系统 IBM7094            微机操作系统          磁盘操作系统      芯片（Intel8080）            批量处理系统、分时系统、实时系统的特点          单道批处理系统特点                  自动性、顺序性、单道性          优点：减少人工操作时间          缺点：CPU 资源不能扽到充分的利用                    多道批处理的特点                  多动性、无序性、调度性、复杂性          优点：提高 CPU、内存和 I/O 设备的利用率和系统吞吐量          缺点：系统平均周转时间长、缺乏交互能力                    分时系统的特点                  多路性、独立性、及时性、交互性          优点：向用户提供了人机交互的方便性          缺点：不能及时接收和处理用户命令                    实时系统的特点（用户实时控制和实时信息处理）                  应用：工业现场的自动控制、海底探测、智能机器人和航空航天…          多路性、独立性、及时性、交互性、可靠性          优点：往往采取多级容错来实施系统安全和数据安全          缺点：系统错误会带来大量损失                          系统分类                  主机操作系统                  运行在大型机上的操作系统，主要是提供三种服务：批处理、事务处理、分时处理                            服务器操作系统                  运行在网络服务器上的操作系统，通过网络同时为众多用户服务、允许用户共享硬件和软件资源                          可以提供打印服务、文件服务、web 服务                            微机操作系统                  个人操作系统          单个用户提供良好的应用环境和应用软件开发环境                            嵌入式操作系统                  允许于嵌入式设备中（20 世纪 70 年代）                    3、操作系统的特征  并发与共享互相依赖；虚拟映射关系  并发：两个以上事件在同一时间间隔内发生  共享：系统在资源可供内存中多个并发执行的进程共同使用          资源共享方式                  互斥共享：例如：访问同一个数据是顺序执行          同时共享：例如：可以同事访问一个数据                      虚拟：通过某种技术把一个物理实体变成若个干逻辑上的对应物  异步性：进程以不可预知的速度向前推进4、操作系统的功能      内存管理          内存分配方式                  静态分配：每个作业运行之前分配好内存空间，在作业整个运行期间不再改变          动态分配：每个作业运行前或者运行中，均可申请新的附加内存空间，以适应程序和数据的动态增涨                    内存保护                  内存主要任务；确保每道用户程序都只在自己内存空间运行，互不干扰          内存保护机制：是设置连个界限寄存器，越界检查都是由硬件实现                    地址映射：运行时，将地址空间中的逻辑地址转换为内存空间                  地址空间（虚拟地址）：目标程序或装入程序限定的空间，称为”地址空间”单元的编号称之为逻辑地址，又称为相对地址          内存空间（存储地址）：由内存中的一系列单元所限定的地址范围称之为”内存空间”，其中地址称之为物理地址                    内存的扩充：借助于虚拟存储技术，从逻辑上扩充容量，使用的用到的内存容量比实际内存容量大的多，扩充内存必须具有内存扩充机制            进程管理          进程表述与组织      进程控制      进程同步      进程通信与进程调度            设备管理（I/O 请求、分配）          缓冲管理      设备分配      设备处理      设备独立性与虚拟设备            文件管理          文件存储空间的管理      目录管理      文件的读写、和存储控制            接口用户管理          命令接口      图像用户接口      程序接口      5、操作系统的体系结构      软件体系结构          一个复杂软件系统高层结构、为软件提供一个结构、行为和属性的高级抽象，包括元素的结构、元素间关系、知道元素集成模型和约束              简单的监控程序模型                  典型代表：FMS / IB-SYS          单体结构模型          层次结构模型                          基本思想                                客户/服务器模型与微内核          动态课扩展结构模型                    6、指令的执行第二章（进程管理）1、进程描述      并发执行          操作系统本质是数据结构加算法      操作系统中最核心的概念是进程      程序的顺序执行特点：顺序性、封闭性、可再现性      程序的并发执行特点：间断性、失去封闭性、不可再现性            进程概念          进程是允许并发的程序在某个数据集合上的运行过程      进程是正文段、用户数据段和进程控制块（PCB）共同组成的执行环境                  正文段：存放被执行的机器指令          用户数据段：存放进程在执行时要操作的用户数据          进程控制块：存放程序的执行环境                          进程的特征          并发性      独立性      异步性      动态性      结构特征            进程和程序区别          程序静态，进程是动态      程序永久，进程暂时存在      程序和进程存在实体不同                  程序：指令集合          进程：正文段、用户数据段、进程控制快组成                          进程和程序的联系          进程是程序的一次执行      进程总是对应至少一个特定的程序，执行程序的代码      一个程序可以对应多个进程            进程控制块          进程实体存在的标志是操作系统管理进程所使用的数据结构—进程控制块      进程控制块（PCB）是进程实体的一部分，是操作系统中最重要的数据结构      进程控制块中记录了操作系统所需要的，用户描述进程情况以及控制进程运行所需要的全部信息      进程控制块是操作系统感知进程存在的唯一标志              包含信息有哪些                  进程标识符信息：唯一标识一个进程          处理机状态信息：包括通用寄存器，指令计数器，程序状态字 PSW，用户栈指针          进程调度信息：包括进程状态信息，进程优先级和进程调度所需的其他信息          进程控制信息：包括程序和数据的地址，进程同步和通信机制资源清单以及链接指针                          进程的状态                  就绪态、执行态、阻塞态                    2、进程的控制      进程的创建          进程创建–阻塞–唤醒–终止                      创建条件                  用户登录          作业调度          提供服务          应用请求                            新进程执行情况                  父子进程并发执行          父等待，知道某个子执行完毕                            新进程地址空间情况                  子共享父地址空间          子拥有独立地址空间          操作系统组织和管理进程是通过管理和组织进程控制块来实                            调用创建新进程的系统调用来创建进程的一般步骤                  申请空白 PCB          为新进程分配资源          初始化进程控制快          将新进程插入就绪队列                          进程的阻塞                  条件                  请求系统服务          数据尚未到达          无工作可做          启动某种操作                            完成进程阻塞简化过程                  将进程的状态改为阻塞态          将进程插入相应的阻塞队列          转进程调度程序，从就绪进程中选择进程为其分配 CPU                          进程的唤醒          将阻塞队列中移除      将进程状态阻塞态改为就绪态      将进程插入就绪态            进程的终止（撤销）          正常执行完毕，终止进程，删除该进程      一个进程调用适当的系统调用，终止另外一个进程              父终止子原因                  子进程是了超过了分配的资源          分配给子进程任务不再需要          父进程退出                            操作系统通过系统调用完成进程终止的一般过程如下                  从进程 PCB 中读进程状态          若进程正在执行，则终止进程的执行          若进程有子孙进程，在大多数情况下需要终止子孙进程          释放资源          将终止进程的 PCB 移出                          操作系统内核  进程调度与死锁内存管理文件系统I/O 设备管理"
  },
  
  {
    "title": "Hyper-V",
    "url": "/posts/hyper-v/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-07-27 09:32:25 +0800",
    





    
    "snippet": "Windows Hyper-V  需要先下载好 Centos 7 镜像  阿里云地址创建Linux启动网络管理基础设置CentosEnter  网络设置vi /etc/sysconfig/network-scripts/ifcfg-eth0TYPE=Ethernet                             # 网卡类型：为以太网PROXY_METHOD=none       ...",
    "content": "Windows Hyper-V  需要先下载好 Centos 7 镜像  阿里云地址创建Linux启动网络管理基础设置CentosEnter  网络设置vi /etc/sysconfig/network-scripts/ifcfg-eth0TYPE=Ethernet                             # 网卡类型：为以太网PROXY_METHOD=none                         # 代理方式：关闭状态BROWSER_ONLY=no                           # 只是浏览器：否BOOTPROTO=dhcp                            # 设置网卡获得ip地址的方式，可能的选项为static(静态)，dhcp(dhcp协议)或bootp(bootp协议).DEFROUTE=yes                              # 默认路由：是, 不明白的可以百度关键词 `默认路由`IPV4_FAILURE_FATAL=no                     # 是不开启IPV4致命错误检测：否IPV6INIT=yes                              # IPV6是否自动初始化: 是[不会有任何影响, 现在还没用到IPV6]IPV6_AUTOCONF=yes                         # IPV6是否自动配置：是[不会有任何影响, 现在还没用到IPV6]IPV6_DEFROUTE=yes                         # IPV6是否可以为默认路由：是[不会有任何影响, 现在还没用到IPV6]IPV6_FAILURE_FATAL=no                     # 是不开启IPV6致命错误检测：否IPV6_ADDR_GEN_MODE=stable-privacy         # IPV6地址生成模型：stable-privacy [这只一种生成IPV6的策略]NAME=ens34                                # 网卡物理设备名称UUID=8c75c2ba-d363-46d7-9a17-6719934267b7 # 通用唯一识别码，没事不要动它，否则你会后悔的。。DEVICE=ens34                              # 网卡设备名称, 必须和 `NAME` 值一样ONBOOT=no                                 # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备IPADDR=172.12.12.96                       # 网卡对应的ip地址PREFIX=24                                 # 子网 24就是255.255.255.0GATEWAY=172.12.12.255                     # 网关DNS1=114.114.114.114                      # dnsHWADDR=78:2B:CB:57:28:E5                  # mac地址  网络工具安装          yum update      yum install net-tools      ifconfig      "
  },
  
  {
    "title": "Postman env manager",
    "url": "/posts/postman-env/",
    "categories": "Dev, Utils",
    "tags": "Tools, Postman",
    "date": "2023-07-26 09:33:25 +0800",
    





    
    "snippet": "为什么要环境管理  你有生产 API 和开发 API,在不同的位置。  你用两个环境,一个用于开发和生产。  每个环境包含一个变量来存储基础 URL。  指的是变量集合中的每个请求的 URL 字段。  你之间切换环境运行时要求测试它们对开发或生产环境。  在您的组织中,您可能有一个团队,只有进入开发环境,并与编辑个体的团队成员和只读存取特定环境。创建一个环境  在 Environment q...",
    "content": "为什么要环境管理  你有生产 API 和开发 API,在不同的位置。  你用两个环境,一个用于开发和生产。  每个环境包含一个变量来存储基础 URL。  指的是变量集合中的每个请求的 URL 字段。  你之间切换环境运行时要求测试它们对开发或生产环境。  在您的组织中,您可能有一个团队,只有进入开发环境,并与编辑个体的团队成员和只读存取特定环境。创建一个环境  在 Environment quick look (eye) and Manage environments (gear) buttons 可以查看、创建、修改  点击 Manage environments -&gt; Add  给此环境赋予名字 Environment Name      输入一个名称为您的变量,并指定 最初的 和 当前的 值——默认将当前值复制初始值          Initial Value（初始值）通过邮递员服务器和同步到您的帐户与任何合作者访问共享环境      Current Value（当前值）是当地的邮递员程序,不会同步到您的帐户或共享与您的团队,除非你选择坚持它              当前值访问时用到的值，通过脚本改变值，也会用到这个值      使用环境变量  在一个请求使用一个环境变量值,引用它的名字,包围了 双花括号 :脚本tests[\"StatusOK\"] = pm.response.code == 200;var jsonData = pm.response.json();if (jsonData.token) {  tests[\"Token found\"] = true;  pm.environment.set(\"TOKEN\", jsonData.token);} else {  tests[\"Token found\"] = false;}Tests使用的环境变量设置值{  \"id\": \"1a3920a2-534e-410b-829e-54b9a7038933\",  \"name\": \"im_square(8003)\",  \"values\": [    {      \"key\": \"URL\",      \"value\": \"http://172.12.15.248:8003\",      \"enabled\": true    },    {      \"key\": \"releaseTime\",      \"value\": \"1234567890\",      \"enabled\": true    },    {      \"key\": \"page\",      \"value\": \"1\",      \"enabled\": true    },    {      \"key\": \"pageSize\",      \"value\": \"1\",      \"enabled\": true    },    {      \"key\": \"uid\",      \"value\": \"9f070ce000000\",      \"enabled\": true    }  ],  \"_postman_variable_scope\": \"environment\",  \"_postman_exported_at\": \"2020-07-02T02:13:07.394Z\",  \"_postman_exported_using\": \"Postman/7.27.1\"}request post  url **/im_square/get_info_list      request body    ```json{  “page”: `### 为什么要环境管理    你有生产 API 和开发 API,在不同的位置。  你用两个环境,一个用于开发和生产。  每个环境包含一个变量来存储基础 URL。  指的是变量集合中的每个请求的 URL 字段。  你之间切换环境运行时要求测试它们对开发或生产环境。  在您的组织中,您可能有一个团队,只有进入开发环境,并与编辑个体的团队成员和只读存取特定环境。创建一个环境  在 Environment quick look (eye) and Manage environments (gear) buttons 可以查看、创建、修改  点击 Manage environments -&gt; Add  给此环境赋予名字 Environment Name      输入一个名称为您的变量,并指定 最初的 和 当前的 值——默认将当前值复制初始值          Initial Value（初始值）通过邮递员服务器和同步到您的帐户与任何合作者访问共享环境      Current Value（当前值）是当地的邮递员程序,不会同步到您的帐户或共享与您的团队,除非你选择坚持它              当前值访问时用到的值，通过脚本改变值，也会用到这个值      使用环境变量  在一个请求使用一个环境变量值,引用它的名字,包围了 双花括号 :{{bases_url}}脚本tests[\"StatusOK\"] = pm.response.code == 200;var jsonData = pm.response.json();if (jsonData.token) {  tests[\"Token found\"] = true;  pm.environment.set(\"TOKEN\", jsonData.token);} else {  tests[\"Token found\"] = false;}Tests使用的环境变量设置值{  \"id\": \"1a3920a2-534e-410b-829e-54b9a7038933\",  \"name\": \"im_square(8003)\",  \"values\": [    {      \"key\": \"URL\",      \"value\": \"http://172.12.15.248:8003\",      \"enabled\": true    },    {      \"key\": \"releaseTime\",      \"value\": \"1234567890\",      \"enabled\": true    },    {      \"key\": \"page\",      \"value\": \"1\",      \"enabled\": true    },    {      \"key\": \"pageSize\",      \"value\": \"1\",      \"enabled\": true    },    {      \"key\": \"uid\",      \"value\": \"9f070ce000000\",      \"enabled\": true    }  ],  \"_postman_variable_scope\": \"environment\",  \"_postman_exported_at\": \"2020-07-02T02:13:07.394Z\",  \"_postman_exported_using\": \"Postman/7.27.1\"}request post  url {{URL}}/im_square/get_info_list      request body    {  \"page\": `{{page}}`,  \"pageSize\": `{{pageSize}}`,  \"uid\": \"{{uid}}\"}      正确的返回值{  \"code\": 0,  \"message\": \"0\",  \"ttl\": 1,  \"data\": {    \"total\": 1,    \"infos\": [      {        \"id\": 30051,        \"uId\": \"9f070ce000000\",        \"uPortrait\": \"images&amp;1.png\",        \"uName\": \"Cc360428\",        \"uSex\": 0,        \"mediaUrl\": [          \"images&amp;09ee96d63eb9afc5018f5ac4244c5666.jpg\",          \"images&amp;c577fe740c5d4e819039bb7c92c917e9.jpg\"        ],        \"content\": \"图文\",        \"likeNumber\": 7,        \"likeCheck\": true,        \"commentNumber\": 0,        \"releaseTime\": 1593585321,        \"state\": 0,        \"infoType\": 0,        \"reportCheck\": true,        \"songResourceId\": 0,        \"songTitle\": \"\",        \"singer\": \"\",        \"leadSinger\": \"\",        \"followUp\": \"\",        \"followUpNumber\": 0      }    ]  }}脚本设置环境变量以及读取 ，获取 response 值code = pm.response.code == 200;var jsondata = pm.response.json();var base_url = pm.environment.get(\"URL\");console.log(\"获取环境变量参数 base_url\", base_url);console.log(\"code\", code);if (code) {  console.log(\"jsondata\", jsondata);  if (jsondata.code == 0) {    for (var i = 0; i &lt; jsondata.data.infos.length; i++) {      console.log(\"for-&gt;\", jsondata.data.infos[i].releaseTime);      pm.environment.set(\"releaseTime\", jsondata.data.infos[i].releaseTime);    }  } else {    console.log(\"请求正常 但是相应错误\");    console.log(\"error Message\", jsondata.message);  }} else {  console.log(\"请求错误\");},    \"pageSize\": `,    “uid”: “”  }#### 正确的返回值```json{  \"code\": 0,  \"message\": \"0\",  \"ttl\": 1,  \"data\": {    \"total\": 1,    \"infos\": [      {        \"id\": 30051,        \"uId\": \"9f070ce000000\",        \"uPortrait\": \"images&amp;1.png\",        \"uName\": \"Cc360428\",        \"uSex\": 0,        \"mediaUrl\": [          \"images&amp;09ee96d63eb9afc5018f5ac4244c5666.jpg\",          \"images&amp;c577fe740c5d4e819039bb7c92c917e9.jpg\"        ],        \"content\": \"图文\",        \"likeNumber\": 7,        \"likeCheck\": true,        \"commentNumber\": 0,        \"releaseTime\": 1593585321,        \"state\": 0,        \"infoType\": 0,        \"reportCheck\": true,        \"songResourceId\": 0,        \"songTitle\": \"\",        \"singer\": \"\",        \"leadSinger\": \"\",        \"followUp\": \"\",        \"followUpNumber\": 0      }    ]  }}脚本设置环境变量以及读取 ，获取 response 值code = pm.response.code == 200;var jsondata = pm.response.json();var base_url = pm.environment.get(\"URL\");console.log(\"获取环境变量参数 base_url\", base_url);console.log(\"code\", code);if (code) {  console.log(\"jsondata\", jsondata);  if (jsondata.code == 0) {    for (var i = 0; i &lt; jsondata.data.infos.length; i++) {      console.log(\"for-&gt;\", jsondata.data.infos[i].releaseTime);      pm.environment.set(\"releaseTime\", jsondata.data.infos[i].releaseTime);    }  } else {    console.log(\"请求正常 但是相应错误\");    console.log(\"error Message\", jsondata.message);  }} else {  console.log(\"请求错误\");}"
  },
  
  {
    "title": "Postman",
    "url": "/posts/postman/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-07-26 09:32:25 +0800",
    





    
    "snippet": "PostmanWorkspacesnewHTTPGRPCWebSocketenvironmentspm.test(\"Reuest Status \",function() {    pm.response.to.have.status(200);});var requestJson = pm.response.json();// console.log(\"获取参数\",requestJson);...",
    "content": "PostmanWorkspacesnewHTTPGRPCWebSocketenvironmentspm.test(\"Reuest Status \",function() {    pm.response.to.have.status(200);});var requestJson = pm.response.json();// console.log(\"获取参数\",requestJson);if (requestJson.En == 0){    var UserInfo = JSON.parse(CryptoJS.enc.Base64.parse(requestJson.Data).toString(CryptoJS.enc.Utf8))    console.log(\"userInfo ：\",UserInfo)    pm.environment.set(\"UserId\", UserInfo.UserId);    pm.environment.set(\"Token\", UserInfo.Token);    tests[\"Login\"] = true}else{      tests[\"Login\"] = \"登录失败\"+requestJson.En}"
  },
  
  {
    "title": "v2fly-core",
    "url": "/posts/linux-vpn-v2fly-core/",
    "categories": "DevOps, Software",
    "tags": "LinuxTool, Software",
    "date": "2023-07-19 08:06:01 +0800",
    





    
    "snippet": "docker-composeversion: '3'services:  v2fly-core:    container_name: v2fly-core    image: v2fly/v2fly-core    ports:      - '10808:10808'      - '10809:10809'    volumes:      - /home/save/vpn/v2fly...",
    "content": "docker-composeversion: '3'services:  v2fly-core:    container_name: v2fly-core    image: v2fly/v2fly-core    ports:      - '10808:10808'      - '10809:10809'    volumes:      - /home/save/vpn/v2fly-core/config:/etc/v2ray      - /etc/hosts:/etc/hosts    command: \"run -c /etc/v2ray/config.json\"    restart: 'always'配置文件.├── config│   └── config.json└── docker-compose.yaml1 directory, 2 files"
  },
  
  {
    "title": "curl",
    "url": "/posts/curl/",
    "categories": "DevOps, Command",
    "tags": "Tools",
    "date": "2023-07-17 11:43:01 +0800",
    





    
    "snippet": "Other  下载文件          curl -O http://example.com/file.zip        使用代理          curl -x proxy.example.com:8080 http://example.com/api        跟踪重定向          curl -L http://example.com        限速下载     ...",
    "content": "Other  下载文件          curl -O http://example.com/file.zip        使用代理          curl -x proxy.example.com:8080 http://example.com/api        跟踪重定向          curl -L http://example.com        限速下载          curl –limit-rate 100K http://example.com/file.zip        Cookie          curl -b “cookie1=value1; cookie2=value2” http://example.com/api      http 请求设置请求头curl -H \"Authorization: Bearer token\" http://example.com/api发送文件curl -X POST -H \"Content-Type: application/json\" -d '{\"key1\":\"value1\",\"key2\":\"value2\"}' http://example.com/apiGet要使用curl发送GET请求并带参数，您可以在URL中附加查询字符串参数。以下是一个示例命令：curl -X GET \"https://example.com/api?param1=value1&amp;param2=value2\"在上面的例中，您需要https://example.com/api 替换实际的API端URL，并将param1=value1&amp;param2=value2替换您要发送的参数。如果您的参数值包含特殊字符或空格，您可能需要对其进行URL编码。您可以使用urlencode命令行工或在线URL编码工具来执行此操作。请注意，些特殊字符（如&amp;、?等）在命令行中具有特含义，因此您可能需要使用引号将整个参数部分括起来，以避免解析错误。另外，请保您已经安装了curl命令行工具，并且可以从端或命令提示符中运行它。post  curl -X POST -H \"Content-Type: application/json\" -d '{\"key1 \"value1\", \"key2\": \"value2\"}' https://example.com/api/endpoint  格式化输出  curl -X POST -H \"Content-Type: application/json\" -d '{\"key1 \"value1\", \"key2\": \"value2\"}' https://example.com/api/endpoint | jq      from要使用cURL进行POST请求发送表单数据，可以使用-d或--data选项，后跟以key=value格式表示的表数据。以下是一个示：    curl -X POST -d \"username=johndoe&amp;password=secretpassword\" https://example.com/login        在这个示例，我们向https://example.com/login 发送一个带有两个表单字段username和password的POST请求。    如果有多个单字段，可以使用与号（&amp;）分隔们。如果需要，确保正确地对值进行URL编码。    此外，可以使用-H--header选项定请求的内容类型。例如，如果要使用application/x-www-form-urlencoded内容类型发送请求，可以添加以下标头：    curl -X POST -H \"Content-Type: application/x-www-form-urlencoded\" -d \"username=johndoe&amp;password=secretpassword\" https://example.com/login        请记得将https://example.com/login 替换为实际发送请求的URL  "
  },
  
  {
    "title": "半程马拉松",
    "url": "/posts/half-marathon/",
    "categories": "Cc, Left, half marathon",
    "tags": "Game",
    "date": "2023-06-19 12:48:54 +0800",
    





    
    "snippet": "半程马拉松简介半程马拉松是一项长跑运动项目，全称为半程马拉松路跑比赛（Half Marathon）。它的路线长度约为 21.0975 公里，是一项具有挑战性和观赏性的中长距离长跑比赛。半程马拉松比赛通常在早上开始，选手需要在规定时间内完成整个赛程，并且按照规定的路线进行奔跑。这项比赛的路线通常是在城市内或郊区，有时甚至穿越了名胜古迹、山脉或海滨等美丽的自然风景线。参加半程马拉松比赛需要进行长...",
    "content": "半程马拉松简介半程马拉松是一项长跑运动项目，全称为半程马拉松路跑比赛（Half Marathon）。它的路线长度约为 21.0975 公里，是一项具有挑战性和观赏性的中长距离长跑比赛。半程马拉松比赛通常在早上开始，选手需要在规定时间内完成整个赛程，并且按照规定的路线进行奔跑。这项比赛的路线通常是在城市内或郊区，有时甚至穿越了名胜古迹、山脉或海滨等美丽的自然风景线。参加半程马拉松比赛需要进行长期的训练和准备，以确保身体能够承受比赛的挑战。参赛者需要具备良好的耐力和体能，并且需要遵循正确的饮食和休息习惯，以提高体能和减轻疲劳。半程马拉松比赛除了具有挑战性外，也是一个社交和健康益处的活动。参与者可以结识新朋友，享受跑步带来的愉悦感，同时也能改善心肺功能、增强免疫力、减轻压力等。因此，半程马拉松比赛成为越来越多人钟情的一项户外运动。规则  半程马拉松是一项长跑比赛，全长为 21.0975 公里。以下是其比赛规则和合格记录：      裁判会在比赛开始前进行简短的讲解，介绍比赛路线、安全提示等。        比赛开始后，选手需要按照指定路线完成比赛，不能离开比赛路线。如果出现违规行为，裁判有权取消选手成绩。        在比赛过程中，选手可以自备或者比赛组委会提供的补给站取得水、食物等必需品。        比赛结束后，选手需要按照规定时间内到达终点，并经过裁判确认才算完成比赛。未能在规定时间内到达终点的选手不计入成绩。        选手完成比赛后，组委会将根据成绩对选手进行排名，并颁发奖牌、证书等奖励。        在半程马拉松比赛中，成年男子最佳成绩为 58 分钟 33 秒，女子最佳成绩为 1 小时 4 分钟 51 秒。        对于业余跑者来说，能够完成半程马拉松已经是一个很好的成就。通常要求业余跑者在 2 小时 30 分钟内完成比赛才算合格。  合格规划  男子：2 小时 30 分钟之内  女子：3 小时内计划  半程马拉松的标准距离是 21.0975 公里      推荐方案          推荐 周一 / 周四      推荐 周二 / 周五            计划              week      1      2                  1      5 km      8 km              2      7 km      10 km              3      9 km      12 km              4      11 km      14 km              5      13 km      16 km              6      15 km      18 km              7      17 km      19 km              8      18 km      21 km      "
  },
  
  {
    "title": "TexasPoker",
    "url": "/posts/TexasPoker/",
    "categories": "Cc, Left, Games",
    "tags": "Game",
    "date": "2023-06-19 12:48:54 +0800",
    





    
    "snippet": "规则流程  德州扑克是一种广泛玩的扑克牌游戏，通常由 2 至 10 名玩家参与。以下是德州扑克的基本规则：            步骤      描述                  1. 发底牌 (Hole Cards)      每名玩家收到两张私有底牌，只有自己能看见。              2. 小盲注和大盲注 (Small Blind and Big Blind)      ...",
    "content": "规则流程  德州扑克是一种广泛玩的扑克牌游戏，通常由 2 至 10 名玩家参与。以下是德州扑克的基本规则：            步骤      描述                  1. 发底牌 (Hole Cards)      每名玩家收到两张私有底牌，只有自己能看见。              2. 小盲注和大盲注 (Small Blind and Big Blind)      两名玩家下小盲注和大盲注，小盲注通常是大盲注的一半。              3. 第一轮下注 (Pre-flop)      从大盲注玩家开始，逆时针方向，玩家可选择跟注、加注、弃牌或全下。              4. 翻牌 (Flop)      庄家翻开三张公共牌，放在牌桌中央。              5. 第二轮下注 (Post-flop)      玩家继续下注轮次，可选择跟注、加注、弃牌或全下。              6. 转牌 (Turn)      庄家翻开第四张公共牌，放在牌桌中央。              7. 第三轮下注 (Post-turn)      玩家再次下注，可选择跟注、加注、弃牌或全下。              8. 河牌 (River)      庄家翻开第五张公共牌，放在牌桌中央。              9. 最后一轮下注 (Post-river)      玩家进行最后一轮下注，可选择跟注、加注、弃牌或全下。              10. 摊牌 (Showdown)      玩家亮出手牌，比较牌的强弱，胜出者获得底池。              11. 颁发奖金      奖金分配给胜出的玩家，根据牌型的强弱分配。              12. 开始新一轮游戏      游戏进入下一轮，庄家位置和盲注位置继续移动。      牌值大小  A2345（也称为”轮”或”小顺子”）通常被视为最低的顺子            牌型      描述                  同花大顺 (Royal Flush)      同花色的 A、K、Q、J、10，最高的牌型。              同花顺 (Straight Flush)      同一花色的五张连续牌，例如：9、8、7、6、5。              四条 (Four of a Kind)      四张同样点数的牌，第五张牌不影响结果。              葫芦 (Full House)      三张同样点数的牌加一对，例如：K、K、K、5、5。              同花 (Flush)      五张同一花色的牌，不需要连续。              顺子 (Straight)      五张连续点数的牌，不需要同花色。              三条 (Three of a Kind)      三张同样点数的牌，另外两张不同点数的牌。              两对 (Two Pair)      两对不同点数的牌，例如：Q、Q、7、7、2。              一对 (One Pair)      一对相同点数的牌，另外三张不同点数的牌。              高牌 (High Card)      没有形成上述任何牌型的情况下，由最高点数的牌决定胜负。      边池在德州扑克中，奖池和边池是用来计算玩家赢取筹码的关键概念。下面是它们如何计算的：      奖池 (Main Pot): 主奖池是包括所有玩家的初始下注额的筹码。通常，它是在摊牌时由所有玩家共同下注的筹码总和。主奖池将由胜出的玩家赢得。        边池 (Side Pot): 如果某些玩家全下的筹码多于其他玩家跟注的筹码，就会形成边池。这是因为全下玩家的赌注超过了其他玩家所能跟注的额度。边池中的筹码将由全下玩家之间竞争，而不包括其他玩家。  计算边池的步骤：      计算主奖池中的筹码总额，这是所有玩家的初始下注的总和。        计算每位全下玩家总共下注的筹码总额。        如果有多名全下玩家，将按他们全下的顺序逐一考虑。对于第一名全下玩家，如果他的全下额多于其他玩家所能跟注的总额，多出的筹码将形成边池。        边池中的筹码将保持不变，直到摊牌。在摊牌时，边池中的筹码将由赢得摊牌的全下玩家赢得。主奖池中的筹码将由摊牌后赢得的最佳手牌的玩家赢得。  这个系统确保了在游戏中，全下玩家的额外赌注不会影响那些无法跟注全下的玩家，同时也为边池中的筹码分配提供了一种机制。在复杂的情况下，可能会有多个边池，每个都按相同的原则计算。牌力            CardType      Number      占比                  高牌      1302540      0.5043              一对      1098240      0.4227              两对      123552      0.0475              三条      54912      0.0211              顺子      10200      0.0039              同花      5108      0.0020              葫芦      3744      0.0014              四条      624      0.0002              同花顺      36      0.0000              皇家同花顺      4      0.0000      加注规则      加注额度： 加注时，通常需要下注一个大盲注的大小或更多。这意味着如果前一个玩家跟注了大盲注，你可以选择加注至少大盲注的额度。你也可以选择下更多的筹码，这被称为“加大注”。        加大注： 如果有玩家在同一轮下注中加注，其他玩家可以选择跟注原先的加注额（通常是大盲注的倍数），或者再次加注，将下注额提高。这将继续下去，直到没有玩家愿意再加注为止。        全下 (All-In)： 如果一名玩家的筹码不足以跟注或加注，他可以选择全下，将自己所有的筹码下注。这意味着他将赌上剩下的筹码，但他不再参与后续的下注轮。        回合结束： 一轮下注会一直进行，直到所有玩家都下相同数量的筹码，或者直到所有玩家除了一个弃牌。在回合结束后，翻牌、转牌、河牌等公共牌会依次翻开，然后进入下一轮下注。        限制和无限制： 德州扑克有限制版本和无限制版本。在限制版本中，每一轮下注都有一个上限，通常由大盲注的大小确定。在无限制版本中，玩家可以下任意数量的筹码，甚至可以将所有筹码全下。        筹码管理： 管理自己的筹码是很重要的。加注时，要确保你有足够的筹码来支持你的下注，以免在全下后被淘汰。  术语            术语      解释                  底牌 (Hole Cards)      玩家手中的两张私有牌，只有自己能看见。              底池 (Pot)      所有下注的筹码总额，作为奖金的来源。              小盲注 (Small Blind)      庄家左侧的玩家下的小盲注，通常是底池的一半。              大盲注 (Big Blind)      庄家左侧的玩家下的大盲注，通常是底池的全额。              庄家 (Dealer)      发牌员，代表庄家位置，负责发牌和决定发牌次序。              加注 (Raise)      在当前下注额度的基础上增加下注。              跟注 (Call)      与前一玩家的下注额度相同。              弃牌 (Fold)      放弃当前手牌，退出这一回合。              全下 (All-In)      下注所有筹码，无法再进行下注，但有资格赢得部分底池。              翻牌 (Flop)      游戏开始后，发出的前三张公共牌。              转牌 (Turn)      游戏继续后，翻出的第四张公共牌。              河牌 (River)      游戏继续后，翻出的第五张公共牌。              全屏 (Full House)      一对加上三条，例如：J、J、10、10、10。              三条 (Three of a Kind)      三张相同点数的牌。              葫芦 (Full House)      三条加上一对，例如：A、A、A、K、K。              同花 (Flush)      五张同一花色的牌，不需要连续。              同花大顺 (Royal Flush)      同花色的 A、K、Q、J、10，最高的牌型。              大翻盘 (Bad Beat)      一手在领先的情况下输掉，通常是因为运气不佳的情况。      踢脚牌在德州扑克中，”踢脚牌”（Kicker）是一种用来决定在出现相同牌型时，哪一手牌更强的辅助牌。当多名玩家都拥有相同牌型时，通常会比较他们的踢脚牌来决定胜负。例如，如果两名玩家都有一对（One Pair），即两张点数相同的牌，那么他们的胜负将由踢脚牌决定。如果一名玩家有一对 8（8, 8, X,X），而另一名玩家有一对 7（7, 7, X, X），那么拥有一对 8 的玩家胜出，因为 8 更高于 7。踢脚牌在德州扑克中非常重要，因为它可以帮助区分相同牌型的不同强度。如果踢脚牌也相同，那么可能会出现平局，底池将平均分配给这些平局的玩家。"
  },
  
  {
    "title": "Mysql Monitor",
    "url": "/posts/mysql-monitor/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2023-06-14 13:48:54 +0800",
    





    
    "snippet": "操作步骤如下  mysql 设置  CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'XXXXXXXX' WITH MAX_USER_CONNECTIONS 3;  GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';  mysqld_expor...",
    "content": "操作步骤如下  mysql 设置  CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'XXXXXXXX' WITH MAX_USER_CONNECTIONS 3;  GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';  mysqld_exporter  prometheus  grafanamysqld_exporter 启动GitHub      在机器对应目录下创建目录和文件          mkdir -p /home/save/mysqld_exporter/conf              touch config.my-cnf        [client]host=mysql-addressport=3306# socket=/var/run/mysqld/mysqld.sockuser=rootpassword=password-you[client.server1]user = barpassword = bar123                          docker-compose    version: \"3\"services:  mysqld-exporter:    container_name: mysqld-exporter    image: prom/mysqld-exporter    hostname: mysqld_exporter    ports:      - 9104:9104    volumes:      - ${PWD}/conf/config.my-cnf:/config.my-cnf    command:      - \"--config.my-cnf=/config.my-cnf\"      - \"--collect.binlog_size\"      - \"--collect.info_schema.replica_host\"    restart: always            启动          docker-compose up -d      docker-compose ps      docker-compose logs      prometheusscrape_configs:  - job_name: \"prometheus\"    static_configs:      - targets: [\"prometheus:9991\"]  - job_name: \"mysql\"    params:      auth_module: [client.servers]    static_configs:      - targets:          - mysql-address:3306          # - unix:///run/mysqld/mysqld.sock 本机也可以使用sock 文件    relabel_configs:      - source_labels: [__address__]        target_label: __param_target      - source_labels: [__param_target]        target_label: instance      - target_label: __address__        replacement: mysql-exporter-server:9104grafana  在面板 /dashboard/import  创建三种方法 GrafanaLabs Address          Upload      import id      import json                  Grafana                    最后结果  GitHub 推荐"
  },
  
  {
    "title": "Redis Monitor",
    "url": "/posts/redis-monitor/",
    "categories": "Dev, Database, Redis",
    "tags": "Database, Nosql",
    "date": "2023-06-14 12:48:54 +0800",
    





    
    "snippet": "操作步骤如下  redis-exporter  prometheus  grafanaredis-exporter 启动GitHub      在机器对应目录下创建目录和文件          mkdir -p /home/save/redis-exporter/conf              touch redis_conf.json        {  \"redis://redis-...",
    "content": "操作步骤如下  redis-exporter  prometheus  grafanaredis-exporter 启动GitHub      在机器对应目录下创建目录和文件          mkdir -p /home/save/redis-exporter/conf              touch redis_conf.json        {  \"redis://redis-address-1:6379\": \"\",  \"redis://redis-address-2:6379\": \"\",  \"redis://redis-address-3:6379\": \"****\"}                          docker-compose    version: \"3\"services:  redis-monitor:    container_name: redis-monitor    image: oliver006/redis_exporter    ports:      - \"9121:9121\"    command: \"-redis.password-file=/opt/redis_conf.json\"    volumes:      - /home/save/redis-exporter/conf/redis_conf.json:/opt/redis_conf.json    restart: \"always\"            启动          docker-compose up -d      docker-compose ps      docker-compose logs      prometheusscrape_configs:  - job_name: \"prometheus\"    static_configs:      - targets: [\"prometheus:9991\"]  - job_name: \"redis_exporter_targets\"    static_configs:      - targets:          - redis://redis-address-1:6379          - redis://redis-address-2:6379          - redis://redis-address-3:6379    metrics_path: /scrape    relabel_configs:      - source_labels: [__address__]        target_label: __param_target      - source_labels: [__param_target]        target_label: instance      - target_label: __address__        replacement: redis-exporter-address:9121  - job_name: \"redis_exporter\"    static_configs:      - targets:          - \"redis-exporter-address:9122\"grafana  在面板 /dashboard/import  创建三种方法 GrafanaLabs Address          Upload      import id      import json                  Github 推荐          中文汉化                    最后结果  GitHub 推荐  中文汉化"
  },
  
  {
    "title": "狼人杀",
    "url": "/posts/Werewolf-killing/",
    "categories": "Cc, Left, Werewolf killing",
    "tags": "Game",
    "date": "2023-06-13 12:48:54 +0800",
    





    
    "snippet": "狼人杀推荐网址  简介          狼人杀是一种常见的桌游，它需要多人参与，每个玩家都有一个特定的角色身份      在游戏中，玩家必须通过讨论和推理来找出谁是狼人，并将其赶出村庄，从而获得胜利      游戏攻略 1      游戏攻略 2              手势            基本规则  游戏开始前，所有玩家从中央随机抽取一张角色牌，可以看到自己的身份但不能让其他人...",
    "content": "狼人杀推荐网址  简介          狼人杀是一种常见的桌游，它需要多人参与，每个玩家都有一个特定的角色身份      在游戏中，玩家必须通过讨论和推理来找出谁是狼人，并将其赶出村庄，从而获得胜利      游戏攻略 1      游戏攻略 2              手势            基本规则  游戏开始前，所有玩家从中央随机抽取一张角色牌，可以看到自己的身份但不能让其他人看到  游戏分为白天和黑夜两个阶段，轮流进行。在白天，玩家通过讨论和投票来确定要执行哪个玩家（认为他是狼人）的身份。在黑夜，各角色依次行动，狼人可以选择击杀某个玩家，其他角色可以使用技能来帮助找出狼人。  每个白天，所有玩家都应发言，分享他们的想法和怀疑目标。如果有足够的证据在场上，任何玩家可以建议第一轮投票并选择要处决的玩家（即“狼人”），最终以最多票数的玩家被处决。      黑夜中，          狼人可以在限定时间内选择要击杀的对象。      预言家可以查验一个玩家的身份      女巫可以使用解药和毒药来挽救或害死某个被攻击的玩家      猎人可以选择带走一名单个玩家等      除了基本角色之外，也可以添加其他特殊角色来增加游戏趣味性。        在每个白天结束后，被投票选中的玩家的身份将被公布，并清除出局。如果该玩家是狼人，则村民获得胜利。如果不是，则游戏继续进行。  游戏可能会进入“尾声阶段”，即村庄中只有几个玩家留下时。在此阶段，所有玩家都可以发表更长的讨论意见，直到找出了狼人或狼人赢得游戏。  狼人杀需要玩家们通过推理、分析和交流来找出谁是狼人，并尽量保护自己的身份。这个游戏可以锻炼玩家的思维能力、逻辑思维、口才和团队精神，因此深受欢迎。角色介绍  法官：主持人  村民：正常村民，无特殊技能，只需通过讨论和投票来找出狼人  狼人：每晚可以行使能力，在限定时间内选择要击杀的对象。他们需要隐藏自己的身份，欺骗村民并试图夺取胜利  预言家：每晚可以查验一个玩家的身份，知道该玩家是否为狼人，并将信息告诉其他人  女巫：拥有解药和毒药两种药品，可以挽救或害死一个被狼人击杀的玩家  猎人：在死亡时可以选择带走一名单个玩家（确定他人身份）  守卫：每晚可以守护一个玩家，如果该玩家被狼人攻击，守卫可以牺牲自己保护该玩家  小女孩：可以查看一次所有人，但不参与白天讨论。若狼人选择了她，则本轮狼人失去行动权  飞行员：可以交换任意两名玩家的位置  先知：在场上随机挑选一张身份牌，就知道这个身份是不是狼人  丘比特：在第一天夜晚可以选择两个玩家成为情侣。如果一个情侣死亡，则另一个也会自杀  长老：村庄有长老时，白天不会被狼人攻击，只有夜晚活动才会被狼人攻击警长  警长的选举：在游戏开始时，所有玩家都可以自荐成为警长，并进行投票选举。通常情况下，得票最多的玩家将成为警长  警长的身份：一旦警长被选举出来，他会揭示自己的身份，并获得一张“警徽”卡牌，用于表示自己的身份  警长的发言权：作为警长，他有权利在白天（即狼人杀游戏中的讨论时间）发言。这使得他能够引导对话并指出其他玩家可能是狼人的证据  警长的投票权：警长在村庄的投票中拥有两票，这意味着他可以对结果产生很大的影响力  警长的保护：警长是一个非常重要的角色，在游戏中容易成为狼人的攻击目标。因此，在游戏过程中，其他村民通常会尽力保护警长  警长的猜测：作为警长，他需要通过观察和推理来猜测其他玩家的身份。如果能够正确地猜出狼人的身份，那么将大大提高村民们的胜利机会  警长警徽：当警长投出警长可以选择警徽留给场上人员，也可以撕毁  警长在狼人杀游戏中是一个非常重要的角色，他需要充分利用自己的发言权和投票权来帮助村民找出狼人的身份，并保护好自己。人数角色分配  6 人局：2 名狼人、1 名预言家、1 名女巫、1 名村民、1 名猎人  7 人局：2 名狼人、1 名预言家、1 名女巫、2 名村民、1 名猎人  8 人局：2 名狼人、1 名预言家、1 名女巫、3 名村民、1 名猎人  9 人局：3 名狼人、1 名预言家、1 名女巫、3 名村民、1 名猎人  10 人局：3 名狼人、1 名预言家、1 名女巫、4 名村民、1 名猎人  11 人局：3 名狼人、1 名预言家、1 名女巫、4 名村民、1 名猎人、1 名守卫  12 人局：4 名狼人、1 名预言家、1 名女巫、4 名村民、1 名猎人、1 名守卫  13 人局：4 名狼人、1 名预言家、1 名女巫、4 名村民、1 名猎人、1 名守卫、1 名长老  14 人局：4 名狼人、1 名预言家、1 名女巫、5 名村民、1 名猎人、1 名守卫、1 名长老  15 人局：4 名狼人、1 名预言家、1 名女巫、5 名村民、1 名猎人、1 名守卫、1 名长老、1 名丘比特游戏流程  法官先确认玩家都看过身份  第一天          晚上                  天黑请闭眼（所有人全部闭眼）不能说话          狼人                          狼人请睁眼：请互认身份，做出决策刀谁给出手势（号码牌）              狼人请闭眼                                预言家                          预言家请睁眼：选择要查验几号，你查验的号码是 好人（👍）坏人（👎）              预言家请闭眼                                女巫                          女巫请睁眼：你有解药和毒药；昨晚该号玩家倒牌、救请给手势 👍，毒请给号码牌，你给出是这个              女巫请闭眼                                猎人                          猎人请睁眼：你开枪状态是这个？                                          白天（天亮了）                  昨晚到牌情况                          *号玩家倒牌                                  有遗言                  猎人可以毒死不能开枪，反则其他可以开枪带走一个                                            昨晚平安夜                                开始竞选警长                          上警                                  需要举手 🙋                  人数 &gt; 2 两个人需要发言                  中途也可以下警                                            只有没上警的玩家可以投票那个警长                                警长选择发言顺序                          自发              左边              右边                                每个玩家发言          投票                          同时举出号码牌              票数最多直接出局                                出局                          首夜出局以及白天被放逐的时候才有遗言                                            第二天          晚上                  狼人          预言家          女巫          猎人                    天亮了      查看是否结束        第三天（重复）结束游戏  民众胜利：民众在游戏中成功地找出并淘汰了所有的狼人，则民众胜利。  狼人胜利：狼人在游戏中成功地除掉了所有的平民或其他阵营的角色，则狼人胜利。  第三方胜利：某些版本的狼人杀中含有第三方角色，他们通常有自己独特的获胜条件。"
  },
  
  {
    "title": "第七号嫌疑人",
    "url": "/posts/Suspect-number-seven/",
    "categories": "Cc, Left, Script killing",
    "tags": "Game",
    "date": "2023-06-13 12:48:54 +0800",
    





    
    "snippet": "游戏步骤前奏  讲述剧本类型  讲述内容背景  选角色游戏流程  发放对应角色剧本，并阅读阅读到“请勿翻开下一页”  主持人提示：自己任务第一阶段第一幕（10-15）  发放线索卡和地图          给角色发放对应角色名字线索卡 * 6      地图 * 4                  一楼平面图          二楼平面图          三楼平面图          四...",
    "content": "游戏步骤前奏  讲述剧本类型  讲述内容背景  选角色游戏流程  发放对应角色剧本，并阅读阅读到“请勿翻开下一页”  主持人提示：自己任务第一阶段第一幕（10-15）  发放线索卡和地图          给角色发放对应角色名字线索卡 * 6      地图 * 4                  一楼平面图          二楼平面图          三楼平面图          四楼阁楼                      讨论时间          自我介绍      分享自己唯一线索        讨论结束          可以阅读下个阶段      给播放视频-01      第二幕开始      第二幕 (45-60)  去教堂说秘密（阅读）  讨论结束后  继续阅读  播放视频-02  直接进入第三幕第三幕（10-15）  投票（洪先生该不该死）  投票记录          全部人闭上眼睛      该死 比手势      不该死 不动        投票记录保存好，  公布总结果（无需要给出细节）进入第四幕（45-60）  发放线索          阅读时 发放 “地下平面图” * 1      在搜索证时 发放线索卡 * 10        给出密码9426936  发放线索卡（阁楼密室）* 7第二阶段（90）开始  李察不需要直接翻开下一幕  第二套剧本直接阅读  读完之后直接告诉、现在时间 2020-5-18  重新自我介绍  发放线索          白色资料卡 * 6      516 金秤拍卖行结案相关资料        允许私聊和公聊，不限制  玩家遇到瓶颈，发放提示（酌情考虑）* 8结束  给出答案/玩家自行决定什么时候给出答案          5 个题目                  1 分          1 分          1 分          1 分          3 分                      公布结果，给每个玩家计算分数发布复盘答疑隐藏阶段（30）  是否开启          必须：玩家提问”是谁在第二通电话结束后删除的播放记录和通话记录“        主持人也可以引导开启（提问）          过场剧情文字宣读      给出红色调查卡 * 5        阶段任务          凶手是谁      动机是什么      杀人时间范围        复盘大结局  宣读文本Suspect number seven  全部内容  主持人手册 *1  音频 *2  结案相关资料 *1  剧本          1 *6      2 *5        线索卡 *42          第一阶段嫌疑人 *6      线索卡（密室阁楼） *7      灰色线索卡 *10      附加提示卡 *8      红色调查资料 *5      灰色调查资料 *6        音频          01 01 音频      02 01 音频      "
  },
  
  {
    "title": "VSCode conf",
    "url": "/posts/vscode-conf/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-05-27 11:32:25 +0800",
    





    
    "snippet": "快捷键  修改同名引用 F2  折叠光标处的代码方法          折叠所有 Ctrl+K+0      展开所有 Ctrl+K+J      vscode 配置  在当前工程目录下创建文件.vscode/launch.json{    \"version\": \"该配置文件的版本，由 VSCode 自动生成\",    \"configurations\": [        {        ...",
    "content": "快捷键  修改同名引用 F2  折叠光标处的代码方法          折叠所有 Ctrl+K+0      展开所有 Ctrl+K+J      vscode 配置  在当前工程目录下创建文件.vscode/launch.json{    \"version\": \"该配置文件的版本，由 VSCode 自动生成\",    \"configurations\": [        {            \"name\": \"名字，好听就行\",            \"type\": \"语言类型，装了插件后填 go 就会调用 dlv 命令\",            \"request\": \"launch 是启动新进程，append 是附加到现有的进程\",            \"mode\": \"dlv 的一些选项，支持 debug、exec、test、remote\",            \"host\": \"dlv 监听的地址\",            \"port\": \"dlv 监听的端口（此处应该是数字）\",            \"program\": \"本地的程序路径\",            \"cwd\": \"当前工作路径\",            \"env\": {                \"环境变量名\": \"环境变量值\"            },            \"args\": [\"程序启动参数\"],            \"showLog\": \"是否输出 dlv 的日志（此处应该是 true/false）\"        }    ]}演示      单个    {    \"version\": \"0.2.0\",    \"configurations\": [        {            \"name\": \"Debug with dlv\",            \"type\": \"go\",            \"request\": \"launch\",            \"mode\": \"debug\",            \"host\": \"127.0.0.1\",            \"port\": 2345,            \"program\": \"${workspaceFolder}/path/to/main.go\",            \"cwd\": \"${workspaceFolder}\",            \"env\": {},            \"args\": [],            \"showLog\": true        }    ]}        多个      {  \"version\": \"0.2.0\",  \"configurations\": [    {      \"name\": \"run_normal\",      \"type\": \"go\",      \"request\": \"launch\",      \"mode\": \"debug\",      \"program\": \"${workspaceRoot}/main.go\",      \"output\": \"run_normal\",      \"envFile\": \"${workspaceRoot}/script/server.env\",      \"env\": {        \"RunType\": \"1\",        \"ServerId\": \"yxx_a_1\",        \"GameListen\": \"0.0.0.0:8000\",        \"GameHttp\": \"0.0.0.0:8080\",      },    },    {      \"name\": \"run_manager\",      \"type\": \"go\",      \"request\": \"launch\",      \"mode\": \"debug\",      \"program\": \"${workspaceRoot}/main.go\",      \"output\": \"run_manager\",      \"envFile\": \"${workspaceRoot}/script/server.env\",      \"env\": {        \"RunType\": \"2\",        \"MGrpc\": \"0.0.0.0:8022\",        \"MHttp\": \"0.0.0.0:8021\",      },    },    {      \"name\": \"run_ai\",      \"type\": \"go\",      \"request\": \"launch\",      \"mode\": \"debug\",      \"program\": \"${workspaceRoot}/main.go\",      \"output\": \"run_testing\",      \"envFile\": \"${workspaceRoot}/script/server.env\",      \"env\": {        \"RunType\": \"3\",        \"GameListen\": \"ws://0.0.0.0:8000\"      },    },    {      \"name\": \"run_robot\",      \"type\": \"go\",      \"request\": \"launch\",      \"mode\": \"debug\",      \"program\": \"${workspaceRoot}/main.go\",      \"output\": \"run_testing\",      \"envFile\": \"${workspaceRoot}/script/server.env\",      \"env\": {        \"RunType\": \"99\",        \"name\": \"bt-1-2309189\",        \"gameAddress\": \"172.12.12.189:19014\",        \"RobotNumber\": \"2\",      },    },  ]  }  断点打一个断点，按下 F5，会发现项目已经启动起来了，访问一个 API，发现触发了断点：go install github.com/nsf/gocode@latestgo install github.com/uudashr/gopkgs/cmd/gopkgs@latestgo install github.com/ramya-rao-a/go-outline@latestgo install github.com/acroca/go-symbols@latestgo install golang.org/x/tools/cmd/guru@latestgo install golang.org/x/tools/cmd/gorename@latestgo install github.com/fatih/gomodifytags@latestgo install github.com/haya14busa/goplay/cmd/goplay@latestgo install github.com/josharian/impl@latestgo install github.com/davidrjenni/reftools/cmd/fillstruct@latestgo install github.com/rogpeppe/godef@latestgo install golang.org/x/tools/cmd/godoc@latestgo install sourcegraph.com/sqs/goreturns@latestgo install github.com/golang/lint/golint@latestgo install github.com/cweill/gotests/...@latestgo install github.com/derekparker/delve/cmd/dlv@latestgo install github.com/zmb3/gogetdoc@latestgo install golang.org/x/tools/cmd/goimports@latestgo install github.com/ramya-rao-a/go-outline@latestgo install github.com/mdempsky/gocode@latestgo install github.com/rogpeppe/godef@latestgo install golang.org/x/tools/cmd/guru@latestgo install golang.org/x/tools/cmd/gorename@latestgo install golang.org/x/tools/cmd/goimports@latestgo install github.com/uudashr/gopkgs/cmd/gopkgs@latestgo install github.com/golangci/golangci-lint/cmd/golangci-lint@latestgo install github.com/ramya-rao-a/go-outline@latestgo install github.com/acroca/go-symbols@latestgo install github.com/zmb3/gogetdoc@latestgo install github.com/fatih/gomodifytags@latestgo install github.com/cweill/gotests/...@latestgo install github.com/josharian/impl@latestgo install github.com/uudashr/gopkgs/cmd/gopkgs@latestgo install github.com/davidrjenni/reftools/cmd/fillstruct@latestgo install github.com/ramya-rao-a/go-outline@latestgo install github.com/acroca/go-symbols@latestgo install github.com/mdempsky/gocode@latestgo install github.com/rogpeppe/godef@latestgo install golang.org/x/tools/cmd/godoc@latestgo install github.com/zmb3/gogetdoc@latestgo install golang.org/x/lint/golint@latestgo install github.com/fatih/gomodifytags@latestgo install golang.org/x/tools/cmd/gorename@latestgo install sourcegraph.com/sqs/goreturns@latestgo install golang.org/x/tools/cmd/goimports@latestgo install github.com/cweill/gotests/...@latestgo install golang.org/x/tools/cmd/guru@latestgo install github.com/josharian/impl@latestgo install github.com/haya14busa/goplay/cmd/goplay@latestgo install github.com/uudashr/gopkgs/cmd/gopkgs@latestgo install github.com/davidrjenni/reftools/cmd/fillstruct@latestgo install github.com/alecthomas/gometalinter@latest"
  },
  
  {
    "title": "Server",
    "url": "/posts/server/",
    "categories": "Dev, Utils",
    "tags": "Dev, Servers",
    "date": "2023-05-27 11:32:25 +0800",
    





    
    "snippet": "程序员必备  服务端必备技术和工具编程语言      Java：Java 是应用最为广泛的服务端编程语言之一，它在企业级应用开发领域有广泛的应用。        Python：Python 具有简单易学、高效性和可扩展性等优点，在数据处理、机器学习等领域也非常流行。        Golang：Golang 是谷歌公司开发的现代编程语言，具有高并发性、高效性、易于编写和维护等优点，适合构建大...",
    "content": "程序员必备  服务端必备技术和工具编程语言      Java：Java 是应用最为广泛的服务端编程语言之一，它在企业级应用开发领域有广泛的应用。        Python：Python 具有简单易学、高效性和可扩展性等优点，在数据处理、机器学习等领域也非常流行。        Golang：Golang 是谷歌公司开发的现代编程语言，具有高并发性、高效性、易于编写和维护等优点，适合构建大型分布式系统。        JavaScript：JavaScript 是 Web 前端开发中不可缺少的语言，同时也可以用于编写服务端应用程序。Node.js 提供了一个服务器环境，使得 JavaScript 也可以被用来开发服务端程序。        C++：C++ 是一门强类型的编程语言，被广泛应用于高性能计算、游戏开发、操作系统、数据库等领域。        Rust：Rust 是一门安全而生的语言  Web 框架      Java：Java 开发中最常用的 Web 框架是 Spring。其他常用的框架还包括 Struts、Hibernate、MyBatis 等。        Python：Python 中常用的 Web 框架有 Django、Flask、Tornado、Pyramid 等。        Golang：Golang 中的 Web 框架也很多，常用的有 Gin、Echo、Beego、Martini 等。        JavaScript：JavaScript 作为一门跨平台的语言，被广泛应用于 Web 前后端开发。Node.js 支持的 Web 框架主要有 Express、Koa、Hapi 等。        Ruby：Ruby 开发中最常用的 Web 框架是 Ruby on Rails，它提供了一套完整的 MVC 架构，非常适合快速开发 Web 应用程序。  数据库      关系型数据库：关系型数据库是最常见的存储数据的方式，常用的关系型数据库包括 MySQL、Oracle、PostgreSQL、Microsoft SQL Server 等。        NoSQL 数据库：NoSQL 数据库适合存储非结构化数据和大规模数据。常用的 NoSQL 数据库包括 MongoDB、Cassandra、Redis、Elasticsearch 等。        NewSQL 数据库：NewSQL 数据库是传统关系型数据库和分布式 NoSQL 数据库的混合体，旨在提供更好的可扩展性和高可用性。常用的 NewSQL 数据库有 CockroachDB、TiDB 等。        图形数据库：图形数据库适用于处理复杂的关系网络数据，通常使用基于图论的算法进行查询和存储。常用的图形数据库包括 Neo4j、ArangoDB 等。        时间序列数据库：时间序列数据库适用于存储时间相关的数据，如物联网设备数据、日志数据等。常用的时间序列数据库包括 InfluxDB、OpenTSDB 等。  缓存      Redis：Redis 是一个基于内存的数据存储系统，可以用作缓存、消息队列和持久化存储等。它支持多种数据结构，如字符串、列表、哈希表等，并提供了丰富的操作命令。        Memcached：Memcached 是一个高性能的分布式内存缓存系统，适用于高并发读取、低并发写入的场景。它将数据存储在内存中，支持多线程操作，可以快速地存储和获取数据。        Guava Cache：Guava Cache 是 Google 的一个开源缓存库，提供了本地内存缓存功能，适用于小规模的应用程序。它支持自定义过期策略、最大缓存数量等参数配置。        Ehcache：Ehcache 是一个广泛使用的 Java 缓存框架，可以用于本地缓存或者分布式缓存，支持多种缓存策略，如 LRU、FIFO 等。        Caffeine：Caffeine 是一个 Java 缓存库，具有高性能、低延迟、简单易用等特点。它支持异步加载、过期时间设置、容量限制等功能。  消息队列      RabbitMQ：RabbitMQ 是一个开源的 AMQP（高级消息队列协议）实现，支持多种消息传输模式，如点对点、发布/订阅和请求/响应等。它具有高可靠性、高可扩展性和丰富的插件机制。        Apache Kafka：Apache Kafka 是一个高吞吐量、分布式的消息系统，适合处理大规模的日志数据和流数据。它具有低延迟、高可靠性、可伸缩性和多语言支持等特点。        ActiveMQ：ActiveMQ 是一个基于 JMS（Java 消息服务）协议的开源消息中间件。它支持多种传输协议，如 TCP、UDP、HTTP 和 WebSockets 等，并提供了多种语言客户端库。        RocketMQ：RocketMQ 是阿里巴巴公司自主研发的开源分布式消息中间件，具有高可用、高性能、高可扩展性等特点，支持多种消息协议和消息存储方式。        NSQ：NSQ 是由 Bitly 公司开发的分布式实时消息平台，具有高可靠性、易于部署和维护等特点，适合处理实时数据流。    除此之外，还有许多其他的消息队列方案，如 ZeroMQ、Redis 消息队列等服务器      Apache HTTP Server：Apache HTTP Server 是一个常用的开源 Web 服务器软件，可运行于多个操作系统平台上，如 Windows、Linux、Unix 等。它支持多种语言和通信协议，并提供了丰富的插件和模块。        Nginx：Nginx 是一个轻量级的高性能 Web 服务器和反向代理服务器，适用于处理静态文件、负载均衡、反向代理等任务。它具有低内存消耗、高并发连接等优点。        Tomcat：Tomcat 是一个常用的 Java Web 应用服务器，可以托管 Java Servlet 和 JSP 应用程序。它简单易用、开源免费，并且与 Spring 等框架集成良好。        Jetty：Jetty 是一个轻量级的 Java Web 服务器，具有高效、灵活、易于嵌入的特点。它支持多种 Web 标准和协议，并提供了多种 API 和插件。        Node.js：Node.js 不仅是一种编程语言，也是一种 Web 服务器环境，用于运行 JavaScript 代码。它具有高性能、异步 I/O、事件驱动等优点，适合构建高并发的网络应用程序。    此外，还有许多其他的服务器软件，如 IIS、Caddy、Lighttpd 等容器化技术      Docker：Docker 是一种轻量级的容器化技术，可以将应用程序和依赖项打包成一个独立的容器，实现跨平台的部署。它具有快速启动、高效利用系统资源等优点，支持自动化构建、发布和运行应用程序。        Kubernetes：Kubernetes 是一种开源的容器编排引擎，用于管理容器化的应用程序和服务。它提供了多种功能，如自动负载均衡、自动扩缩容、滚动升级和回滚等。        Apache Mesos：Apache Mesos 是一种分布式系统内核，用于在集群中管理资源和调度任务。它支持多种框架和任务类型，如 Hadoop、Spark、Docker 等，并提供了多种 API 和工具。        LXD：LXD 是一个轻量级的系统容器技术，适用于高性能计算、虚拟化、云计算等领域。它提供了全系统虚拟化和模拟功能，可实现完整的操作系统镜像和容器的创建和管理。        OpenShift：OpenShift 是一种基于 Kubernetes 的企业级容器化平台，提供了一整套应用程序、服务和解决方案。它支持多语言和多框架的应用程序开发、测试和部署，并提供了丰富的自动化工具。    除此之外，还有许多其他的容器化技术，如 Docker Compose、Docker Swarm、Mesosphere DC/OS 等自动化部署工具      Ansible：Ansible 是一种轻量级的自动化配置管理工具，可以用于配置服务器、应用程序和网络设备等。它支持多种操作系统和云平台，并使用 YAML 格式描述配置信息。        Jenkins：Jenkins 是一个开源的自动化构建和测试工具，可实现自动化编译、测试和部署等任务。它支持多种插件和扩展，如 Git、Docker、Kubernetes 等。        Puppet：Puppet 是一个流行的自动化配置管理工具，可用于管理多个服务器并保持一致性。它支持多种操作系统和云平台，并提供了丰富的模块和资源。        Chef：Chef 是另一种广泛使用的自动化配置管理工具，可用于自动化部署应用程序和管理基础架构。它支持多种操作系统和云平台，并提供了丰富的模块和资源。        SaltStack：SaltStack 是一种快速、灵活和可扩展的自动化配置管理工具，可用于远程执行命令、配置服务器和管理基础架构。它支持多种操作系统和云平台，并提供了分布式部署和多种通信协议。  日志收集工具      ELK Stack：ELK Stack 是一个由 Elastic 公司开发的日志管理平台，包括 Elasticsearch、Logstash 和 Kibana 三个组件。它可以采集、存储和分析各种类型的日志数据，并提供了丰富的查询和可视化功能。        Graylog：Graylog 是一种开源的日志管理平台，类似于 ELK Stack，但更加易于安装和配置。它支持多种输入来源、多种输出方式，以及强大的搜索和过滤功能。        Fluentd：Fluentd 是一种轻量级的日志收集和转发工具，支持多种日志格式和多种输出方式。它可以与 ELK Stack 或其他分布式系统集成，并提供了丰富的插件和扩展。        Splunk：Splunk 是一种商业化的日志管理和分析软件，可用于监控、搜索和分析各种类型的数据。它支持多种数据源和数据格式，并提供了丰富的查询和可视化功能。        Papertrail：Papertrail 是一种云端日志管理服务，可用于实时日志查看、搜索和过滤等任务。它支持多种日志来源和多种输出方式，并提供了通知和警报功能。  监控系统      Nagios：Nagios 是一种开源的系统和网络监控工具，可以用于监控主机、服务、网络设备等。它支持多种通信协议和插件，并提供了丰富的报警和通知功能。        Zabbix：Zabbix 是一种流行的企业级监控系统，可用于监控服务器性能、网络流量、应用程序状态等。它支持多种数据源和数据格式，并提供了图形化的界面和可定制的仪表板。        Prometheus：Prometheus 是一个开源的时序数据库和监控系统，适用于容器化环境和云原生应用程序。它使用 HTTP 协议采集指标数据，并提供了丰富的查询和告警规则。        Grafana：Grafana 是一种流行的开源数据可视化平台，可以与其他监控系统集成。它支持多种数据源和数据格式，并提供了可定制的仪表板和报表。        Sensu：Sensu 是一种轻量级的分布式监控和告警系统，可用于检测服务和基础设施故障。它提供了多种插件和扩展，可用于监控不同类型的应用程序和服务。  "
  },
  
  {
    "title": "Math Other",
    "url": "/posts/3-Math/",
    "categories": "Cc, Math",
    "tags": "Math",
    "date": "2023-05-18 12:02:56 +0800",
    





    
    "snippet": "高等数学课程1.微积分微积分是高等数学中最基础和最重要的一部分，它包括单变量微积分和多变量微积分。单变量微积分包括极限、导数和积分，多变量微积分包括偏导数、多元函数的极值和多重积分等。2.线性代数线性代数是一门研究向量空间和线性映射的数学学科，它包括矩阵的基本运算和性质、行列式、向量空间、线性变换、特征值和特征向量等。3.常微分方程常微分方程是研究描述自然现象中的变化过程的数学工具，它包括一...",
    "content": "高等数学课程1.微积分微积分是高等数学中最基础和最重要的一部分，它包括单变量微积分和多变量微积分。单变量微积分包括极限、导数和积分，多变量微积分包括偏导数、多元函数的极值和多重积分等。2.线性代数线性代数是一门研究向量空间和线性映射的数学学科，它包括矩阵的基本运算和性质、行列式、向量空间、线性变换、特征值和特征向量等。3.常微分方程常微分方程是研究描述自然现象中的变化过程的数学工具，它包括一阶和高阶常微分方程、线性和非线性常微分方程等。4.多元函数微积分多元函数微积分是对多元函数的微积分进行深入研究，它包括偏导数、梯度、多元函数的积分和曲线、曲面积分等。5.实变函数和复变函数实变函数和复变函数是研究实数和复数域上的函数的性质和理论的数学分支，包括实变函数的连续性、一致连续性、极限理论和函数列、复变函数的解析性和亚纯函数等。6.傅里叶分析傅里叶分析是一种将信号分解成基本周期函数的数学方法，它包括傅里叶级数、傅里叶变换、拉普拉斯变换等排列组合基础排列和组合是数学中的两个概念，它们常用于解决计数问题。排列是指从一组元素中取出一些元素按照一定的顺序排列，它的符号通常用 $A_n^m$ 或 $P_n^m$ 表示。其中，$n$ 表示元素的总数，$m$ 表示要取出的元素个数，$n$ 和 $m$ 都是非负整数且 $n \\geq m$。其公式为：$A_n^m=\\frac{n!}{(n-m)!}$ 或 $P_n^m=n(n-1)(n-2)\\cdots(n-m+1)$。组合是指从一组元素中取出一些元素，不考虑其顺序，它的符号通常用 $C_n^m$ 或 $\\binom{n}{m}$ 表示。其中，$n$ 表示元素的总数，$m$ 表示要取出的元素个数，$n$ 和 $m$ 都是非负整数且 $n \\geq m$。其公式为：$C_n^m=\\frac{n!}{m!(n-m)!}$ 或 $\\binom{n}{m}=\\frac{n!}{m!(n-m)!}$。需要注意的是，排列和组合的区别在于是否考虑元素的顺序。如果考虑元素的顺序，就是排列；如果不考虑元素的顺序，就是组合。在实际应用中，排列和组合经常用于计算可能性的数量，例如在赛事中确定参赛人员的名单、计算密码的组合等学习方法  熟练掌握阶乘的概念和计算方法，因为排列和组合的计算中会用到阶乘。  掌握排列和组合的定义和公式，并了解它们的区别。  通过练习题巩固理论知识，可以从基础的排列组合问题开始练习，例如从一堆球中选出几个球进行排列或组合等。可以逐渐增加难度，提高解题能力。  多关注实际问题中的排列组合应用，例如在赛事中确定参赛人员的名单、计算密码的组合等，可以帮助理解排列组合的应用场景。  学习计算机科学中的排列组合算法，例如回溯算法、动态规划算法等，可以提高对排列组合的理解和应用能力。  最后，需要坚持练习和复习，不断巩固和提高自己的排列组合能力。阶乘的概念和计算方法阶乘是指从 1 到某个正整数之间所有整数的乘积。例如，$5!$ 表示从 1 到 5 之间所有整数的乘积，即 $5!=1\\times2\\times3\\times4\\times5=120$。阶乘通常用符号 $n!$ 表示，其中 $n$ 是一个非负整数。计算阶乘的方法很简单，只需将从 1 到 $n$ 之间的所有整数相乘即可。如果 $n$ 是一个较大的数，可以使用科学计数法来表示。例如，$100!$ 可以表示为 $9.332621544\\times10^{157}$。阶乘在数学和计算机科学中都有广泛的应用。在数学中，阶乘是组合数学中的一个基本概念，与排列、组合等概念密切相关。在计算机科学中，阶乘的计算经常用于算法设计中，例如递归算法、动态规划算法等。需要注意的是，阶乘只定义在非负整数上，对于负数或小数等其他类型的数，阶乘没有意义排列和组合的定义和公式排列和组合是组合数学中的两个基本概念，它们描述了从一组元素中选取若干个元素的不同方式。排列是指从 $n$ 个不同元素中，选取 $m$ 个元素进行排列，有多少种不同的排列方式。排列的公式为：\\[A_n^m=\\frac{n!}{(n-m)!}\\]其中，$A_n^m$ 表示 $n$ 个不同元素中，选取 $m$ 个元素进行排列的方案数，称为 $n$ 取 $m$ 的排列数。组合是指从 $n$ 个不同元素中，选取 $m$ 个元素进行组合，有多少种不同的组合方式。组合的公式为：\\[C_n^m=\\frac{n!}{m!(n-m)!}\\]其中，$C_n^m$ 表示 $n$ 个不同元素中，选取 $m$ 个元素进行组合的方案数，称为 $n$ 取 $m$ 的组合数。需要注意的是，排列和组合的计算公式中都涉及阶乘的计算，因此在计算排列和组合之前，需要先掌握阶乘的概念和计算方法。此外，排列和组合的区别在于是否考虑元素的顺序，因此在实际问题中需要根据具体情况选择使用排列还是组合。排列和组合的经典问题排列和组合在组合数学中有着广泛的应用，可以用来解决很多经典的问题，以下列举一些：  生日悖论：在一个房间里，如果有 23 个人，那么至少有两个人生日相同的概率是多少？这个问题可以通过计算从 365 个不同的生日中选取 23 个生日的不同排列数来解决，即 $A_{365}^{23}$，然后将其除以 365 的 23 次方，得到概率约为 0.5073。  扑克牌的组合数：扑克牌一副共有 52 张牌，如果从中选取 5 张牌组成一副“手牌”，那么有多少种不同的手牌组合方式？这个问题可以通过计算从 52 张牌中选取 5 张牌的不同组合数来解决，即 $C_{52}^5$，得到答案为 2,598,960。  队伍的排列组合：在一个班级里，有 20 个人，其中有 5 个人被选为演讲代表，如果要按照一定的顺序排成一队，那么有多少种不同的排列方式？这个问题可以通过计算从 5 个代表中选取 5 个人进行排列的方案数来解决，即 $A_5^5$，得到答案为 120。  二项式定理：二项式定理是组合数学中的一个重要定理，它描述了两个数之和的幂的展开式。具体来说，它表示：\\[(a+b)^n=\\sum_{k=0}^n C_n^k a^{n-k}b^k\\]其中，$C_n^k$ 表示从 $n$ 个元素中选取 $k$ 个元素进行组合的方案数。以上仅是排列和组合问题的一部分例子，排列和组合在现实生活和科学研究中有着广泛的应用，掌握排列和组合的基本原理和方法，能够帮助我们更好地理解和解决这些问题离散数学离散数学基础离散数学是研究离散量的数学学科，它涵盖了数论、图论、逻辑、集合论、代数结构、组合数学等多个分支。离散数学在计算机科学、信息科学、工程学等领域中有着广泛的应用。以下是离散数学的基础知识点：  集合论：集合论是研究集合及其运算的数学分支，它包括集合的基本概念、集合的运算、集合的关系、集合的代数运算、集合的函数、基数等概念。  逻辑：逻辑是研究正确推理的科学，它包括命题逻辑、一阶逻辑、模态逻辑等多个分支。逻辑中的基本概念包括命题、命题变元、联结词、真值表、命题公式等。  图论：图论是研究图及其性质的数学分支，它包括图的基本概念、图的遍历、图的连通性、图的染色、最短路径等问题。  代数结构：代数结构是研究代数系统及其性质的数学分支，它包括群论、环论、域论等多个分支。代数结构中的基本概念包括代数系统的定义、子群、正规子群、同态、同构等。  组合数学：组合数学是研究离散对象的组合方式的数学分支，它包括排列组合、二项式定理、生成函数、容斥原理等多个分支。离散数学经典题目  二分图匹配：给定一个二分图，求最大匹配数。二分图匹配是指在一个二分图中，选取尽量多的边使得每个顶点最多只与一个相邻顶点相连。  哈密尔顿回路：给定一个无向图，是否存在一条路径使得它经过图中每个顶点恰好一次，并且最终回到起点。这个问题是 NP-完全问题，即在多项式时间内不能解决。  平面图着色问题：给定一个平面图，求最少需要几种颜色来为每个顶点进行着色，使得相邻的顶点颜色不同。  约瑟夫问题：有 n 个人排成一个圆圈，从第 k 个人开始依次报数，报到第 m 个人出列，然后从出列的下一个人开始重新报数，直到所有人都出列。求出最后一个出列的人在初始圆圈中的编号。  网络流最大流：给定一个有向图和它的容量，以及一个源点和汇点，求出从源点到汇点的最大流量概率论和统计学概率论和统计学是数学中的两个重要分支，它们都与随机现象相关。概率论研究的是随机事件发生的概率，而统计学研究的是如何从样本数据中推断总体数据的特征。以下是概率论和统计学的一些基本概念和方法：  概率：指某个事件发生的可能性。概率可以用数值表示，其取值范围是 0 到 1。  条件概率：指在已知某一事件发生的条件下，另一事件发生的概率。  独立事件：指两个或多个事件之间互不影响，其中一个事件的发生不会影响另一个事件的发生。  期望值：指一组数据的平均值，其计算方法是将每个数据乘以其概率，然后将乘积相加。  方差：指一组数据的离散程度，其计算方法是将每个数据与期望值的差的平方乘以其概率，然后将乘积相加。  正态分布：是概率论中的一种常见分布，其形态为钟形曲线，其均值、方差是对其分布特性的刻画。  抽样：指从总体中随机地抽取一部分样本数据，以便用样本数据来推断总体数据的特征。  参数估计：是指通过样本数据来估计总体数据的未知参数。  假设检验：是指根据样本数据，判断总体数据的某个假设是否成立概率论和统计学 经典题目以下是概率论和统计学中的一些经典题目：  假设有一枚硬币，投掷 10 次，每次正面向上的概率为 0.6，那么投掷 10 次后，恰好有 6 次正面向上的概率是多少？  一家工厂生产的零件，其长度服从均值为 10 厘米、标准差为 0.5 厘米的正态分布。现从工厂中随机抽取 10 个零件，计算其长度的平均值，求平均长度在 9.5 到 10.5 之间的概率是多少？  某城市每日发生的交通事故数量服从参数为 3 的泊松分布。求这个城市每周至少发生一次交通事故的概率是多少？  一项检测仪器的误差服从均值为 0、标准差为 0.05 的正态分布。现从检测仪器中随机取出 10 个样本进行检测，计算其误差的平均值。问这个样本的平均误差是否与检测仪器的标准误差有显著差异？  假设一个班级中男生和女生的比例为 3：4，从班级中随机选出 2 个学生，问这两个学生都是女生的概率是多少？这些题目覆盖了概率论和统计学中的常见问题和方法，对于想要学习和掌握概率论和统计学的人来说是很有帮助的线性代数  线性代数是数学的一个分支，主要研究线性方程组、向量空间、线性变换和矩阵等概念和方法。以下是线性代数中一些常见的内容和知识点：  向量和向量空间：向量是线性代数中的基本概念，向量可以表示为一个有限个数的有序实数列表，或者一个点的坐标。向量空间是指由向量和对向量的加法和数乘所构成的一个集合，满足一定的公理。  矩阵和矩阵运算：矩阵是由数个数排列成的矩形阵列，矩阵可以表示为一个有限个数的有序实数列表。矩阵的加法、数乘和乘法等运算是线性代数中的基本运算。  线性方程组：线性方程组是由若干个线性方程组成的方程组，其中每个方程的未知数都是一次项。解线性方程组的方法包括高斯消元法、矩阵的逆、克拉默法则等。  行列式和特征值：行列式是一个数学概念，可以用来判断一个方阵是否可逆，求解线性方程组的解等。特征值是指一个线性变换在某个向量上作用后，得到的向量与原向量方向相同或相反的数量。  线性变换和矩阵表示：线性变换是指向量空间之间的一个映射，线性变换可以用矩阵表示，矩阵表示是将向量空间之间的线性变换表示为矩阵的形式线形代数经典题目  求解线性方程组：给定一个线性方程组，求其解集。  求解矩阵的逆：给定一个方阵，求其逆矩阵。  求解矩阵的秩：给定一个矩阵，求其秩。  求解矩阵的特征值和特征向量：给定一个方阵，求其特征值和特征向量。  求解线性变换的矩阵表示：给定一个线性变换，求其在某个基下的矩阵表示。  求解向量空间的基和维数：给定一个向量空间，求其基和维数。  求解线性变换的核和像空间：给定一个线性变换，求其核空间和像空间。  求解矩阵的特征分解：给定一个方阵，求其特征分解。以上是线性代数中的一些经典题目，这些题目涉及到线性方程组、矩阵、线性变换等基本概念和方法。熟练掌握这些题目可以加深对线性代数的理解和应用。数值计算  数值计算是一门研究用数值方法解决数学问题的学科。它涉及到数值方法、数值分析、数值逼近、误差分析、数值优化等方面的内容。以下是数值计算中的一些经典问题：  插值问题：给定一些已知数据点，如何构造一个函数来近似这些数据点？  数值微积分问题：如何用数值方法计算函数的导数、积分、微分方程等？  数值线性代数问题：如何用数值方法求解线性方程组、矩阵特征值等问题？  非线性方程组求解：如何用数值方法求解非线性方程组？  数值优化问题：如何用数值方法求解最优化问题，例如求解无约束优化问题、线性规划问题、非线性规划问题等？  常微分方程数值解法：如何用数值方法求解常微分方程的初值问题？  偏微分方程数值解法：如何用数值方法求解偏微分方程问题？数值计算是应用数学的一个重要分支，涉及到很多实际问题的数值模拟和计算。在实际应用中，需要根据问题的具体特点选取适当的数值方法和算法来解决问题。掌握数值计算基本概念和常见方法，对于从事科学研究和工程技术的人员来说，都是非常重要的。数值计算 经典题目  插值问题：给定一些已知数据点，如何构造一个函数来近似这些数据点？常用的插值方法有拉格朗日插值、牛顿插值、分段线性插值、分段三次样条插值等。  数值微积分问题：如何用数值方法计算函数的导数、积分、微分方程等？常用的数值微积分方法有数值微分公式、复化求积公式、龙格-库塔法等。  数值线性代数问题：如何用数值方法求解线性方程组、矩阵特征值等问题？常用的数值线性代数方法有高斯消元法、LU 分解法、QR 分解法、幂法、反幂法等。  非线性方程组求解：如何用数值方法求解非线性方程组？常用的非线性方程组求解方法有牛顿法、割线法、弦截法、埃特金法等。  数值优化问题：如何用数值方法求解最优化问题，例如求解无约束优化问题、线性规划问题、非线性规划问题等？常用的数值优化方法有梯度下降法、共轭梯度法、单纯形法、内点法等。  常微分方程数值解法：如何用数值方法求解常微分方程的初值问题？常用的常微分方程数值解法有欧拉法、改进的欧拉法、龙格-库塔法等。  偏微分方程数值解法：如何用数值方法求解偏微分方程问题？常用的偏微分方程数值解法有有限差分法、有限元法、谱方法等。导数导数是微积分的一个基本概念，它描述了函数在某一点的变化率。对于函数 $f(x)$，它在 $x=a$ 处的导数定义为：\\[f'(a) = \\lim\\_{h\\to 0} \\frac{f(a+h) - f(a)}{h}\\]其中 $h$ 是一个无限趋近于 $0$ 的数。几何上来说，导数可以理解为函数在该点处的切线斜率。如果导数存在，那么函数在该点处是可导的，也就意味着函数在该点附近有一个较好的近似线性函数。对于函数 $y=f(x)$，其导数可以表示为 $y’$、$f’(x)$ 或 $\\frac{dy}{dx}$。常见的导数运算法则包括加减法规则、乘法规则、除法规则、链式法则、反函数法则等。导数有广泛的应用，例如用于求解极值问题、优化问题、微分方程等导数例子  常数函数：对于任何常数 $c$，$f(x)=c$ 的导数为 $f’(x)=0$。  幂函数：对于 $f(x)=x^n$，其中 $n$ 是正整数，则 $f’(x)=nx^{n-1}$。  指数函数：对于 $f(x)=a^x$，其中 $a$ 是正实数，则 $f’(x)=a^x\\ln a$。  对数函数：对于 $f(x)=\\log_a x$，其中 $a$ 是正实数且 $a \\neq 1$，则 $f’(x)=\\frac{1}{x\\ln a}$。  三角函数：对于 $f(x)=\\sin x$，则 $f’(x)=\\cos x$；对于 $f(x)=\\cos x$，则 $f’(x)=-\\sin x$；对于 $f(x)=\\tan x$，则 $f’(x)=\\sec^2 x$导数经典题目  求函数 $f(x)=x^2+2x+1$ 在 $x=2$ 处的导数。解答：对函数 $f(x)$ 求导，得到 $f’(x)=2x+2$。因此，$f’(2)=2\\cdot 2+2=6$。  求函数 $f(x)=\\sin x$ 在 $x=\\frac{\\pi}{2}$ 处的导数。解答：对函数 $f(x)=\\sin x$ 求导，得到 $f’(x)=\\cos x$。因此，$f’(\\frac{\\pi}{2})=\\cos(\\frac{\\pi}{2})=0$。  求函数 $f(x)=\\frac{1}{x}$ 在 $x=2$ 处的导数。解答：对函数 $f(x)=\\frac{1}{x}$ 求导，得到 $f’(x)=-\\frac{1}{x^2}$。因此，$f’(2)=-\\frac{1}{2^2}=-\\frac{1}{4}$。  求函数 $f(x)=\\sqrt{x+1}$ 在 $x=3$ 处的导数。解答：对函数 $f(x)=\\sqrt{x+1}$ 求导，得到 $f’(x)=\\frac{1}{2\\sqrt{x+1}}$。因此，$f’(3)=\\frac{1}{2\\sqrt{3+1}}=\\frac{1}{4}$。  求函数 $f(x)=x^2\\ln x$ 在 $x=1$ 处的导数。解答：对函数 $f(x)=x^2\\ln x$ 求导，需要使用乘法法则和对数函数的求导公式。首先，$f’(x)=2x\\ln x + x$；然后，由于 $\\lim_{x\\to 0} \\ln x = -\\infty$，因此 $f’(1)=2\\cdot 1\\cdot \\ln 1 + 1 = 1$。数学中方程分类  一元一次方程：形如 $ax + b = 0$，其中 $a,b$ 为常数，$x$ 为未知数。  一元二次方程：形如 $ax^2 + bx + c = 0$，其中 $a,b,c$ 为常数，$x$ 为未知数。  一元三次方程：形如 $ax^3 + bx^2 + cx + d = 0$，其中 $a,b,c,d$ 为常数，$x$ 为未知数。  一元多次方程：形如 $a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0 = 0$，其中 $a_0, a_1, \\ldots, a_n$ 为常数，$x$ 为未知数。  二元一次方程组：形如 $\\begin{cases} ax + by = c \\ dx + ey = f \\end{cases}$，其中 $a,b,c,d,e,f$ 为常数，$x,y$ 为未知数。  二元二次方程组：形如 $\\begin{cases} ax^2 + by^2 + cx + dy + e = 0 \\ fx^2 + gy^2 + hx + iy + j = 0 \\end{cases}$，其中 $a,b,c,d,e,f,g,h,i,j$ 为常数，$x,y$ 为未知数。  高次方程组：形如 $f_1(x_1, x_2, \\ldots, x_n) = 0, f_2(x_1, x_2, \\ldots, x_n) = 0, \\ldots, f_m(x_1, x_2, \\ldots, x_n) = 0$，其中 $f_1,f_2,\\ldots,f_m$ 是 $n$ 个未知数 $x_1, x_2, \\ldots, x_n$ 的多项式。除了上述常见的方程式外，还有一些特殊的方程式，如三角方程、指数方程、对数方程、差分方程等。不同类型的方程式有不同的解法和性质，需要根据具体情况来选择相应的方法和技巧一元  一元一次方程是指形如 $ax + b = 0$ 的方程，其中 $a$ 和 $b$ 为常数，$x$ 为未知数  一元二次方程是指形如 $ax^2 + bx + c = 0$ 的方程，其中 $a, b, c$ 为常数，$x$ 为未知数。  一元三次方程是指形如 $ax^3 + bx^2 + cx + d = 0$ 的方程，其中 $a, b, c, d$ 为常数，$x$ 为未知数  一元多次方程是指形如 $a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_1 x + a_0 = 0$ 的方程，其中 $a_0, a_1, \\ldots, a_n$ 为常数，$x$ 为未知数，$n$ 为方程的次数          下面分别给出一元一次方程、一元二次方程、一元三次方程和一元多次方程的一个例子以及其解答：        解一元一次方程 $2x + 3 = 7$。解：将方程中的常数项 $3$ 移到等号的右侧，得到 $2x = 4$，再将系数 $2$ 除到 $x$ 的左侧，得到 $x = 2$。因此，方程的解为 $x = 2$。      解一元二次方程 $x^2 - 4x + 3 = 0$。解：使用求根公式，将 $a=1, b=-4, c=3$ 代入，得到：\\[x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{4 \\pm \\sqrt{16 - 4 \\cdot 1 \\cdot 3}}{2 \\cdot 1} = 1, 3\\]    因此，方程的解为 $x=1$ 或 $x=3$。        解一元三次方程 $x^3 + 2x^2 - x - 2 = 0$。解：观察方程的系数，发现 $x=1$ 是一个根。因此，可以通过带余除法将 $x-1$ 除掉，得到：\\[x^3 + 2x^2 - x - 2 = (x-1)(x^2 + 3x + 2) = 0\\]    这是一个二次方程，可以使用求根公式求解，得到 $x=-1$ 和 $x=-2$。因此，方程的解为 $x=1$，$x=-1$ 或 $x=-2$。    解一元四次方程 $x^4 + x^3 - 6x^2 - 7x + 10 = 0$。解：该方程不容易用求根公式求解，可以使用因式分解或者数值逼近的方法求解。其中，因式分解的方法需要对方程二元  二元一次方程组是由两个一次方程组成的方程组，其一般形式为：a₁x + b₁y = c₁a₂x + b₂y = c₂其中，a₁、a₂、b₁、b₂、c₁、c₂ 为已知常数，x、y 为未知数。  二元二次方程组是由两个二次方程组成的方程组，其一般形式为：a₁x² + b₁y² + c₁xy + d₁x + e₁y + f₁ = 0a₂x² + b₂y² + c₂xy + d₂x + e₂y + f₂ = 0其中，a₁、a₂、b₁、b₂、c₁、c₂、d₁、d₂、e₁、e₂、f₁、f₂ 为已知常数，x、y 为未知数。  二元一次方程组和二元二次方程组都是数学中常见的方程组，求解这些方程组可以应用代数、几何和矩阵等不同的方法。对于具体的题目和答案，需要根据题目给出的具体条件进行求解  经典题目【例题 1】已知方程组：2x + y = 53x - y = 1求解方程组的解。【解答】将第二个方程的左边乘以 2 得到 6x-2y=2，与第一个方程相加可得 8x=7，解得 x=7/8，代入第一个方程可得 y=3/8，因此该方程组的解为 x=7/8，y=3/8。二元二次方程组的经典题目：【例题 2】已知方程组：x² + y² = 25x + y = 7求解方程组的解。【解答】将第二个方程改写为 y=7-x，代入第一个方程可得 x²+(7-x)²=25，化简可得 2x²-14x+24=0，进一步化简得到 x=2 或 x=6。将 x 的值代入 y=7-x，可得当 x=2 时 y=5，当 x=6 时 y=1。因此该方程组的解为(x,y)=(2,5)或(6,1)。  解题方法  相减法：将两个方程中同一变量系数相等的项相减，得到一个只包含一个未知数的一次方程，从而求出这个未知数的值，再代入其中一个方程求另一个未知数的值。  代入法：将一个方程中的一个未知数表示成另一个未知数的函数，再代入另一个方程，得到只包含一个未知数的一次方程，从而求出这个未知数的值，再代入其中一个方程求另一个未知数的值。  加法法：将两个方程相加，得到一个只包含一个未知数的一次方程，从而求出这个未知数的值，再代入其中一个方程求另一个未知数的值。二元二次方程组解题方法：  消元法：通过将其中一个方程中的某个未知数表示成另一个未知数的函数，再代入另一个方程中消去一个未知数，从而得到一个只包含一个未知数的二次方程，再通过求解这个二次方程得到其中一个未知数的值，再代入其中一个方程求另一个未知数的值。  用公式法：如果方程组的形式符合二元二次方程组的标准形式，即 x²+bx+c=0 和 y²+dy+e=0，可以使用求解二次方程的公式求解。  画图法：将两个方程所表示的直线和圆在平面直角坐标系中画出来，其交点即为方程组的解"
  },
  
  {
    "title": "Math Formula",
    "url": "/posts/2-formula/",
    "categories": "Cc, Math",
    "tags": "Math",
    "date": "2023-05-18 12:02:54 +0800",
    





    
    "snippet": "初中公式      求和公式：$\\sum_{i=1}^n i$ 表示将 $1$ 到 $n$ 之间的所有自然数相加。        平方根公式：$\\sqrt{2} + \\sqrt{3}$ 表示求 $\\sqrt{2}$ 和 $\\sqrt{3}$ 的和。        二次方程求根公式：$x = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}$ 是解二次方程 $ax^2 + bx...",
    "content": "初中公式      求和公式：$\\sum_{i=1}^n i$ 表示将 $1$ 到 $n$ 之间的所有自然数相加。        平方根公式：$\\sqrt{2} + \\sqrt{3}$ 表示求 $\\sqrt{2}$ 和 $\\sqrt{3}$ 的和。        二次方程求根公式：$x = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}$ 是解二次方程 $ax^2 + bx + c =0 $ 的公式，其中 $a=2, b=-5, c=3$。        三角函数：$\\sin\\frac{\\pi}{6}, \\cos\\frac{\\pi}{3}, \\tan\\frac{\\pi}{4}$ 分别表示 $30^\\circ$ 角的正弦、$60^\\circ$ 角的余弦和 $45^\\circ$ 角的正切值。        相似三角形：已知两个相似三角形，第一个三角形中对应边长为 $AB=2$，$BC=3$，$AC=4$，求第二个三角形中对应边长。    解：设第二个三角形中对应边长为 $DE=x, EF=y, DF=z$，则有：$\\frac{x}{2}=\\frac{y}{3}=\\frac{z}{4}$。因为两个三角形相似，所以它们的对应角度相等，因此有：$\\angle B = \\angle E, \\angle C = \\angle F$。由于三角形内角和为 $180^\\circ$，因此有：$\\angle A = \\angle D$。因此可以使用正弦定理或余弦定理求解出第二个三角形中对应边长的值。        勾股定理：已知一个直角三角形，其中一条直角边长为 $3$，斜边长为 $5$，求另一条直角边长的长度。    解：设另一条直角边长为 $x$，则根据勾股定理有：$x^2 + 3^2 = 5^2$。解得 $x=4$。        余弦定理：已知一个三角形，其三个角度分别为 $30^\\circ, 60^\\circ, 90^\\circ$，其中直角边长为 $1$，求斜边长的长度。    解：设斜边长为 $c$，则根据余弦定理有：$c^2 = 1^2 + (\\sqrt{3})^2 - 2 \\times 1 \\times \\sqrt{3} \\times \\cos 60^\\circ$。化简得：$c=\\sqrt{4}=2$。        正弦定理：已知一个三角形，其中两个角度分别为 $30^\\circ$ 和 $45^\\circ$，对应边长分别为 $2$ 和 $x$，求第三条边长的长度。    解：根据正弦定理有：$\\frac{x}{\\sin 105^\\circ} = \\frac{2}{\\sin 45^\\circ}$，解得 $x=2 \\sqrt{3}$。        数列通项公式：已知等差数列 $1, 5, 9, 13, \\ldots$，求第 $100$ 项的值。    解：设第 $100$ 项为 $a_{100}$，则有：$a_{100} = a_1 + (100-1)d = 1 + 99 \\times 4 = 397$。  高中公式  指数和幂          $x^n$ 表示$x$的$n$次方      $x^{-n}$ 表示$x$的倒数的$n$次方      $x^{\\frac{1}{n}}$ 表示$x$的$n$次方根            代数式          二次方程求解公式：$x = \\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$，其中$a,b,c$为实数且$a\\neq 0$。              因式分解公式：\\[(a+b)^2=a^2+2ab+b^2\\]\\[(a-b)^2=a^2-2ab+b^2\\]\\[a^2-b^2=(a+b)(a-b)\\]\\[a^3+b^3=(a+b)(a^2-ab+b^2)\\]\\[a^3-b^3=(a-b)(a^2+ab+b^2)\\]            等比数列通项公式：$a_n = a_1q^{n-1}$，其中$a_1$为首项，$q$为公比。            几何          同余三角形定理：若$\\triangle ABC\\cong \\triangle A’B’C’$，则有$AB\\cong A’B’$，$BC\\cong B’C’$，$CA\\cong C’A’$。      相似三角形定理：若$\\triangle ABC\\sim \\triangle A’B’C’$，则有$\\frac{AB}{A’B’}=\\frac{BC}{B’C’}=\\frac{CA}{C’A’}$。      圆的面积公式：$S=\\pi r^2$，其中$r$为半径。      圆的周长公式：$C=2\\pi r$，其中$r$为半径。            三角函数          正弦定理：$\\frac{a}{\\sin A}=\\frac{b}{\\sin B}=\\frac{c}{\\sin C}=2R$，其中$R$为三角形外接圆半径。      余弦定理：$a^2=b^2+c^2-2bc\\cos A$（同理可得$b^2$和$c^2$的表达式）。      勾股定理：$a^2+b^2=c^2$，其中$c$为斜边长。            解析几何                  坐标公式：                  两点间距离公式：$d=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$          点到直线距离公式：$d=\\frac{|Ax+By+C|}{\\sqrt{A^2+B^2}}$                    直线解析式：$y=kx+b$，其中$k$为斜率，$b$为截距。      圆的解析式：$(x-a)^2+(y-b)^2=r^2$，其中$(a,b)$为圆心坐标，$r$为半径。            极限          $\\lim_{x \\to a} f(x)$ 表示当$x$无限接近$a$时，$f(x)$的极限值      "
  },
  
  {
    "title": "Math Readme",
    "url": "/posts/1-math/",
    "categories": "Cc, Math",
    "tags": "Math",
    "date": "2023-05-18 12:01:54 +0800",
    





    
    "snippet": "数学简介数学是一门研究数量、结构、变化以及空间的学科。它是一种基础性的科学，包括许多分支领域，例如代数、几何、数论、概率论和统计学等等。数学的起源可以追溯到古代文明，如埃及、巴比伦和希腊。数学的目标是通过逻辑推理和精确的符号表示来理解和探究各种现象和问题，从而提供解决问题的方法和工具。数学不仅在科学和技术领域中得到广泛应用，也被广泛地运用于社会科学领域。除了实际应用，数学还有自身的纯粹美和哲...",
    "content": "数学简介数学是一门研究数量、结构、变化以及空间的学科。它是一种基础性的科学，包括许多分支领域，例如代数、几何、数论、概率论和统计学等等。数学的起源可以追溯到古代文明，如埃及、巴比伦和希腊。数学的目标是通过逻辑推理和精确的符号表示来理解和探究各种现象和问题，从而提供解决问题的方法和工具。数学不仅在科学和技术领域中得到广泛应用，也被广泛地运用于社会科学领域。除了实际应用，数学还有自身的纯粹美和哲学意义。许多数学家认为，数学是一种抽象的艺术形式，以其深刻的思想和美丽的结构而闻名。数学学习规划      明确学习目标：在开始学习数学之前，需要明确自己的学习目标。你是想要打牢基础，还是准备深入研究高级数学概念？你希望将数学应用到哪些领域中去？        制定计划和时间表：制定一个详细的学习计划和时间表，并按时执行它。让自己保持每天或每周固定的学习时间，这样可以帮助你建立良好的学习习惯。        掌握基础知识：学习数学，必须先掌握基本概念和定义，例如整数、分数、小数、代数表达式等等。建议从基础开始系统地学习数学。        阅读教材和鸟瞰图：找到适合你的教材和鸟瞰图，了解各种数学概念和技巧。        做练习题：通过做练习题来加深对数学概念的理解。选择适合自己难度的题目，坚持练习，并及时检查错题，弥补自己的不足。        参加数学课程和研讨会：参加数学课程和研讨会，与其他数学爱好者交流，并找到可以共同探讨数学问题的人。        扩展阅读：了解数学在实际中的应用，例如金融、工程、物理、生物等领域，并且可以通过阅读相关材料扩展您的知识面。  Other  确定目标：首先确定您希望在数学方面取得什么样的成就。这个目标应该是明确和具体的，例如：想要通过一项考试、学好高中数学、在职场上需要掌握数学技能等等。  制定计划：根据您的目标，制定一个具体的学习计划。您可以根据自己的时间和能力制定计划。可以考虑以下因素：          学习时间：确定每周可用于学习的时间，并在此基础上规划每天的学习时间。      学习内容：根据目标和自己的水平，选择相应的数学领域进行学习。可以考虑从基础知识开始，逐步深入。      学习方法：选择适合自己的学习方法，例如：自学、听课、参加培训等等。可以尝试不同的方法，选择最适合自己的方法。        学习执行：按照学习计划执行。建议将学习内容分成小块，每天逐步完成。同时，可以适当地加入一些练习和实践，帮助自己加深理解和掌握知识。  监测进展：每周或每月检查一次自己的学习进展。看看自己是否按计划进行学习，是否需要对计划进行调整。同时可以评估一下自己的学习效果，看看是否达到了预期目标。  持续学习：数学是一个不断深入和发展的领域。即使您已经掌握了某些知识，也需要继续学习和跟进最新的进展。因此，持续学习是非常重要的。"
  },
  
  {
    "title": "Life Math",
    "url": "/posts/life-math/",
    "categories": "Cc, Math",
    "tags": "Math",
    "date": "2023-05-18 12:00:54 +0800",
    





    
    "snippet": "百分比  $ 值 = 最小值 + (百分比 ×(最大值 − 最小值)) $          “值” 是你要计算的百分比值      “最小值” 是范围内的最小值（1000000000）      “百分比” 是你想计算的百分比（百分之 80，表示为 0.80）      “最大值” 是范围内的最大值（2500000000）        例子          $ 值 = 10000000...",
    "content": "百分比  $ 值 = 最小值 + (百分比 ×(最大值 − 最小值)) $          “值” 是你要计算的百分比值      “最小值” 是范围内的最小值（1000000000）      “百分比” 是你想计算的百分比（百分之 80，表示为 0.80）      “最大值” 是范围内的最大值（2500000000）        例子          $ 值 = 1000000000+(0.80×(2500000000−1000000000)) $      $ 值 = 1000000000+(0.80×1500000000) $      $ 值 = 1000000000+1200000000=2200000000 $      所以，在这个范围内的百分之 80 的值是 2200000000      求区间\\[百分比 = \\frac{给定值−最小值}{最大值−最小值} * 100%\\]      例子          假设你有一个数值范围，最小值为 10，最大值为 50，而你想计算值 30 在这个范围内的百分比\\(百分比 = \\frac{30−10}{50−10} *100 = \\frac{20}{40}*100 = 50%\\)            这个公式可以用于确定一个值在某个范围内的相对位置  "
  },
  
  {
    "title": "Math 国内教育",
    "url": "/posts/education/",
    "categories": "Cc, Math",
    "tags": "Math",
    "date": "2023-05-18 12:00:54 +0800",
    





    
    "snippet": "小学一年级数学：  数字 0-10 的认识和比较  简单的加减法  几何形状的认识，如正方形、三角形、圆形等  时间和日历的基本概念二年级数学：  数字 0-100 的认识和比较  简单的加减法，进一步学习加减法口诀  二维图形的认识，如长方形、正方形、三角形、圆形等  一些简单的度量单位，如长度、重量、容积等三年级数学：  数字 0-1000 的认识和比较  加减法的巩固和进一步学习乘法和...",
    "content": "小学一年级数学：  数字 0-10 的认识和比较  简单的加减法  几何形状的认识，如正方形、三角形、圆形等  时间和日历的基本概念二年级数学：  数字 0-100 的认识和比较  简单的加减法，进一步学习加减法口诀  二维图形的认识，如长方形、正方形、三角形、圆形等  一些简单的度量单位，如长度、重量、容积等三年级数学：  数字 0-1000 的认识和比较  加减法的巩固和进一步学习乘法和除法  掌握一些简单的分数和小数的概念  手表的读取和日历的计算  面积和周长的概念四年级数学：  大数的认识和比较  加减法、乘法和除法的深入学习  掌握一些基本的几何知识，如平移、旋转、镜像等  了解一些简单的代数概念和符号  体积和容积的概念五年级数学：  数字的认识和比较，包括整数、分数和小数  加减法、乘法和除法的深入学习和练习  一些简单的几何证明，如等边三角形的性质等  学习一些简单的统计方法，如图表的制作和分析  比例和百分数的概念六年级数学：  数字的认识和比较，包括整数、分数和小数  加减法、乘法和除法的深入学习和练习，学习算式的变形  掌握一些初步的代数知识，如未知数的概念和简单方程的解法  学习一些初步的几何知识，如平面直角坐标系和简单的三角函数  数据的分析和应用，如平均数、中位数和众数的计算等。初中七年级数学：  数系，包括自然数、整数、有理数、实数和复数等的认识和比较  代数式的认识和计算  等比数列和等差数列的概念和运算  平面图形的认识和性质，如正多边形、相似、全等等  空间几何的初步认识，如立体图形的计算和展开八年级数学：  代数式的深入学习和运算，如多项式、分式等  二次根式的认识和计算  线性方程组和一元二次方程的解法  三角形的基本概念和计算，如正弦、余弦、正切等  平面向量的认识和计算九年级数学：  平面向量和空间向量的深入学习和计算  三角函数的概念和运算，如正弦定理、余弦定理等  指数和对数的概念和运算  解析几何的基本知识和计算，如直线、圆等的方程和性质  概率和统计的初步认识和应用，如基本概率公式、随机事件等高中  高一数学：          函数的概念和运算，如函数的图像、性质、反函数等      极限和连续的初步认识和应用      导数的概念和计算，如导数的性质、应用等      不等式的基本性质和解法      三角函数和三角恒等式的深入学习和应用        高二数学：          微积分的深入学习和应用，如函数的导数和微分、不定积分、定积分等      平面向量和空间向量的深入学习和应用，如向量的数量积、叉积、平面和直线的方程等      解析几何的深入学习和应用，如平面直角坐标系、空间直角坐标系、圆锥曲线等      概率和统计的深入学习和应用，如离散型随机变量、连续型随机变量、正态分布等        高三数学：          复数的深入学习和应用，如复数的概念、运算、初等函数、解析式等      常微分方程的基本概念和求解方法，如一阶常微分方程、高阶常微分方程等      矩阵和行列式的概念和计算，如矩阵的基本运算、逆矩阵、行列式的性质等      数学建模的基本方法和应用，如模型建立、模型求解、模型分析等      "
  },
  
  {
    "title": "kubectl 基础命令",
    "url": "/posts/Kubernetes/",
    "categories": "DevOps, Command",
    "tags": "LinuxTool, Shell, Docker",
    "date": "2023-05-10 14:43:01 +0800",
    





    
    "snippet": "kubectl简介  kubectl 是 Kubernetes 命令行工具，用于与 Kubernetes 集群进行交互和管理。  它可以用来部署应用程序，管理集群资源（例如 Pod、Service 和 ReplicaSet 等），  诊断和调试问题，以及执行其他与 Kubernetes 相关的任务。通过 kubectl，您可以在命令行界面中执行所有 Kubernetes API操作，并对集群...",
    "content": "kubectl简介  kubectl 是 Kubernetes 命令行工具，用于与 Kubernetes 集群进行交互和管理。  它可以用来部署应用程序，管理集群资源（例如 Pod、Service 和 ReplicaSet 等），  诊断和调试问题，以及执行其他与 Kubernetes 相关的任务。通过 kubectl，您可以在命令行界面中执行所有 Kubernetes API操作，并对集群的状态进行操作。  kubectl 是使用 Go 语言编写的开源软件，在安装了 Kubernetes 的任何机器上均可使用。基础命令好的，为了更加详细地回答您的问题，以下是一些 kubectl 的基础命令及其用法：      获取集群信息：    # 查看 Kubernetes 集群信息kubectl cluster-info# 查看节点列表kubectl get nodes            获取资源对象信息：    # 获取 Pod 列表kubectl get pods# 获取 Service 列表kubectl get services# 获取 Deployment 列表kubectl get deployments# 获取 ReplicaSet 列表kubectl get replicasets            创建、更新和删除资源对象：    # 通过 YAML 文件创建资源对象kubectl create -f &lt;YAML_FILE&gt;# 更新资源对象kubectl apply -f &lt;YAML_FILE&gt;# 删除资源对象kubectl delete -f &lt;YAML_FILE&gt;            查看资源对象的详细信息：    # 查看 Pod 详细信息kubectl describe pod &lt;POD_NAME&gt;# 查看 Service 详细信息kubectl describe service &lt;SERVICE_NAME&gt;# 查看 Deployment 详细信息kubectl describe deployment &lt;DEPLOYMENT_NAME&gt;# 查看 ReplicaSet 详细信息kubectl describe replicaset &lt;REPLICASET_NAME&gt;            查看 Pod 日志：    kubectl logs &lt;POD_NAME&gt;            进入 Pod 中的容器：    kubectl exec -it &lt;POD_NAME&gt; bash            扩容和缩容应用程序：    # 扩容 Deployment 的副本数kubectl scale --replicas=&lt;REPLICA_COUNT&gt; deployment/&lt;DEPLOYMENT_NAME&gt;# 缩容 Deployment 的副本数kubectl scale --replicas=&lt;REPLICA_COUNT&gt; deployment/&lt;DEPLOYMENT_NAME&gt;            滚动升级应用程序：    # 开始滚动升级kubectl set image deployment/&lt;DEPLOYMENT_NAME&gt; &lt;CONTAINER_NAME&gt;=&lt;NEW_IMAGE&gt;:&lt;TAG&gt;# 查看滚动升级状态kubectl rollout status deployment/&lt;DEPLOYMENT_NAME&gt;# 回滚到先前的版本kubectl rollout undo deployment/&lt;DEPLOYMENT_NAME&gt;      高级命令好的，以下是一些更加高级的 kubectl 命令及其用法：      使用 kubectl port-forward 命令将本地端口绑定到 Pod 端口：    kubectl port-forward &lt;POD_NAME&gt; &lt;LOCAL_PORT&gt;:&lt;REMOTE_PORT&gt;        该命令会将本地端口 &lt;LOCAL_PORT&gt; 绑定到远程 Pod 的端口 &lt;REMOTE_PORT&gt;。例如，要将本地端口 8080 绑定到名为 my-pod 的Pod 中的端口 80，可以使用以下命令：    kubectl port-forward my-pod 8080:80            使用 kubectl cp 命令在容器和本地文件系统之间复制文件：    kubectl cp &lt;POD_NAME&gt;:&lt;CONTAINER_PATH&gt; &lt;LOCAL_PATH&gt;kubectl cp &lt;LOCAL_PATH&gt; &lt;POD_NAME&gt;:&lt;CONTAINER_PATH&gt;        该命令可以将文件从本地文件系统复制到运行中的容器中，或者将文件从容器中复制到本地文件系统中。例如，要将名为 my-pod的容器中的 /app/logs 目录复制到本地文件系统中的 /tmp 目录，可以使用以下命令：    kubectl cp my-pod:/app/logs /tmp            使用 kubectl top 命令查看节点和 Pod 的 CPU 和内存使用情况：    # 查看节点的 CPU 和内存使用情况kubectl top node# 查看 Pod 的 CPU 和内存使用情况kubectl top pod            使用 kubectl proxy 命令在 Kubernetes API 服务器和本地之间建立代理：    kubectl proxy        该命令会在本地启动一个代理，将 Kubernetes API 服务器和本地连接起来。通过访问 http://localhost:8001，您可以访问Kubernetes API，并查看集群状态、部署资源等。  "
  },
  
  {
    "title": "docker-compose 基础命令",
    "url": "/posts/docker-compose/",
    "categories": "DevOps, Command",
    "tags": "LinuxTool, Shell, Docker",
    "date": "2023-05-10 14:42:01 +0800",
    





    
    "snippet": "docker-compose说明Docker Compose 是 Docker 官方提供的一种用于管理容器化应用程序的工具，它可以通过编写一个 YAML 文件来定义和配置多个 Docker 容器的运行方式和相互关系，然后使用 docker-compose 命令来启动、停止、构建、重启、删除等操作。使用 Docker Compose 的主要优点是可以轻松地处理多个 Docker 容器之间的依赖...",
    "content": "docker-compose说明Docker Compose 是 Docker 官方提供的一种用于管理容器化应用程序的工具，它可以通过编写一个 YAML 文件来定义和配置多个 Docker 容器的运行方式和相互关系，然后使用 docker-compose 命令来启动、停止、构建、重启、删除等操作。使用 Docker Compose 的主要优点是可以轻松地处理多个 Docker 容器之间的依赖关系，并在一个命令下启动全部或部分容器。同时，Docker Compose 还支持在不同的环境中运行相同的服务，比如本地测试和生产环境。Docker Compose 使用 YAML 文件来定义多个服务和相关的配置，这些服务可以在一个命令下启动或停止，也可以指定服务之间的依赖关系。下面是一个简单的 Docker Compose YAML 文件示例：version: \"3\"services:  web:    build: .    ports:      - \"5000:5000\"  redis:    image: \"redis:alpine\"以上文件定义了两个服务：web 和 redis。其中，web 服务需要在当前目录下构建一个 Docker 镜像，并将主机的 5000 端口映射到容器内的 5000 端口；而 redis 服务则直接使用 Redis 官方提供的镜像。通过 Docker Compose，你可以轻松地启动这两个服务，只需在命令行中输入 docker-compose up 即可。Docker Compose 还提供了很多其他的命令和参数，可以帮助你更好地管理容器化应用程序。基本命令以下是一些常用的 Docker Compose 命令：      docker-compose up: 启动容器。如果需要后台运行，可以添加 -d 参数。        docker-compose down: 停止并删除所有在 docker-compose.yaml 文件中定义的服务、网络和容器。        docker-compose ps: 列出正在运行的服务和容器的状态。        docker-compose logs: 查看指定服务的日志信息。        docker-compose build: 构建或重新构建指定的服务或整个应用程序。        docker-compose run: 在新的容器中运行一个指定的服务，并可以附加其他参数。        docker-compose start: 启动停止的服务。        docker-compose stop: 停止正在运行的服务。        docker-compose restart: 重启正在运行的服务。  高级命令      docker-compose config: 检查 docker-compose.yml 文件的语法，并输出配置文件中所有服务的合并配置。        docker-compose kill: 停止指定服务容器，可以使用 -s 参数来指定停止信号，默认为 SIGKILL。        docker-compose pause: 暂停指定服务容器。        docker-compose unpause: 取消暂停指定服务容器。        docker-compose rm: 删除已经停止运行的容器。        docker-compose pull: 从 Docker 镜像仓库拉取最新版本的镜像。        docker-compose push: 将构建好的本地镜像推送到 Docker 镜像仓库。        docker-compose scale: 手动缩放服务的容器实例数量。例如，docker-compose scale web=3 将会将 web 服务的容器实例数量扩大到 3 个。  例子好的，以下是一个简单的示例，用来说明如何使用 docker-compose 命令：假设你有一个 Web 应用程序，需要使用 Nginx 作为反向代理服务器和 PHP-FPM 作为应用程序服务器。首先，你需要在项目根目录下创建一个名为 docker-compose.yml 的文件，并输入以下内容：version: '3'services:  nginx:    image: nginx    ports:      - \"80:80\"    volumes:      - ./nginx.conf:/etc/nginx/nginx.conf    depends_on:      - php-fpm  php-fpm:    build: .    volumes:      - .:/usr/share/nginx/html这个文件定义了两个服务：Nginx 和 PHP-FPM。其中，Nginx 使用官方的 Nginx 镜像，将容器内的 80 端口映射到主机的 80 端口，并挂载当前目录下的 nginx.conf 文件作为 Nginx 的配置文件。PHP-FPM 使用 Dockerfile 中的配置构建镜像，将当前目录下的文件挂载到容器中的 /usr/share/nginx/html 目录中。接下来，你可以使用以下命令启动和停止这个应用程序：# 启动应用程序docker-compose up -d# 停止并删除所有容器和网络docker-compose down以上是一个简单的 docker-compose 示例，通过编辑 docker-compose.yml 文件来配置多个服务的参数，再通过命令行工具来启动、停止和管理这些服务，可以方便快捷地构建和管理 Docker 应用程序。"
  },
  
  {
    "title": "Docker 基础命令",
    "url": "/posts/cmd-docker/",
    "categories": "DevOps, Command",
    "tags": "LinuxTool, Shell, Docker",
    "date": "2023-05-09 12:09:01 +0800",
    





    
    "snippet": "DockerDocker 基本使用  docker run: 运行一个容器这是启动 Docker 容器最基本的命令。它会从指定的镜像创建一个新的容器，并在其中运行指定的命令。例如：docker run ubuntu /bin/bash这将使用 ubuntu 镜像创建一个新的容器，并在其中启动 bash shell。  docker ps: 列出当前正在运行的容器此命令列出所有正在运行的 Do...",
    "content": "DockerDocker 基本使用  docker run: 运行一个容器这是启动 Docker 容器最基本的命令。它会从指定的镜像创建一个新的容器，并在其中运行指定的命令。例如：docker run ubuntu /bin/bash这将使用 ubuntu 镜像创建一个新的容器，并在其中启动 bash shell。  docker ps: 列出当前正在运行的容器此命令列出所有正在运行的 Docker 容器。例如：docker ps可以使用 -a 选项来列出所有容器，包括已停止的容器。  docker stop: 停止一个或多个正在运行的容器此命令用于停止一个或多个正在运行的容器。例如：docker stop &lt;container-id&gt;其中 &lt;container-id&gt; 是要停止的容器 ID。  docker rm: 删除一个或多个容器此命令用于删除一个或多个容器。例如：docker rm &lt;container-id&gt;其中 &lt;container-id&gt; 是要删除的容器 ID。  docker images: 列出所有本地镜像此命令列出本地 Docker 主机上的所有镜像。例如：docker images  docker pull: 从 Docker 镜像仓库中拉取镜像此命令用于从 Docker 镜像仓库中获取镜像。例如：docker pull ubuntu这将获取最新的 ubuntu 镜像。  docker push: 将本地镜像推送到 Docker 镜像仓库中此命令用于将本地镜像推送到 Docker 镜像仓库中。例如：docker push my-image其中 my-image 是要推送到仓库中的镜像名称。  docker build: 使用 Dockerfile 构建一个新的镜像此命令用于使用 Dockerfile 创建一个新的镜像。例如：docker build -t my-image .这将在当前目录中查找名为 Dockerfile 的文件，并使用它来构建名为 my-image 的新镜像。  docker exec: 在正在运行的容器中执行命令此命令可以在正在运行的容器中执行任意命令。例如：docker exec &lt;container-id&gt; ls其中 &lt;container-id&gt; 是要执行命令的容器 ID，ls 是要执行的命令。  docker network: 管理 Docker 网络此命令用于管理 Docker 网络。例如：docker network create my-network这将创建一个名为 my-network 的新网络。您可以使用其他命令向该网络添加容器等。希望这些示例能够帮助您更好地了解 Docker 命令的用途docker 问题排查以下是一些常见的 Docker 管理和排查问题命令：  docker ps: 列出当前正在运行的容器此命令可用于查看当前正在运行的 Docker 容器。  docker logs &lt;container-id&gt;: 查看容器的日志输出此命令可用于查看容器的日志输出，以帮助您诊断问题。使用 &lt;container-id&gt; 替换要查看其日志的容器的 ID。  docker images: 列出本地镜像此命令可用于列出所有在本地 Docker 主机上可用的镜像。  docker inspect &lt;container-id&gt;: 获取有关容器的详细信息此命令可用于获取有关特定容器的详细信息，包括 IP 地址、端口映射等。  docker stop &lt;container-id&gt;: 停止正在运行的容器此命令可用于停止正在运行的 Docker 容器。使用 &lt;container-id&gt; 替换要停止的容器的 ID。  docker rm &lt;container-id&gt;: 删除容器此命令可用于删除指定的 Docker 容器。使用 &lt;container-id&gt; 替换要删除的容器的 ID。  docker exec -it &lt;container-id&gt; /bin/bash: 进入正在运行的容器并打开 shell此命令可用于进入正在运行的 Docker 容器并打开 shell。使用 -it 选项启动交互式会话。使用 &lt;container-id&gt; 替换要进入的容器的 ID。  docker build -t &lt;image-name&gt; .: 使用 Dockerfile 构建一个新的镜像此命令可用于使用 Dockerfile 构建新的 Docker 镜像，并为其指定名称。使用 -t 选项指定镜像名称。  docker network create &lt;network-name&gt;: 创建一个新的 Docker 网络此命令可用于创建一个新的 Docker 网络，以在该网络中运行容器。高级命令      docker stats: 显示所有正在运行的容器的 CPU、内存和网络使用情况。        docker network: 用于管理 Docker 网络，包括创建、删除、连接和断开连接等操作。        docker volume: 用于管理 Docker 卷，包括创建、删除、挂载和卸载等操作。        docker top: 显示一个或多个容器的进程列表。        docker attach: 连接到正在运行的容器，并输入命令或查看控制台输出。        docker exec: 在正在运行的容器中执行命令。与 docker attach 不同，docker exec 不会连接到容器的标准输入和标准输出。        docker commit: 将容器保存为新的镜像。        docker export: 导出容器的文件系统内容为 tar 文件。        docker import: 从 tar 文件导入内容创建镜像。  docker 使用例子以下是一些使用 Docker 命令的示例：  docker images: 列出所有可用的本地镜像。$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              latest              4c108a37151f        6 days ago          72.7MBnginx               latest              bd3d43637225        2 weeks ago         133MBmysql               latest              978e8745d1f9        2 weeks ago         542MB  docker ps: 列出所有正在运行的容器。$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES8b64c3da13b2        nginx               \"nginx -g 'daemon of…\"   2 hours ago         Up 2 hours          80/tcp              my-nginx-container56b8cfaae72d        mysql               \"docker-entrypoint.s…\"   3 hours ago         Up 3 hours          3306/tcp            my-mysql-container  docker stop &lt;container-id&gt;: 停止正在运行的容器。$ docker stop 8b64c3da13b2  docker rm &lt;container-id&gt;: 删除已停止的容器。$ docker rm 8b64c3da13b2  docker restart &lt;container-id&gt;: 重启正在运行的容器。$ docker restart 56b8cfaae72d  docker start &lt;container-id&gt;: 启动已停止的容器。$ docker start 56b8cfaae72d  docker rmi &lt;image-name&gt;: 删除本地的镜像。$ docker rmi mysql  docker logs &lt;container-id&gt;: 查看容器的日志输出。$ docker logs 56b8cfaae72d  docker login: 登录到 Docker Hub。$ docker login  docker tag &lt;old-image-name&gt; &lt;new-image-name&gt;:&lt;tag&gt;: 创建一个新的标记为 &lt;new-image-name&gt;:&lt;tag&gt; 的镜像。$ docker tag my-nginx-container my-docker-registry.com/my-nginx-container:v1.0.0  docker push &lt;new-image-name&gt;:&lt;tag&gt;: 将镜像推送到 Docker 镜像仓库。 $ docker push my-docker-registry.com/my-nginx-container:v1.0.0  docker pull &lt;image-name&gt;:&lt;tag&gt;: 从 Docker 镜像仓库中拉取镜像。$ docker pull my-docker-registry.com/my-nginx-container:v1.0.0这些是一些使用 Docker 命令的示例。根据您的需求，可能需要添加其他选项和参数来定制每个命令的行为。"
  },
  
  {
    "title": "API测试工具",
    "url": "/posts/testing-base/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2023-05-09 09:05:01 +0800",
    





    
    "snippet": "API 压力测试以下是常用的 API 压力测试工具：      Apache JMeter：JMeter 是一个开源的 Java 应用程序，可以用于负载测试、性能测试和压力测试。它支持多种协议，包括 HTTP, FTP, JDBC 等。        Gatling：Gatling 是一个基于 Scala 的开源负载测试工具，可以用于 Web、WebSocket 和 JMS 测试。它提供了可...",
    "content": "API 压力测试以下是常用的 API 压力测试工具：      Apache JMeter：JMeter 是一个开源的 Java 应用程序，可以用于负载测试、性能测试和压力测试。它支持多种协议，包括 HTTP, FTP, JDBC 等。        Gatling：Gatling 是一个基于 Scala 的开源负载测试工具，可以用于 Web、WebSocket 和 JMS 测试。它提供了可扩展的 DSL 来编写测试脚本，并且可以生成详细的报告。        LoadRunner：LoadRunner 是一款商业软件，被广泛用于企业级应用的负载测试。它可以模拟高并发用户访问，并提供实时分析和监控功能。        Artillery：Artillery 是一个基于 Node.js 的开源负载测试工具，可以用于测试 WebSockets、HTTP、UDP 等各种类型的应用程序。它提供了简单的 YAML 配置文件来定义测试场景，还有可视化分析结果。        Tsung：Tsung 是一个开源的 Erlang 工具，可以模拟大量用户对 Web 应用程序进行测试。它使用 XML 描述文件来定义测试场景，并且提供了实时监控和统计信息。        Locust：Locust 是一个开源的 Python 负载测试工具，主要用于测试 Web 应用程序。它可以通过 Python 脚本定义测试场景，并且提供了实时监控和统计信息。        k6：k6 是一个开源的负载测试工具，支持 HTTP、WebSocket 等协议。它使用 JavaScript 编写测试脚本，提供了实时监控和统计信息。  这些 API 压力测试工具都有自己的特点和优势，使用时需要根据具体要求进行选择。API 测试API 测试工具有很多，以下是一些常用的 API 测试工具：      Postman：Postman 是一个基于 Chrome 浏览器的 API 测试工具，它可以发送 HTTP 请求以及查看和管理响应。        SoapUI：SoapUI 是市场上最广泛使用的开源 API 测试工具之一，它支持 Web 服务、REST API、SOAP API 等不同类型的 API 测试。        Swagger：Swagger 是一个流行的 API 文档工具，它还包括一个 API 测试工具，可以通过 Swagger UI 测试 API。        JMeter：JMeter 是一个功能强大的 Java 应用程序，它可以进行负载测试、性能测试、压力测试等各种类型的 API 测试。        Rest-Assured：Rest-Assured 是一个基于 Java 的库，专门用于编写 REST API 测试。        Karate：Karate 也是一个 Java 库，它提供了一种新的领域特定语言来编写 API 测试脚本。        HTTPie：HTTPie 是一个类似于 cURL 的命令行工具，可以发送 HTTP 请求并显示响应。  这些工具都有自己的优缺点，选择合适的 API 测试工具需要考虑到项目需求、团队技术能力以及可用的资源等因素。PostmanPostman 是一款广泛使用的 API 测试工具，它可以用来测试 RESTful API、SOAP API 等。下面是一些关于 Postman 的详细解释和常用教程。  Postman 基本介绍Postman 是一款跨平台的 API 测试工具，支持 Windows、Mac、Linux 等操作系统。它提供了一个可视化的界面，使得用户可以轻松地创建、发送和调试 HTTP 请求，并查看响应结果。除此之外，Postman 还提供了许多高级功能，如自动化测试、断言、环境变量等。      安装 Postman你可以通过以下步骤安装 Postman：          前往官网 https://www.postman.com/downloads/      下载适合你的操作系统版本。      运行下载好的安装文件，按照提示进行安装。            发送第一个请求在安装完成后，你可以尝试通过以下步骤发送第一个请求：          打开 Postman      在左上角的输入框中输入请求 URL      选择请求方法（GET、POST 等）      点击”Send”按钮发送请求      查看响应结果            使用环境变量当你需要在不同的环境中测试 API 时，通常需要修改请求的 URL 或参数。为了方便管理，你可以使用 Postman 的环境变量功能。环境变量是一种可重复使用的值，可以在所有请求中引用。你可以按照以下步骤创建和使用环境变量：          在 Postman 左上角点击”Manage Environments”按钮      点击”Add”按钮创建一个新的环境，输入环境名称和变量名      输入变量的值，保存环境设置      在请求中使用环境变量，格式为            自动化测试除了手动发送请求之外，Postman 还支持自动化测试。你可以创建测试脚本，来验证响应是否符合预期。测试脚本通常基于 JavaScript 编写，Postman 提供了一些内置的函数和对象，使得编写测试脚本变得更加容易。你可以按照以下步骤创建自动化测试：          打开一个请求，并在”Tests”选项卡中编写测试脚本      使用内置的函数和对象对响应结果进行断言      点击”Send”按钮发送请求，并等待测试结果            导出和分享当你需要与团队成员或他人共享请求时，你可以将请求导出为文件并分享给他们。Postman 支持将请求导出为多种格式，如 JSON、YAML、CSV 等。你可以按照以下步骤导出请求：          打开一个请求，并在顶部菜单栏中选择”Export”      选择导出的格式，并输入导出的文件名      点击”Save”按钮导出请求以上是 Postman 的一些常用教程，希望能对你有所帮助。      SoapUISoapUI 是一款功能强大的 API 测试工具，主要用于测试 Web 服务、REST API 和 SOAP API 等。下面是一些关于 SoapUI 的详细解释和常用教程。  SoapUI 基本介绍SoapUI 是一款跨平台的 API 测试工具，支持 Windows、Mac、Linux 等操作系统。它提供了一个可视化的界面，使得用户可以轻松地创建、发送和调试 HTTP 请求，并查看响应结果。除此之外，SoapUI 还提供了许多高级功能，如自动化测试、断言、数据驱动测试等。  安装 SoapUI你可以通过以下步骤安装 SoapUI：  前往官网 https://www.soapui.org/downloads/latest-release.html  下载适合你的操作系统版本。  运行下载好的安装文件，按照提示进行安装。  发送第一个请求在安装完成后，你可以尝试通过以下步骤发送第一个请求：  打开 SoapUI  创建一个新的项目并添加一个测试套件  在测试套件中添加一个测试用例  在测试用例中添加一个测试步骤  选择请求方法（GET、POST 等）、输入请求 URL 和参数  点击”Send Request”按钮发送请求  查看响应结果  使用数据驱动测试当你需要测试多个相似的场景时，手动创建测试用例会非常麻烦。为了方便管理，你可以使用 SoapUI 的数据驱动测试功能。数据驱动测试是一种自动化测试方法，它通过分析数据来执行不同的测试流程。你可以按照以下步骤创建和使用数据驱动测试：  在测试套件中添加一个数据源  添加要测试的数据行，并为每一行输入不同的参数  将数据源与测试用例关联，使得测试用例将使用数据源中的数据  在测试用例中使用数据源中的数据，替换请求 URL 和参数  自动化测试除了手动发送请求之外，SoapUI 还支持自动化测试。你可以创建 Groovy 脚本，来验证响应是否符合预期。Groovy 是一种基于 Java 语言的脚本语言，SoapUI 使用 Groovy 作为其测试脚本语言。你可以按照以下步骤创建自动化测试：  打开一个请求，并在”Assertions”选项卡中编写测试脚本  使用 Groovy 语言对响应结果进行断言  点击”Run Test”按钮发送请求，并等待测试结果  导出和分享当你需要与团队成员或他人共享请求时，你可以将请求导出为文件并分享给他们。SoapUI 支持将请求导出为多种格式，如 XML、JSON、HTML 等。你可以按照以下步骤导出请求：  打开一个请求，并在顶部菜单栏中选择”Export”  选择导出的格式，并输入导出的文件名  点击”Save”按钮导出请求以上是 SoapUI 的一些常用教程，希望能对你有所帮助。JMeterJMeter 是一款广泛使用的性能测试工具，主要用于测试 Web 应用程序、API 和数据库等。下面是一些关于 JMeter 的详细解释和常用教程。  JMeter 基本介绍JMeter 是一个功能强大的开源性能测试工具，它支持多种协议，如 HTTP、FTP、SMTP、JMS 等。JMeter 提供了可视化的用户界面，使得用户可以轻松地创建、发送和调试请求，并查看响应结果。除此之外，JMeter 还提供了许多高级功能，如线程组管理、断言、监控等。  安装 JMeter你可以通过以下步骤安装 JMeter：  前往官网 https://jmeter.apache.org/download_jmeter.cgi  下载最新版本的 JMeter 二进制文件  解压下载好的文件到本地文件夹  运行 bin/jmeter.bat 或者 bin/jmeter.sh 启动 JMeter  发送第一个请求在安装完成后，你可以尝试通过以下步骤发送第一个请求：  打开 JMeter  创建一个新的测试计划并添加一个线程组  在线程组中添加一个 HTTP 请求  输入请求 URL 和参数  点击”运行”按钮发送请求  查看响应结果  使用断言当你需要验证响应是否符合预期时，可以使用 JMeter 的断言功能。断言是一种功能，可以验证请求的响应是否符合预期。JMeter 提供了多种内置的断言类型，如响应代码、响应消息、响应时间等。你可以按照以下步骤创建和使用断言：  在 HTTP 请求中选择”响应断言”选项卡  选择一个断言类型，并输入断言值  点击”运行”按钮发送请求，并等待测试结果  使用线程组当你需要模拟多个用户同时访问 API 时，可以使用 JMeter 的线程组功能。线程组是一种模拟并发用户的机制。你可以按照以下步骤创建和使用线程组：  在测试计划中添加一个线程组  设置线程组的并发级别和线程数  在线程组中添加 HTTP 请求，模拟并发访问  监控测试结果在测试执行完毕后，你可以使用 JMeter 的监控功能来分析测试结果。JMeter 提供了多种监控器类型，如聚合报告、图形结果、响应时间分布等。你可以按照以下步骤使用监控器：  在测试计划中添加一个监控器  运行测试，并查看监控器输出结果以上是 JMeter 的一些常用教程，希望能对你有所帮助。"
  },
  
  {
    "title": "Vim 使用说明",
    "url": "/posts/vim/",
    "categories": "DevOps, Shell",
    "tags": "LinuxTool, Shell",
    "date": "2023-05-08 12:07:01 +0800",
    





    
    "snippet": "vimVim(Vi IMproved) 是一个高级的文本编辑器，是 Unix 和类 Unix 系统中最受欢迎的编辑器之一。它可以处理多种文件类型，包括纯文本、代码等，并且支持多种操作模式和自定义配置，可以提高编辑效率。Vim 的一些基本概念和使用方法  操作模式：Vim 有三种操作模式，分别是命令模式（Command mode）、插入模式（Insert mode）和视觉模式（Visual m...",
    "content": "vimVim(Vi IMproved) 是一个高级的文本编辑器，是 Unix 和类 Unix 系统中最受欢迎的编辑器之一。它可以处理多种文件类型，包括纯文本、代码等，并且支持多种操作模式和自定义配置，可以提高编辑效率。Vim 的一些基本概念和使用方法  操作模式：Vim 有三种操作模式，分别是命令模式（Command mode）、插入模式（Insert mode）和视觉模式（Visual mode）。命令模式用于执行命令、移动光标等操作；插入模式用于输入文本；视觉模式用于选择文本。  命令：在命令模式下，可以使用各种命令进行操作，如移动光标、删除文本、复制粘贴等。常用命令包括 h/j/k/l 分别表示左/下/上/右方向键；i/a/o 分别表示插入、在光标后插入、在行尾插入；dd 表示删除整行；yy 表示复制整行；p 表示将复制的内容粘贴到当前位置。  配置文件：Vim 使用 .vimrc 文件来存储用户自定义设置和插件配置。可以通过修改该文件来实现自定义配置，如设置显示行号、设置缩进等。  插件：Vim 支持多种插件，可以通过安装插件来扩展其功能。一些常用的插件包括 NERDTree（文件浏览器）、vim-airline（状态栏增强）、YouCompleteMe（自动补全）等。Vim 的一些使用方法  打开文件：使用 vim 命令加上要打开的文件名称即可打开，如 vim test.txt。  切换模式：在命令模式下按下 i/a/o 进入插入模式，在插入模式下按下 Esc 进入命令模式，在命令模式下按下 v 进入视觉模式。  保存文件：在命令模式下按下 :w 即可保存文件，若要保存并退出可以按下 :wq。  查找和替换：在命令模式下按下 / 进入查找模式，输入要查找的内容后按下 Enter；在命令模式下按下 :s/old/new/g 进行替换，其中 old 表示要被替换的文本，new 表示替换成的文本，g 表示全局匹配。  多窗口操作：在命令模式下按下 :sp 可以在当前窗口中水平分割一个新窗口，按下 :vsp 可以在当前窗口中垂直分割一个新窗口，使用 Ctrl+w 进行窗口切换。以上是 Vim 的一些基本概念和使用方法。需要注意的是，由于 Vim 具有较高的学习曲线，初学者可能需要花费一些时间来适应其操作方式。vim 常用快捷键以下是 Vim 中一些常用的快捷键：  i：进入插入模式  Esc：退出插入模式，回到命令模式  :wq：保存并退出文件  :q：退出文件  :q!：强制退出文件不保存  yy：复制当前行  p：粘贴上一次复制的文本  dd：删除当前行  /：查找文本  n：继续查找下一个匹配项  u：撤销上一步操作  Ctrl + r：重做上一步撤销的操作  :%s/old/new/g：全局替换文本中所有旧字符串为新字符串"
  },
  
  {
    "title": "Linux awk 基础命令",
    "url": "/posts/linux_awk/",
    "categories": "DevOps, Command",
    "tags": "Tools",
    "date": "2023-05-08 12:06:01 +0800",
    





    
    "snippet": "awkawk 是一种用于处理文本数据的命令行工具，它可以用来从文件或者管道中读取数据，并对其进行格式化、转换、过滤和计算等操作。下面是一个简单的 awk 命令使用指南：1. 基础语法awk [options] 'pattern { action }' file(s)其中，pattern 表示匹配模式，action 表示要执行的动作。如果没有指定 pattern，则默认匹配所有行。file(s...",
    "content": "awkawk 是一种用于处理文本数据的命令行工具，它可以用来从文件或者管道中读取数据，并对其进行格式化、转换、过滤和计算等操作。下面是一个简单的 awk 命令使用指南：1. 基础语法awk [options] 'pattern { action }' file(s)其中，pattern 表示匹配模式，action 表示要执行的动作。如果没有指定 pattern，则默认匹配所有行。file(s) 表示输入文件名，可以指定多个文件。2. 使用变量awk 中有一些内置变量，可以用于获取当前正在处理的行或者列的信息。例如：  $0 表示整个行内容；  $1 表示第一个字段（以空格分隔）；  $NF 表示最后一个字段；  NR 表示当前行号；  NF 表示当前行的字段数。在 awk 中，可以使用这些变量来进行行或者列的处理和计算。3. 常用操作以下是 awk 常用的操作：  打印行：awk '{print}' file.txt  按条件过滤行：awk '/pattern/ {print}' file.txt  格式化输出：awk '{printf \"%s %s\\n\", $1, $2}' file.txt  计算行数：awk 'END {print NR}' file.txt  计算平均值：awk '{sum+=$1; count++} END {print sum/count}' file.txt  按分隔符处理：awk -F',' '{print $1, $NF}' file.txt4. 常用选项以下是 awk 常用的一些选项：  -F&lt;separator&gt; 指定分隔符；  -v var=value 定义变量；  -f script.awk 指定脚本文件。例如，可以使用以下命令从 CSV 文件中提取第一列和最后一列：awk -F ',' '{print $1, $NF}' file.csv也可以将选项和脚本组合起来使用，例如：awk -F ',' -v threshold=90 '{if ($3 &gt; threshold) print $0}' file.csv这个命令会读取 file.csv 文件，并根据逗号分隔符解析每一行数据。然后根据变量 threshold 进行过滤，如果第三列的值大于 threshold，则输出整行数据。"
  },
  
  {
    "title": "Linux 基础命令",
    "url": "/posts/base_cmd/",
    "categories": "DevOps, Shell",
    "tags": "LinuxTool, Shell",
    "date": "2023-05-08 12:05:01 +0800",
    





    
    "snippet": "Linux 基础命令Linux 是一种典型的 Unix 类操作系统，基于命令行操作，以下是一些常用的 Linux 基础命令：  ls：列出目录内容  cd：切换目录  mkdir：创建新目录  rm：删除文件或目录  cp：复制文件或目录  mv：移动文件或目录  touch：创建新文件  cat：连接、显示文件内容  grep：文本搜索工具  ping：测试网络连接  ifconfig：查...",
    "content": "Linux 基础命令Linux 是一种典型的 Unix 类操作系统，基于命令行操作，以下是一些常用的 Linux 基础命令：  ls：列出目录内容  cd：切换目录  mkdir：创建新目录  rm：删除文件或目录  cp：复制文件或目录  mv：移动文件或目录  touch：创建新文件  cat：连接、显示文件内容  grep：文本搜索工具  ping：测试网络连接  ifconfig：查看和配置网络接口状态  top：实时显示进程状态  ps：列出当前系统进程  kill：结束某个进程  tar：打包或解压缩文件以上只是常用命令的部分，还有很多其他的 Linux 命令可以使用。ls 列出目录内容“ls” 是一个常用的命令，用于显示当前工作目录中的文件和子目录列表。以下是 “ls” 命令的详细解释：  格式：ls [选项] [文件/目录]  选项：ls 命令支持许多选项，其中一些最常用的选项包括：          -l：以长格式列表方式显示文件和目录（包括权限、拥有者、大小、修改时间等信息）      -a：显示所有文件和目录，包括隐藏文件和目录      -h：人性化地显示文件和目录大小，例如使用 MB、GB 等单位      -r：反向排序输出结果      -t：按时间排序输出结果，最新的文件或目录将排在前面        文件/目录：可以指定一个或多个文件或目录来进行查看，如果不指定，则默认为当前工作目录。举个例子，如果要查看当前工作目录下的所有文件和目录，可以输入 “ls” 命令，在命令行界面上会列出所有文件和子目录的名称。如果要查看详细的信息，可以输入 “ls -l” 命令，会列出每个文件和目录的权限、拥有者、大小、修改时间等信息。cd 切换目录“cd” 命令用于更改当前工作目录。以下是 “cd” 命令的详解：  格式：cd [目录路径]  目录路径：要切换到的目录路径，可以是绝对路径或相对路径。如果不指定目录路径，则默认更改为当前用户的主目录。举个例子，如果当前工作目录为 “/home/user1/Documents”，如果要切换到该用户的主目录 “/home/user1”，可以输入 “cd” 命令或 “cd ~” 命令；如果要切换到 “/home/user1/Desktop” 目录，可以输入 “cd Desktop” 或 “cd /home/user1/Desktop” 命令。此外，还有一些特殊符号可以在 “cd” 命令中使用来快速导航：  . ：代表当前目录，例如 “cd .” 命令不会进行任何操作。  .. ：代表上级目录，例如 “cd ..” 命令可以将当前目录切换到其父目录。  - ：代表上一个工作目录，例如 “cd -“ 命令可以切换回之前的工作目录。需要注意的是，如果指定的目录不存在或没有访问权限，”cd” 命令将会失败并输出错误信息。因此，在使用 “cd” 命令时需要确保目录存在并且有正确的访问权限。mkdir 创建新目录“mkdir” 命令用于创建新的目录。以下是 “mkdir” 命令的详解：  格式：mkdir [选项] 目录名  选项：mkdir 命令支持许多选项，其中一些最常用的选项包括：          -p：递归地创建目录和子目录，例如可以使用 “mkdir -p dir1/dir2/dir3” 一次性创建多级目录。      -m：指定新创建目录的权限，例如可以使用 “mkdir -m 755 dirname” 创建新目录并将其权限设置为 755。        目录名：要创建的目录名称。举个例子，如果想在当前工作目录下创建一个名为 “test” 的新目录，可以输入 “mkdir test” 命令。如果想要一次性创建多级目录，可以使用 “mkdir -p dir1/dir2/dir3” 命令来创建名为 “dir1/dir2/dir3” 的目录树。如果需要指定新目录的权限，则可以使用 “mkdir -m 755 dirname” 命令，并将目录权限设置为 755。需要注意的是，如果目录已经存在，”mkdir” 命令将会失败并输出错误信息。因此，在使用 “mkdir” 命令时需要确保目录不存在或者使用 “-p” 选项递归创建目录。rm 删除文件或目录“rm” 命令用于删除文件或目录。以下是 “rm” 命令的详解：  格式：rm [选项] 文件/目录  选项：rm 命令支持许多选项，其中一些最常用的选项包括：          -f：强制删除文件或目录，不提示确认。      -r：递归删除目录及其子目录和文件。      -i：交互式删除，删除每个文件或目录前都会提示确认。        文件/目录：要删除的文件或目录名称。举个例子，如果要删除当前工作目录下名为 “test.txt” 的文件，可以输入 “rm test.txt” 命令。如果要删除一个目录及其所有子目录和文件，可以使用 “rm -r dirname” 命令，注意需要谨慎操作以避免误删重要数据。如果需要在删除前进行确认，可以使用 “-i” 选项，例如 “rm -i filename” 命令会在删除文件前提示确认。需要注意的是，删除文件或目录时需要确保有足够的权限，并且慎重考虑是否真的需要删除它们，因为一旦删除将无法恢复。在使用 “rm” 命令时建议先进行备份并且谨慎操作。cp 复制文件或目录“cp” 命令用于复制文件或目录。以下是 “cp” 命令的详解：  格式：cp [选项] 源文件/目录 目标文件/目录  选项：cp 命令支持许多选项，其中一些最常用的选项包括：          -r：递归复制目录及其子目录和文件。      -i：交互式复制，复制每个文件或目录前都会提示确认。      -p：保留源文件或目录的权限、所有权和时间戳等信息。        源文件/目录：要复制的源文件或目录名称。  目标文件/目录：要将源文件或目录复制到的目标位置。举个例子，如果要将当前工作目录下名为 “test.txt” 的文件复制到 /home/user1/ 目录中，可以输入 “cp test.txt /home/user1/” 命令。如果要复制一个目录及其所有子目录和文件，可以使用 “cp -r sourcedir destdir” 命令。如果需要在复制前进行确认，可以使用 “-i” 选项，例如 “cp -i filename /path/to/destination/” 命令会在复制文件前提示确认。如果需要保留源文件或目录的权限和所有权等信息，可以使用 “-p” 选项，例如 “cp -rp sourcedir destdir” 命令会递归复制目录并保留其所有权、权限和时间戳等信息。需要注意的是，在复制目录时，需要使用 “-r” 选项递归复制子目录和文件，并确保复制到的目标位置具有足够的权限。在使用 “cp” 命令时建议谨慎操作以避免误操作。mv 移动文件或目录“mv” 命令用于移动或重命名文件或目录。以下是 “mv” 命令的详解：  格式：mv [选项] 源文件/目录 目标文件/目录  选项：mv 命令支持许多选项，其中一些最常用的选项包括：          -i：交互式移动或重命名，移动或重命名每个文件或目录前都会提示确认。      -f：强制移动或重命名，不提示确认。        源文件/目录：要移动或重命名的源文件或目录名称。  目标文件/目录：要将源文件或目录移动到的目标位置，或者要将源文件或目录重命名为的新名称。举个例子，如果要将当前工作目录下名为 “test.txt” 的文件移动到 /home/user1/ 目录中，可以输入 “mv test.txt /home/user1/” 命令。如果要将一个目录及其所有子目录和文件移动到另一个位置，可以使用 “mv sourcedir destdir” 命令。如果需要将文件或目录重命名，可以将目标位置指定为新名称，例如 “mv oldname newname” 命令将文件或目录 “oldname” 重命名为 “newname”。需要注意的是，在移动或重命名文件或目录时，需要确保源文件或目录存在，并且目标位置具有足够的权限。在使用 “mv” 命令时建议谨慎操作以避免误操作，并且不要将文件移动到其他程序正在使用的目录中以避免出现意外错误。touch 创建新文件“touch” 命令用于创建新文件或更新已有文件的修改时间。以下是 “touch” 命令的详解：  格式：touch [选项] 文件  选项：touch 命令支持许多选项，其中一些最常用的选项包括：          -a：只更改文件的访问时间。      -m：只更改文件的修改时间。      -c：只在文件不存在时才创建该文件。      -t：指定要设置的时间戳，格式为 [[CC]YY]MMDDhhmm[.SS]        文件：要创建或更新时间戳的文件名称。举个例子，如果要在当前工作目录下创建一个名为 “test.txt” 的空文件，可以输入 “touch test.txt” 命令。如果要更新已有文件的修改时间，可以使用 “touch filename” 命令。如果需要只更改文件的访问时间或修改时间，可以使用 “-a” 或 “-m” 选项，例如 “touch -a filename” 命令只更改文件的访问时间。如果希望只在文件不存在时才创建该文件，则可以使用 “-c” 选项，例如 “touch -c filename” 命令。如果需要指定要设置的时间戳，则可以使用 “-t” 选项，例如 “touch -t 202201011200.00 filename” 命令将文件的时间戳设置为 2022 年 1 月 1 日 12:00。需要注意的是，在使用 “touch” 命令时，如果指定的文件不存在，则会创建一个空文件。在更新时间戳时，需要确保具有足够的权限，并且谨慎操作以避免误操作。cat 连接、显示文件内容“cat” 命令用于显示文件内容或将多个文件合并成一个文件。以下是 “cat” 命令的详解：  格式：cat [选项] 文件  选项：cat 命令支持许多选项，其中一些最常用的选项包括：          -n：在输出文件的每一行前插入行号。      -b：在输出文件的非空行前插入行号。      -s：压缩连续空白行为一行。      -A：显示特殊字符（如文本中的制表符和换行符）。        文件：要显示内容或合并的文件名称。举个例子，如果要查看当前工作目录下名为 “test.txt” 的文件内容，可以输入 “cat test.txt” 命令。如果要合并两个文件 “file1” 和 “file2” 并将结果写入新文件 “output” 中，可以使用 “cat file1 file2 &gt; output” 命令。如果需要在输出文件的每一行前插入行号，则可以使用 “-n” 选项，例如 “cat -n filename” 命令会输出带行号的文件内容。如果需要将连续空白行压缩成一行，则可以使用 “-s” 选项，例如 “cat -s filename” 命令会输出压缩后的文件内容。需要注意的是，在显示文件之前，需要确保已经具有足够的权限来访问文件。在合并文件时，需要确保所有要合并的文件存在，并且目标文件没有被保护或已经存在，以避免数据丢失。grep 文本搜索工具grep 命令是一种文本搜索工具，常用于从文件中查找某个特定的字符串或者正则表达式，并且可以显示匹配行的内容。以下是 grep 命令的基本语法：grep [options] pattern [file]其中，pattern 为要匹配的模式，可以是一个字符串或者一个正则表达式；file 则为要搜索的文件名。下面是常用的一些选项：  -i: 忽略大小写。  -v: 显示不匹配的行。  -n: 显示匹配行的行号。  -l: 只显示包含匹配项的文件名。  -c: 统计匹配行的数量。  -r: 在目录及其子目录下递归搜索。例如，以下命令将在文件 example.txt 中搜索所有包含字符串 “hello” 的行：grep \"hello\" example.txt如果要忽略大小写，可以使用 -i 选项：grep -i \"hello\" example.txt如果要显示匹配行的行号，可以使用 -n 选项：grep -n \"hello\" example.txt如果要递归搜索目录 mydir 下的所有文件，可以使用 -r 选项：grep -r \"hello\" mydir/以上是 grep 命令的一些基本用法和选项。更多信息可以参考 grep 的帮助文档。ping 测试网络连接ping 命令用于检查网络连接是否正常，可以测试与目标主机之间的连通性和网络延迟。它发送一个 ICMP ECHO 请求消息到指定的目的地，并等待接收一个 ICMP ECHO 响应消息。以下是 ping 命令的基本语法：ping [options] target其中，target 可以是 IP 地址或者域名，表示需要对这个地址进行 ping 测试。下面是一些常用的选项：  -c count: 指定要发送的 ICMP 请求消息的次数。  -i interval: 指定发送 ICMP 请求消息的时间间隔（以秒为单位）。  -s size: 指定每个 ICMP 请求消息的数据包大小（默认为 56 字节）。  -t ttl: 指定 ICMP 数据报中的 Time To Live 值（默认为 64）。  -w deadline: 指定等待响应的最大时间（以秒为单位）。例如，以下命令将向 IP 地址为 192.168.1.1 发送 5 个 ICMP 请求消息：ping -c 5 192.168.1.1如果想要持续 ping 一个主机，可以使用 -t 选项：ping -t google.com以上是 ping 命令的一些基本用法和选项。更多信息可以参考 ping 的帮助文档。ifconfig 查看和配置网络接口状态ifconfig（interface configuration）命令是用于配置和显示网络接口信息的工具。它可以列出当前系统中所有的网络接口，包括以太网、无线网络、回环接口等，并且可以查看和修改这些接口的 IP 地址、子网掩码、MAC 地址等配置信息。以下是 ifconfig 命令的基本语法：ifconfig [options] [interface]其中，interface 表示要操作的网络接口的名称，如果省略则默认显示所有接口的信息。下面是一些常用的选项：  -a: 显示所有接口的信息，包括未激活的接口。  up: 启动指定的接口。  down: 关闭指定的接口。  inet addr: 指定 IPv4 地址。  netmask mask: 指定子网掩码。  hw ether MAC: 指定 MAC 地址。例如，以下命令将显示所有网络接口的信息：ifconfig -a如果想要启动一个被禁止的网络接口（如 eth0），可以使用以下命令：ifconfig eth0 up如果想要修改一个接口的 IP 地址和子网掩码，可以使用以下命令：ifconfig eth0 inet 192.168.1.10 netmask 255.255.255.0以上是 ifconfig 命令的一些基本用法和选项。需要注意的是，ifconfig 命令已经被新的 ip 命令取代，因此在一些新的 Linux 发行版中可能已经不再支持 ifconfig 命令。top 实时显示进程状态top 命令用于实时监控系统的进程和资源使用情况，可以查看哪些进程占用了 CPU 时间、内存、虚拟内存等系统资源，并且可以按照不同的指标进行排序。以下是 top 命令的基本语法：top运行该命令后，会显示当前系统中所有进程的信息，按照 CPU 占用率进行排序，上方的几行显示了系统的总体信息，包括系统负载、运行进程数、CPU 使用情况、内存使用情况等。下面的每一行显示了一个具体的进程的信息，包括进程 ID、占用 CPU 的百分比、内存占用量、进程所属用户等。下面是一些常用的交互命令：  q: 退出 top 命令。  k: 结束某个进程，需要输入要终止的进程 ID。  f: 显示或隐藏需要显示的字段，可以选择要显示的列，如 PID、CPU、MEM 等。  r: 修改某个进程的优先级，需要输入要修改的进程 ID 和新的优先级值。例如，以下命令将启动 top 命令并按照内存占用率进行排序：top -o %MEM如果想要显示更多的进程信息，可以使用 f 命令选择要显示的字段：top -o %CPU以上是 top 命令的一些基本用法和选项。需要注意的是，top 命令只能在交互式命令行环境下使用，如果需要在脚本中监控系统进程和资源使用情况，可以考虑使用其他工具，如 ps 命令等。ps 列出当前系统进程ps 命令用于列出当前系统中运行的进程信息，可以查看进程 ID、进程名称、占用 CPU 时间、内存等资源的情况，并且可以按照不同的指标进行排序。以下是 ps 命令的基本语法：ps [options]默认情况下，ps 命令只会显示当前用户自己运行的进程信息。如果需要查看所有进程的信息，需要使用 -e 或者 -A 选项。例如，以下命令将列出当前系统中所有进程的信息并按照进程 ID 排序：ps -eo pid,ppid,cmd,%cpu,%mem --sort=-pid其中，-e 选项表示要显示所有进程的信息，-o 选项指定要显示的字段，--sort 选项指定排序方式。上述命令将显示 PID、父进程 ID、进程名、CPU 使用率、内存使用率等信息，并按照进程 ID 从大到小进行排序。下面是一些常用的选项：  -e: 显示所有进程的信息。  -A: 显示所有进程的信息，与 -e 选项类似。  -f: 显示完整的进程信息，包括进程的 UID、GID、PPID 等。  -u username: 显示指定用户的进程信息。  -p pidlist: 显示指定 PID 列表对应的进程信息。例如，以下命令将显示当前用户运行的所有进程：ps -u $USER如果想要查看某个进程的详细信息，可以使用 -f 选项：ps -ef | grep nginx以上是 ps 命令的一些基本用法和选项。需要注意的是，在不同的操作系统中，ps 命令的参数和输出格式可能有所不同。kill 结束某个进程kill 命令用于终止指定进程或者发送信号给指定进程。可以使用 ps 命令查找要终止的进程的 PID，然后使用 kill 命令向该进程发送终止信号。以下是 kill 命令的基本语法：kill [options] pid ...其中，pid 表示要终止的进程的 PID。多个 PID 可以用空格分隔。如果在命令行中不指定任何选项，则默认向进程发送 SIGTERM 信号，让其正常退出。下面是一些常用的选项：  -l: 列出所有可用的信号名称。  -9: 强制终止进程，使用 SIGKILL 信号。  -s signal: 指定要发送的信号类型（使用信号名称或数字）。例如，以下命令将向进程编号为 12345 发送 SIGTERM 信号，让其正常退出：kill 12345如果想要强制终止某个进程，可以使用 -9 选项：kill -9 12345如果想要发送其他类型的信号，可以使用 -s 选项，如向进程 12345 发送 SIGUSR1 信号：kill -s SIGUSR1 12345以上是 kill 命令的一些基本用法和选项。需要注意的是，强制终止进程可能会导致数据丢失或者出现其他问题，应该尽量避免使用 -9 选项。tar 打包或解压缩文件tar(tape archive)命令用于在 Linux 中创建和解压归档文件，可以将多个文件或目录打包成一个文件，并且可以使用不同的压缩算法进行压缩。 tar 命令经常用于备份数据以及在多台服务器之间传输文件。以下是 tar 命令的基本语法：tar [options] [archive_name] [files/dirs]其中，archive_name 表示要创建的归档文件的名称，files/dirs 则表示要添加到归档文件中的文件或目录列表。如果没有指定归档文件名称，则默认会将归档文件输出到标准输出。如果同时指定了归档文件名称和文件列表，则 tar 命令将把这些文件添加到归档文件中。下面是一些常用的选项：  -c: 创建新的归档文件。  -x: 从归档文件中提取文件。  -v: 显示详细信息，包括要添加或提取的文件列表。  -f file: 指定归档文件的名称。  -z: 对归档文件进行 gzip 压缩。  -j: 对归档文件进行 bzip2 压缩。  -C dir: 指定要操作的目录。例如，以下命令将创建名为 myarchive.tar 的归档文件，并将目录 mydir 中的所有文件添加到该归档文件中：tar -cvf myarchive.tar mydir/如果想要将归档文件解压到当前目录下，可以使用以下命令：tar -xvf myarchive.tar如果想要将归档文件进行 bzip2 压缩，并且指定要操作的目录为 /home，可以使用以下命令：tar -cjvf home.tar.bz2 -C / home/以上是 tar 命令的一些基本用法和选项。需要注意的是，在不同的操作系统中，tar 命令的参数和输出格式可能有所不同。vimVim(Vi IMproved) 是一个高级的文本编辑器，是 Unix 和类 Unix 系统中最受欢迎的编辑器之一。它可以处理多种文件类型，包括纯文本、代码等，并且支持多种操作模式和自定义配置，可以提高编辑效率。以下是 Vim 的一些基本概念和使用方法：  操作模式：Vim 有三种操作模式，分别是命令模式（Command mode）、插入模式（Insert mode）和视觉模式（Visual mode）。命令模式用于执行命令、移动光标等操作；插入模式用于输入文本；视觉模式用于选择文本。  命令：在命令模式下，可以使用各种命令进行操作，如移动光标、删除文本、复制粘贴等。常用命令包括 h/j/k/l 分别表示左/下/上/右方向键；i/a/o 分别表示插入、在光标后插入、在行尾插入；dd 表示删除整行；yy 表示复制整行；p 表示将复制的内容粘贴到当前位置。  配置文件：Vim 使用 .vimrc 文件来存储用户自定义设置和插件配置。可以通过修改该文件来实现自定义配置，如设置显示行号、设置缩进等。  插件：Vim 支持多种插件，可以通过安装插件来扩展其功能。一些常用的插件包括 NERDTree（文件浏览器）、vim-airline（状态栏增强）、YouCompleteMe（自动补全）等。以下是 Vim 的一些使用方法：  打开文件：使用 vim 命令加上要打开的文件名称即可打开，如 vim test.txt。  切换模式：在命令模式下按下 i/a/o 进入插入模式，在插入模式下按下 Esc 进入命令模式，在命令模式下按下 v 进入视觉模式。  保存文件：在命令模式下按下 :w 即可保存文件，若要保存并退出可以按下 :wq。  查找和替换：在命令模式下按下 / 进入查找模式，输入要查找的内容后按下 Enter；在命令模式下按下 :s/old/new/g 进行替换，其中 old 表示要被替换的文本，new 表示替换成的文本，g 表示全局匹配。  多窗口操作：在命令模式下按下 :sp 可以在当前窗口中水平分割一个新窗口，按下 :vsp 可以在当前窗口中垂直分割一个新窗口，使用 Ctrl+w 进行窗口切换。以上是 Vim 的一些基本概念和使用方法。需要注意的是，由于 Vim 具有较高的学习曲线，初学者可能需要花费一些时间来适应其操作方式。"
  },
  
  {
    "title": "自动化脚本",
    "url": "/posts/auto_shell/",
    "categories": "DevOps, Shell",
    "tags": "LinuxTool, Shell",
    "date": "2023-05-05 15:05:01 +0800",
    





    
    "snippet": "自动化脚本备份文件#!/bin/bash# 定义变量backup_dir=\"/path/to/backup\"file_to_backup=\"/path/to/file.txt\"# 创建备份目录mkdir -p \"$backup_dir\"# 备份文件backup_file=\"$backup_dir/$(date +%Y-%m-%d_%H-%M-%S)_file.txt\"cp \"$file_to...",
    "content": "自动化脚本备份文件#!/bin/bash# 定义变量backup_dir=\"/path/to/backup\"file_to_backup=\"/path/to/file.txt\"# 创建备份目录mkdir -p \"$backup_dir\"# 备份文件backup_file=\"$backup_dir/$(date +%Y-%m-%d_%H-%M-%S)_file.txt\"cp \"$file_to_backup\" \"$backup_file\"# 显示备份结果if [ -e \"$backup_file\" ]then    echo \"File backup succeeded: $backup_file\"else    echo \"File backup failed.\"fi#!/bin/bash# 定义备份目录和目标服务器地址backup_dir=\"/data/backup\"target_server=\"user@target-server:/backup\"# 备份 Web 服务器文件web_dir=\"/var/www/html\"rsync -avz --delete $web_dir $backup_dir/web# 备份应用程序文件app_dir=\"/opt/myapp\"rsync -avz --delete $app_dir $backup_dir/app# 将备份数据同步到目标服务器rsync -avz --delete $backup_dir $target_server解释这个脚本会在指定的目录中创建一个新的备份文件，并将原始文件复制到该备份文件中。备份文件的文件名包括当前日期和时间，以确保每个备份文件都有唯一的名称。你可以通过修改backup_dir和file_to_backup变量来自定义备份目录和要备份的文件路径。当脚本执行完成时，它将会输出备份结果：如果备份文件成功创建，则显示成功消息及其文件名；否则，显示失败消息。这只是一个基础的备份示例，你可以根据需要对其进行扩展和修改。例如，你可能希望增加一些错误检查或添加日志记录功能。管理服务器Shell 脚本可以用来管理服务器上的自动化任务，例如定时运行脚本、自动化部署应用程序、监控服务状态等。下面是一个简单的 Shell 脚本示例，用于管理定时任务：#!/bin/bash# 添加一个定时任务到 crontab 文件中add_cron_job() {    local command=\"$1\"    local schedule=\"$2\"    # 将定时任务添加到 crontab 文件    (crontab -l ; echo \"$schedule $command\") | crontab -}# 移除 crontab 中指定命令的定时任务remove_cron_job() {    local command=\"$1\"    # 从 crontab 文件中移除指定命令的定时任务    crontab -l | grep -v \"$command\" | crontab -}# 显示当前系统所有定时任务list_cron_jobs() {    crontab -l}# 在每天凌晨 3 点执行 backup.sh 脚本add_cron_job \"/bin/bash /path/to/backup.sh\" \"0 3 * * *\"# 将 backup.sh 脚本从定时任务中移除remove_cron_job \"/bin/bash /path/to/backup.sh\"# 显示当前系统所有定时任务list_cron_jobs在这个脚本中，我们定义了三个函数：add_cron_job、remove_cron_job 和 list_cron_jobs。其中 add_cron_job 函数用于添加一个定时任务到 crontab 文件中，remove_cron_job 函数用于移除 crontab 中指定命令的定时任务，list_cron_jobs 函数用于显示当前系统所有定时任务。在这个脚本中，我们添加了一个定时任务来每天凌晨 3 点执行 backup.sh 脚本。我们还可以使用 remove_cron_job 函数将该定时任务从 crontab 中移除。需要注意的是，在实际使用中，还需要考虑一些其他因素，比如安全性、错误处理等问题，以确保自动化任务的可靠性和安全性。自动化任务 Shell 监控文件系统Shell 脚本可以用来监控文件系统，例如检查磁盘空间、监控日志文件等。下面是一个简单的 Shell 脚本示例，用于监控磁盘空间：#!/bin/bash# 检查磁盘空间使用情况check_disk_space() {    local threshold=90  # 磁盘空间阈值    # 获取当前磁盘空间使用率（取整数部分）    local usage=$(df -h / | awk 'NR==2{print $5}' | sed 's/%//')    if [ \"$usage\" -gt \"$threshold\" ]; then        echo \"磁盘空间使用率超过阈值 ${threshold}%，当前使用率为 ${usage}%\"        return 1    else        echo \"磁盘空间使用率正常，当前使用率为 ${usage}%\"        return 0    fi}# 每隔 10 分钟检查一次磁盘空间while true; do    check_disk_space    sleep 600done在这个脚本中，我们定义了一个函数 check_disk_space，用于检查磁盘空间使用情况，并将使用率与设定的阈值进行比较。如果使用率超过了阈值，则输出警告信息并返回错误码 1；否则输出正常信息并返回成功码 0。然后，在主函数中，我们使用一个 while 循环来每隔 10 分钟调用 check_disk_space 函数来检查磁盘空间使用情况，并通过 sleep 命令实现定时检查。需要注意的是，在实际使用中，还需要考虑一些其他因素，例如日志记录、警报通知等问题，以确保监控程序的可靠性和及时性。docker build and push以下是一个示例脚本，可以实现 Go 程序的 Docker 自动构建并推送到 Docker 仓库：#!/bin/bash# 设置变量IMAGE_NAME=\"your-image-name\"DOCKER_REPO=\"your-docker-repo\"TAG=\"latest\"DOCKERFILE_PATH=\"./Dockerfile\"CONTEXT=\"./\"# 构建镜像docker build -t \"${DOCKER_REPO}/${IMAGE_NAME}:${TAG}\" -f ${DOCKERFILE_PATH} ${CONTEXT}# 推送镜像到 Docker 仓库docker push \"${DOCKER_REPO}/${IMAGE_NAME}:${TAG}\"将以上脚本保存为名为 build-and-push.sh 的文件，在终端中运行此脚本即可自动构建和推送您的 Docker 镜像。请确保在脚本中替换 IMAGE_NAME 和 DOCKER_REPO 变量以反映您的实际情况。"
  },
  
  {
    "title": "C",
    "url": "/posts/c-base-ok/",
    "categories": "Language, C",
    "tags": "Server, C",
    "date": "2023-01-06 09:58:38 +0800",
    





    
    "snippet": "基础知识C 数据类型基础类型数值类型  整形  短整形 short  整形 int  长整型 long  浮点型  单精度 float  双精度 double字符串类型 char构造类型数组结构体 struct共用体 union枚举类型 enum指针类型空类型 void",
    "content": "基础知识C 数据类型基础类型数值类型  整形  短整形 short  整形 int  长整型 long  浮点型  单精度 float  双精度 double字符串类型 char构造类型数组结构体 struct共用体 union枚举类型 enum指针类型空类型 void"
  },
  
  {
    "title": "C Base",
    "url": "/posts/c-base/",
    "categories": "Language, C",
    "tags": "Server, C",
    "date": "2023-01-06 09:58:37 +0800",
    





    
    "snippet": "第一个 C 程序示例#include &lt;stdio.h&gt;int main(){   /* 我的第一个 C 程序 */   printf(\"Hello, World! \\n\");   return 0;}  程序的第一行 #include  是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。  下一行 int main() 是主函数，程序从这里开始执行。 ...",
    "content": "第一个 C 程序示例#include &lt;stdio.h&gt;int main(){   /* 我的第一个 C 程序 */   printf(\"Hello, World! \\n\");   return 0;}  程序的第一行 #include  是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。  下一行 int main() 是主函数，程序从这里开始执行。  下一行 /…/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。  下一行 printf(…) 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。  下一行 return 0; 终止 main() 函数，并返回值 0。编译 执行 Ｃ  打开一个文本编辑器，添加上述代码。  保存文件为 hello.c。  打开命令提示符，进入到保存文件所在的目录。  键入 gcc hello.c，输入回车，编译代码。  如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。  现在，键入 a.out 来执行程序。  您可以看到屏幕上显示 “Hello World”。  gcc hello.c./a.outgcc hello.c -o hello.out[root@iz2zeb00z6vr5gix5utl11z c]# ll-rw-r–r– 1 root root 118 Nov 1 10:56 hello.c-rwxr-xr-x 1 root root 8360 Nov 1 10:58 hello.out基本语法C 的令牌  关键字  标识符  常量  字符串值（或者一个符号）printf(\"Hello, World! \\n\");分号每个语句必须以分号结束，表面一个逻辑实体的结束注释  单行注释// 单行注释代码  多行/*    多行注释代码*/标识符  C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _开始，后跟零个或多个字母、下划线和数字（0-9）  区分大小写  示例有效标识符mohd       zara    abc   move_name  a_123myname50   _temp   j     a23b9      retVal关键字关键字（保留字）不能作为常量名、变量名或其他标识符名称空格空格区分类型  基本类型  枚举  void 类型          函数返回为空      函数为空      指针指向 void        派生类型          指针      数组      结构体      共用体      变量定义#include &lt;stdio.h&gt;// 函数外定义变量 x 和 yint x;int y;int addtwonum(){    // 函数内声明变量 x 和 y 为外部变量    extern int x;    extern int y;    // 给外部变量（全局变量）x 和 y 赋值    x = 1;    y = 2;    return x+y;}int main(){    int result;    // 调用函数 addtwonum    result = addtwonum();    printf(\"result 为: %d\",result);    return 0;}"
  },
  
  {
    "title": "进制 & 转换",
    "url": "/posts/binary/",
    "categories": "Language, C",
    "tags": "Server, C",
    "date": "2023-01-06 09:58:36 +0800",
    





    
    "snippet": "简介  进制（或称数制）是一种数学表示方法，用来描述数字在计算机和其他数字系统中的表示和处理方式。在计算机科学中，常见的进制有二进制、八进制和十六进制。  不同的进制有不同的作用和优缺点。例如，二进制非常适合计算机内部的数字处理，因为它只有两个基本数字 0 和 1，可以通过硬件电路实现高效的加法和乘法运算。而十六进制则更容易阅读和书写，因为它包含了数字和字母，可以更方便地表示较大的数字，同时...",
    "content": "简介  进制（或称数制）是一种数学表示方法，用来描述数字在计算机和其他数字系统中的表示和处理方式。在计算机科学中，常见的进制有二进制、八进制和十六进制。  不同的进制有不同的作用和优缺点。例如，二进制非常适合计算机内部的数字处理，因为它只有两个基本数字 0 和 1，可以通过硬件电路实现高效的加法和乘法运算。而十六进制则更容易阅读和书写，因为它包含了数字和字母，可以更方便地表示较大的数字，同时也更直观地表示二进制数据。  在计算机编程中，不同进制的转换也经常使用到，例如将一个二进制数转换成十进制数，或者将一个十进制数转换成十六进制数等等。总之，进制在计算机科学中扮演着重要的角色，是理解和掌握计算机科学基础知识的重要组成部分。分类  二进制（基数为 2）：由 0 和 1 组成的数字系统。  八进制（基数为 8）：由 0-7 组成的数字系统，使用前缀 0 表示。  十进制（基数为 10）：由 0-9 组成的数字系统，我们平时所使用的数字系统就是十进制。  十六进制（基数为 16）：由 0-9 和 A-F（或 a-f）组成的数字系统，使用前缀 0x 或 0X 表示。计算机中主要用途  二进制（Base-2）：在计算机内部，所有数据都是以二进制形式存储和处理的。二进制的主要用途是表示数字、字符和图像等二进制数据。例如，在计算机内部，使用二进制来表示整型、布尔型、位图和数据流等。  八进制（Base-8）：八进制通常用于表示文件权限标志。在 Unix 系统中，文件的读、写和执行权限可以用三个八进制数来表示，例如 0664 表示文件权限为-rw-rw-r–。  十进制（Base-10）：十进制是我们最为熟悉的数字系统，它通常用于表示时间、日期、货币和其他计量单位。在编程语言中，使用十进制来表示浮点型和高精度计算等。  十六进制（Base-16）：十六进制通常用于表示颜色代码、内存地址、消息摘要等二进制数据。在计算机科学中，十六进制经常用于调试和测试，以便更好地查看和理解二进制数据。之间转换      二进制到八进制/十六进制：          八进制：将二进制数每三位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 8，第三组权值为 64，以此类推。然后将每组得到的权值加起来，即可表示成对应的八进制数。例如，二进制数 110100111 可以分为 011、010、011 和 1 三组，对应的八进制数就是 326。      十六进制：将二进制数每四位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 16，第三组权值为 256，第四组权值为 4096，以此类推。然后将每组得到的权值加起来，即可表示成对应的十六进制数。例如，二进制数 110100111 可以分为 1101 和 0011 和 1 三组，对应的十六进制数就是 0xD3。            八进制到二进制/十六进制：          二进制：将每个八进制数位上的数字分别转换成对应的三位二进制数即可。例如，八进制数 644 转换成二进制数就是 110 100 100。      十六进制：将每个八进制数位上的数字分别转换成对应的四位二进制数，或者将每个八进制数位转换成三位二进制数并连接起来即可得到十六进制数。例如，八进制数 644 转换成十六进制数就是 0x1A4。            十进制到二进制/八进制/十六进制：          二进制：使用除法取余法将十进制数依次除以 2，并将每次得到的余数倒序排列即可得到相应的二进制数。例如，十进制数 255 对应的二进制数就是 11111111。      八进制：使用除法取余法将十进制数依次除以 8，并将每次得到的余数倒序排列即可得到相应的八进制数。例如，十进制数 255 对应的八进制数就是 377。      十六进制：使用除法取余法将十进制数依次除以 16，并将每次得到的余数倒序排列。当余数大于等于 10 时，A-F（或 a-f）代表 10~15，例如 10 对应 A，15 对应 F。最终得到的数值即为相应的十六进制数。例如，十进制数 255 对应的十六进制数就是 0xFF。            十六进制到二进制/八进制/十进制：          二进制：将十六进制数每一位转换为对应的四位二进制数即可。例如，十六进制数 0xAB 对应的二进制数就是 1010 1011。      八进制：将十六进制数每两位转换为对应的三位八进制数并连接起来即可得到相应的八进制数。例如，十六进制数 0xAB 对应的八进制数就是 253。      十进制：将十六进制数每一位分别转换成对应的十进制数，并根据位数从右向左依次相乘得到每个位上的值，最后将所有的值加起来即可得到相应的十进制数。例如，十六进制数 0xAB 对应的十进制数就是 171。      练习      将二进制数 10101010 转换成八进制和十六进制。          八进制：将二进制数每三位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 8，以此类推。得到的每组数值即为对应的八进制数位。10101010 可以分为 1、010 和 101、010 三组，对应的八进制数为 152。      十六进制：将二进制数每四位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 16，以此类推。得到的每组数值即为对应的十六进制数位。10101010 可以分为 1010 和 1010 两组，对应的十六进制数为 0xAA。        所以，10101010 的八进制表示为 152，十六进制表示为 0xAA。        将八进制数 755 转换成二进制和十六进制。          二进制：将每个八进制数位上的数字分别转换成对应的三位二进制数即可。7 变成 111，5 变成 101，5 变成 101。因此，八进制数 755 用二进制表示为 111101101。      十六进制：将每个八进制数位上的数字分别转换成对应的四位二进制数，或者将每个八进制数位转换成三位二进制数并连接起来即可得到十六进制数。7 变成 0111，5 变成 0101，5 变成 0101。因此，八进制数 755 转换为十六进制为 0x375。        所以，755 的二进制表示为 111101101，十六进制表示为 0x375。        将十进制数 128 转换成二进制、八进制和十六进制。          二进制：使用除法取余法将十进制数依次除以 2，并将每次得到的余数倒序排列即可得到相应的二进制数。128 除以 2 得到 64 余 0，64 除以 2 得到 32 余 0，32 除以 2 得到 16 余 0，16 除以 2 得到 8 余 0，8 除以 2 得到 4 余 0，4 除以 2 得到 2 余 0，2 除以 2 得到 1 余 0，1 除以 2 得到 0 余 1。因此，128 用二进制表示为 10000000。      八进制：使用除法取余法将十进制数依次除以 8，并将每次得到的余数倒序排列即可得到相应的八进制数。128 除以 8 得到 16 余 0，16 除以 8 得到 2 余 0，2 除以 8 得到 0 余 2。因此，128 用八进制表示为 200。      十六进制：使用除法取余法将十进制数依次除以 16，并将每次得到的余数倒序排列。当余数大于等于 10 时，A-F 代表 10~15，例如 10 对应 A，15 对应 F。128 除以 16 得到 8 余 0，8 除以 16 得到 0 余 8。因此，128 用十六进制表示为 0x80。        所以，128 的二进制表示为 10000000，八进制表示为 200，十六进制表示为 0x80。        将十六进制数 0x1A 转换成二进制、八进制和十进制。          二进制：将十六进制数每一位转换为对应的四位二进制数即可。1 对应 0001，A 对应 1010。因此，0x1A 用二进制表示为 0001 1010。      八进制：将十六进制数每一位转换为对应的三位二进制数，并将所有二进制数连接起来即可得到相应的八进制数。1 对应 001，A 对应 1010。因此，0x1A 用八进制表示为 032。      十进制：将十六进制数每一位分别转换成对应的十进制数，并根据位数从右向左依次相乘得到每个位上的值，最后将所有的值加起来即可得到相应的十进制数。1×16^1+10×16^0=26。因此，0x1A 用十进制表示为 26。        所以，0x1A 的二进制表示为 0001 1010，八进制表示为 032，十进制表示为 26。        将二进制数 1101010111011111 转换成八进制和十六进制。          八进制：将二进制数每三位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 8，第三组权值为 64，以此类推。得到的每组数值即为对应的八进制数位。1101010111011111 可以分为 011、010、101、110、111 和 1 六组，对应的八进制数为 32567。      十六进制：将二进制数每四位一组分组，从右向左依次为每组加权，第一组权值为 1，第二组权值为 16，第三组权值为 256，第四组权值为 4096，以此类推。得到的每组数值即为对应的十六进制数位。1101010111011111 可以分为 1101、0101、1101 和 1111 三组，对应的十六进制数为 0xD5DF。        所以，1101010111011111 的八进制表示为 32567，十六进制表示为 0xD5DF。        将八进制数 654 转换成二进制和十六进制。          二进制：将每个八进制数位上的数字分别转换成对应的三位二进制数即可。6 变成 110，5 变成 101，4 变成 100。因此，八进制数 654 用二进制表示为 110 101 100。      十六进制：将每个八进制数位上的数字分别转换成对应的四位二进制数，或者将每个八进制数位转换成三位二进制数并连接起来即可得到十六进制数。6 变成 0110，5 变成 0101，4 变成 0100。因此，八进制数 654 转换为十六进制为 0x354。        所以，654 的二进制表示为 110 101 100，十六进制表示为 0x354。        将十进制数 1024 转换成二进制、八进制和十六进制。          二进制：使用除法取余法将十进制数依次除以 2，并将每次得到的余数倒序排列即可得到相应的二进制数。1024 除以 2 得到 512 余 0，512 除以 2 得到 256 余 0，256 除以 2 得到 128 余 0，128 除以 2 得到 64 余 0，64 除以 2 得到 32 余 0，32 除以 2 得到 16 余 0，16 除以 2 得到 8 余 0，8 除以 2 得到 4 余 0，4 除以 2 得到 2 余 0，2 除以 2 得到 1 余 0，1 除以 2 得到 0 余 1。因此，1024 用二进制表示为 10000000000。      八进制：使用除法取余法将十进制数依次除以 8，并将每次得到的余数倒序排列即可得到相应的八进制数。1024 除以 8 得到 128 余 0，128 除以 8 得到 16 余 0，16 除以 8 得到 2 余 0，2 除以 8 得到 0 余 2。因此，1024 用八进制表示为 2000。      十六进制：使用除法取余法将十进制数依次除以 16，并将每次得到的余数倒序排列。当余数大于等于 10 时，A-F 代表 10~15，例如 10 对应 A，15 对应 F。1024 除以 16 得到 64 余 0，64 除以 16 得到 4 余 0，4 除以 16 得到 0 余 4。因此，1024 用十六进制表示为 0x400。        所以，1024 的二进制表示为 10000000000，八进制表示为 2000，十六进制表示为 0x400。        将十六进制数 0xFE 转换成二进制、八进制和十进制。          二进制：将十六进制数每一位转换为对应的四位二进制数即可。F 对应 1111，E 对应 1110。因此，0xFE 用二进制表示为 1111 1110。      八进制：将十六进制数每一位转换成对应的三位二进制数，或者将每个十六进制数位转换成四位二进制数并分为相邻的三位，然后每三位转换成一个八进制数即可。F 对应 111，E 对应 111。因此，0xFE 用八进制表示为 376。      十进制：将十六进制数每一位分别转换成对应的十进制数，并根据位数从右向左依次相乘得到每个位上的值，最后将所有的值加起来即可得到相应的十进制数。F×16^1+E×16^0=15×16+14=254。因此，0xFE 用十进制表示为 254。        所以，0xFE 的二进制表示为 1111 1110，八进制表示为 376，十进制表示为 254。  "
  },
  
  {
    "title": "MongoDB Database",
    "url": "/posts/mongodb-index/",
    "categories": "Dev, Database, MongoDB",
    "tags": "Database, Nosql",
    "date": "2022-09-19 12:21:48 +0800",
    





    
    "snippet": "Mongo Database数据库（Database）在 MongoDB 中是一个顶级容器，用于组织和存储集合（Collections）。每个数据库可以包含多个集合，而每个集合又可以包含多个文档（Documents）。以下是 MongoDB 数据库的详解和一些操作注意事项：数据库的特点      独立性：每个数据库是相互独立的，有自己的权限设置和存储空间。        命名空间：数据库名是...",
    "content": "Mongo Database数据库（Database）在 MongoDB 中是一个顶级容器，用于组织和存储集合（Collections）。每个数据库可以包含多个集合，而每个集合又可以包含多个文档（Documents）。以下是 MongoDB 数据库的详解和一些操作注意事项：数据库的特点      独立性：每个数据库是相互独立的，有自己的权限设置和存储空间。        命名空间：数据库名是大小写敏感的，且不能包含以下字符：/\\. \"$*&lt;&gt;:|?        集合的分组：数据库可以通过集合来组织和存储数据，方便管理和查询。        权限控制：MongoDB 支持对数据库进行权限控制，可以通过用户角色和权限来管理数据库访问。        备份和恢复：MongoDB 提供了备份和恢复数据库的功能，方便进行数据的备份和恢复操作。  操作注意事项      创建数据库：在 MongoDB 中，可以使用 use 命令来创建数据库。例如，要创建一个名为 mydatabase 的数据库，可以执行 use mydatabase。        切换数据库：使用 use 命令可以切换当前操作的数据库。例如，要切换到 mydatabase，可以执行 use mydatabase。        查看当前数据库：可以使用 db 命令查看当前正在使用的数据库。例如，执行 db 命令会显示当前数据库的名称。        查看所有数据库：可以使用 show dbs 命令来查看 MongoDB 中所有的数据库列表。        删除数据库：可以使用 db.dropDatabase() 命令来删除当前数据库。请谨慎执行此操作，删除数据库会同时删除其中的所有集合和文档。        备份和恢复：可以使用 mongodump 和 mongorestore 命令来进行 MongoDB 数据库的备份和恢复操作。        权限管理：MongoDB 支持对数据库进行权限管理，可以使用 db.createUser() 命令创建用户并分配权限，以控制用户对数据库的访问。        性能优化：在设计数据库时，应考虑到数据的结构和索引的设计，以及合理利用 MongoDB 提供的分片和复制等功能来优化性能。        监控和管理：定期监控数据库的性能和运行状态，及时处理异常和优化配置，保证数据库的稳定运行。  连接数据库&gt; 在你提供的命令中，你正在使用 `mongo` 命令连接到 MongoDB，同时提供了用户名、密码和认证数据库信息。让我为你解释一下这个命令的各个部分的含义：      连接数据库          mongo --host hostname --port port --username username --password password --authenticationDatabase admin      mongo --host 172.12.10.189 --port 10005 --username root --password root --authenticationDatabase admin            --host 172.12.10.189: 指定 MongoDB 服务器的主机地址为 172.12.10.189，这是你要连接的 MongoDB 服务器的 IP 地址。        --port 10005: 指定 MongoDB 服务器的端口号为 10005，这是 MongoDB 服务器监听的端口号。        --username root: 指定要使用的用户名为 root，这是要连接到 MongoDB 服务器的用户名。        --password root: 指定要使用的密码为 root，这是与用户名对应的密码。        --authenticationDatabase admin: 指定用于认证的数据库为 admin，这是包含认证用户信息的数据库。  这个命令的执行目的是连接到指定的 MongoDB 服务器，并使用提供的用户名和密码进行身份验证，同时指定认证数据库为 admin。如果提供的用户名和密码正确，连接将成功建立，并进入 mongo shell，允许你执行 MongoDB 相关的操作和查询。  也可以不指定：mongo --host 172.12.10.189 --port 10005 --username root --password root操作数据库  创建的数据库 mydatabase 并不在数据库的列表中， 要显示它，我们需要向 mydatabase 数据库插入一些数据。  远程数据库：mongo --host 172.12.10.189 --port 10005 --username root --password root  创建名为 mydatabase 的数据库：use mydatabase  查看当前数据库：db  查看所有数据库列表：show dbs  插入一条数据：db.mydatabase.insertOne({\"name\":\"Cc\"})  查看所有数据库列表：show dbs  查询版本信息：db.version()  实例的状态信息：db.serverStatus()  实例的内存使用情况：db.runCommand({ serverStatus: 1, mem: 1 })  实例的存储引擎信息：db.runCommand({ engineStatus: 1 })  查看数据库状态：db.stats()"
  },
  
  {
    "title": "MongoDB Base",
    "url": "/posts/mongodb-base-copy/",
    "categories": "Dev, Database, MongoDB",
    "tags": "Database, Nosql",
    "date": "2022-09-18 12:21:48 +0800",
    





    
    "snippet": "Mongo DB 介绍  数据模型：MongoDB 使用 BSON（二进制 JSON）格式来存储数据。BSON 是一种二进制表示形式，类似于 JSON，但支持更多的数据类型，例如日期、二进制数据和特定的地理空间类型。每个文档都有一个唯一的”_id”字段作为主键。  集群和复制：MongoDB 支持分布式部署，可以将数据分布在多个服务器上的集群中。集群提供了高可用性和容错能力，如果某个节点发生...",
    "content": "Mongo DB 介绍  数据模型：MongoDB 使用 BSON（二进制 JSON）格式来存储数据。BSON 是一种二进制表示形式，类似于 JSON，但支持更多的数据类型，例如日期、二进制数据和特定的地理空间类型。每个文档都有一个唯一的”_id”字段作为主键。  集群和复制：MongoDB 支持分布式部署，可以将数据分布在多个服务器上的集群中。集群提供了高可用性和容错能力，如果某个节点发生故障，系统可以自动切换到其他节点。复制是通过将数据复制到多个服务器来实现的，其中一个服务器是主服务器，负责写入操作，其他服务器是备份服务器，用于读取操作和故障恢复。  索引和查询：MongoDB 支持多种类型的索引，包括单字段索引、组合索引、文本索引和地理空间索引等。索引可以大大提高查询性能。MongoDB 的查询语言丰富而强大，支持比较、范围、正则表达式、逻辑操作符等复杂的查询操作。  事务支持：MongoDB 从版本 4.0 开始引入了对多文档事务的支持。事务允许开发人员在多个操作上维护数据的一致性和完整性。通过事务，可以确保多个写操作要么全部成功执行，要么全部回滚，从而保持数据的一致性。  安全性：MongoDB 提供了多种安全性功能来保护数据的机密性和完整性。它支持访问控制、身份验证和角色管理，可以限制用户对数据库的访问权限。此外，MongoDB 还提供了加密通信、字段级加密和审计功能等，以增强数据的安全性。  可视化管理工具：MongoDB 提供了名为 MongoDB Compass 的官方可视化管理工具，用于浏览和操作数据库。它提供了一个直观的界面，可以执行数据查询、创建索引、监视性能和管理集群等任务。  社区支持和生态系统：MongoDB 有一个庞大的活跃社区，提供了广泛的文档、教程和示例代码。此外，还有许多第三方工具和库与 MongoDB 集成，例如 ORM（对象关系映射）工具、数据迁移工具和可视化报表工具等，为开发人员提供了更多的选择和灵活性优劣      优势          灵活的数据模型：MongoDB 使用类似 JSON 的 BSON 格式存储数据，文档模型非常灵活，可以存储不同结构的数据。      高性能：MongoDB 支持水平扩展，能够处理大量的并发请求，具有很高的读写性能。      强大的查询功能：支持丰富的查询操作，包括字段查询、范围查询、正则表达式、全文搜索等。      高可用性：MongoDB 支持主从复制和分片，可以保证数据的高可用性和可靠性。      自动分片：MongoDB 可以根据数据量自动分片，简化了水平扩展的管理            劣势          不支持事务：MongoDB 不支持跨文档的 ACID 事务，对于某些需要强一致性的场景可能不太适用。      内存占用较高：MongoDB 在处理大量数据时需要较大的内存来维护索引和数据结构，会占用较多的系统资源。      学习成本：对于习惯了关系型数据库的开发人员来说，需要一定的学习成本来适应 MongoDB 的文档模型和查询语言      数据库，集合，文档，限制，限制  CN 官方文档  数据库（Database）          MongoDB 可以同时管理多个数据库。每个数据库都有独立的命名空间，用于存储集合和文档。      每个数据库在物理上由一个或多个文件组成，这些文件存储实际的数据和索引。        集合（Collection）          集合是 MongoDB 中的一个逻辑概念，用于组织和存储一组相关的文档。      集合不要求预定义的结构，即不同的文档可以有不同的字段和结构。      集合可以通过数据库对象进行访问，例如 db.collectionName。        文档（Document）          文档是 MongoDB 中存储数据的基本单位，类似于关系数据库中的行。      文档使用 BSON（二进制 JSON）格式表示，是一个有序的键值对集合。      文档可以包含多种类型的数据，如字符串、整数、浮点数、布尔值、数组、嵌套文档等。        限制（Limitations）          单个文档的最大大小为 16MB。如果需要存储更大的数据，可以使用 GridFS 来处理大型文件。      单个集合中的文档数目没有明确的限制，但是在实际使用中，应根据系统资源和查询性能进行适度的控制。      MongoDB 支持的最大数据库数量、集合数量和索引数量都有一定的限制，具体取决于 MongoDB 的版本和配置。      在写操作中，MongoDB 的文档级别的原子性是保证的，但是在 MongoDB 4.0 之前，跨多个文档的事务支持是有限的。MongoDB 4.0 及之后的版本引入了全面的多文档事务支持。      配置文件  MongoDB 的配置文件是一个文本文件，通常命名为 mongodb.conf，它包含了 MongoDB 服务器的各种配置选项。这些选项可以控制 MongoDB 的行为、性能、安全性等方面。下面是一些常见的 MongoDB 配置选项及其解释：      bindIp：          解释：指定 MongoDB 服务器绑定的 IP 地址，用于指定服务器监听的网络接口。默认值为 127.0.0.1，即只监听本地连接。如果要允许来自其他主机的连接，可以将其设置为 0.0.0.0。      示例：bindIp: 0.0.0.0            port：          解释：指定 MongoDB 服务器监听的端口号。默认端口号为 27017。      示例：port: 27017            dbpath：          解释：指定 MongoDB 存储数据文件的路径。在该路径下存放着 MongoDB 数据库文件。      示例：dbpath: /data/db            logpath：          解释：指定 MongoDB 日志文件的路径。MongoDB 会将运行时的日志信息输出到该文件中。      示例：logpath: /var/log/mongodb/mongod.log            logappend：          解释：指定是否在日志文件末尾追加日志信息。如果设置为 true，则新的日志信息将被追加到已有日志文件的末尾；如果设置为 false，则每次启动时都会清空日志文件。      示例：logappend: true            fork：          解释：指定是否以守护进程模式运行 MongoDB。如果设置为 true，则 MongoDB 在启动时会在后台运行；如果设置为 false，则 MongoDB 在启动时会在前台运行。      示例：fork: true            auth：          解释：指定是否启用身份验证功能。如果设置为 true，则 MongoDB 会要求连接时提供用户名和密码。      示例：auth: true            replication：          解释：指定 MongoDB 是否为复制集成员。复制集是一组 MongoDB 服务器的集合，用于提供数据的冗余备份和高可用性。      示例：replication: { replSetName: \"myReplicaSet\" }            security.authorization：          解释：指定 MongoDB 的授权模式。可以选择 “enabled”（启用）或 “disabled”（禁用）。启用授权后，需要通过用户名和密码进行身份验证。      示例：security.authorization: enabled            storage.journal.enabled：          解释：指定是否启用日志记录。启用日志记录可以提高 MongoDB 的数据持久性，但会对性能产生一定影响。      示例：storage.journal.enabled: true      "
  },
  
  {
    "title": "Django Base",
    "url": "/posts/1-django-base/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Django",
    "date": "2022-05-27 10:00:00 +0800",
    





    
    "snippet": "简介  Python Django 是一个流行的 Web 开发框架，它提供了一种快速构建高质量 Web 应用程序的方式。Django 是由 Python编程语言编写的，它采用了“模型-视图-控制器”（MVC）设计模式，以及“全栈框架”思想，使得开发者可以轻松地实现数据模型、业务逻辑和用户界面的交互。  Django 的特点：      自带管理后台：Django 自带了一个可自定义的管理后台...",
    "content": "简介  Python Django 是一个流行的 Web 开发框架，它提供了一种快速构建高质量 Web 应用程序的方式。Django 是由 Python编程语言编写的，它采用了“模型-视图-控制器”（MVC）设计模式，以及“全栈框架”思想，使得开发者可以轻松地实现数据模型、业务逻辑和用户界面的交互。  Django 的特点：      自带管理后台：Django 自带了一个可自定义的管理后台，可以方便地管理应用程序中的数据。        ORM 支持：Django 提供了强大的对象关系映射（ORM）支持，使得开发者可以使用 Python 代码来操作数据库，而不必直接编写 SQL 语句。        URL 路由支持：Django 使用 URLConf 来处理 URL 请求，这个过程简单明了，并且可以非常容易地进行路由、重定向和 URL 反转等操作。        模板引擎：Django 自带了一个模板引擎，可以让开发者更加轻松地构建用户界面。        安全性：Django 将安全性作为其核心原则之一，提供了一系列针对常见 Web 安全漏洞的内置保护机制。        社区支持：Django 拥有庞大的社区支持，可以让开发者轻松地找到解决问题的方法和资源。  HelloWorld  让我为你介绍一下如何使用 Django 创建一个 “Hello, World!”      首先，确保你已安装了 Python 和 Django。可以通过以下命令来检查：    python --versiondjango-admin --version            接下来，打开终端并输入以下命令创建一个 Django 项目：    django-admin startproject helloworld            这将会在当前目录下创建一个名为 helloworld 的文件夹，并在其中生成 Django 项目的基本结构。          进入 helloworld 目录：        cd helloworld            然后再输入以下命令以启动开发服务器：    python manage.py runserver        现在，在浏览器中访问 访问地址 即可看到 “Welcome to Django” 的欢迎页面。      接下来，我们需要创建一个简单的视图来输出 “Hello, World!”。在 helloworld/helloworld 目录下创建一个名为 views.py的文件，并添加以下内容：    from django.http import HttpResponse  def hello(request):    return HttpResponse(\"Hello, World!\")            接着，我们需要将这个视图映射到 URL 上。打开 helloworld/helloworld/urls.py 文件，并将以下代码添加到 urlpatterns 列表中：    from django.urls import pathfrom . import views  urlpatterns = [    path('hello/', views.hello, name='hello'),]            最后，我们需要重启开发服务器，以便 Django 加载新的视图和 URL 映射。在终端中按下 Ctrl + C，然后再次运行以下命令：    python manage.py runserver              现在，在浏览器中访问 HelloWorld你将会看到 “Hello, World!” 的输出。这就是一个简单的 Django “Hello, World!” 项目的创建过程。          "
  },
  
  {
    "title": "Python Other",
    "url": "/posts/13-other/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:18 +0800",
    





    
    "snippet": "Other多线程  Python多线程是一种并发编程的技术，在同一时间内执行多个线程，从而提高程序的效率和响应速度。在Python中，可以使用threading模块来创建和管理线程。      下面是一个简单的例子：    import threading  def print_numbers():    for i in range(1, 11):        print(i)  def...",
    "content": "Other多线程  Python多线程是一种并发编程的技术，在同一时间内执行多个线程，从而提高程序的效率和响应速度。在Python中，可以使用threading模块来创建和管理线程。      下面是一个简单的例子：    import threading  def print_numbers():    for i in range(1, 11):        print(i)  def print_letters():    for i in range(ord('a'), ord('k')):        print(chr(i))  t1 = threading.Thread(target=print_numbers)t2 = threading.Thread(target=print_letters)  t1.start()t2.start()  t1.join()t2.join()            该程序创建了两个线程t1和t2，分别执行print_numbers函数和print_letters函数。通过调用start()方法启动线程，join()方法等待线程结束。在上述例子中，t1和t2会同时执行，因此输出结果可能是交替出现的数字和字母。        需要注意的是，在多线程编程中，由于多个线程共享相同的资源（如全局变量或文件），因此可能会出现竞争条件和死锁等问题。因此，在编写多线程程序时，需要特别小心，确保线程安全。        另外，Python还提供了multiprocessing模块，可以将任务分配给多个进程并行处理，更适合CPU密集型任务。与多线程不同，每个进程拥有独立的内存空间，不会共享资源。  协程  Python 协程是一种轻量级的并发编程方式，可以通过使用 async 和 await 关键字来实现。协程是可以暂停和恢复执行的函数，可以让我们更方便地进行异步编程。      下面是一个简单的 Python 协程示例：    import asyncio  async def foo():    print('Start foo')    await asyncio.sleep(1)    print('Finish foo')  async def bar():    print('Start bar')    await asyncio.sleep(2)    print('Finish bar')  async def main():    # 并发执行 foo 和 bar 协程    tasks = [asyncio.create_task(foo()), asyncio.create_task(bar())]    await asyncio.gather(*tasks)  if __name__ == '__main__':    asyncio.run(main())            这个示例定义了三个协程函数 foo、bar 和 main，其中 foo 和 bar 分别打印一些信息并等待一段时间，main函数则同时调用 foo 和 bar 协程，并使用 asyncio.gather() 方法并发运行这两个协程。最终输出结果为：    Start fooStart barFinish fooFinish bar        这说明在 3 秒钟内，同时执行了 foo 和 bar 协程，并且在各自的等待时间结束后，按顺序输出了相应的结果。"
  },
  
  {
    "title": "Python Stdlib",
    "url": "/posts/12-stdlib/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:17 +0800",
    





    
    "snippet": "标准库  os：提供了与操作系统交互的函数，例如文件和目录操作。  sys：提供了访问Python解释器及其环境的变量和函数。  math：提供了数学计算函数，例如三角函数、指数函数等。  random：提供了生成随机数的函数。  datetime：提供了处理日期和时间的函数和类。  re：提供了正则表达式功能，用于字符串匹配和处理。  json：提供了处理JSON数据的函数和类。  csv...",
    "content": "标准库  os：提供了与操作系统交互的函数，例如文件和目录操作。  sys：提供了访问Python解释器及其环境的变量和函数。  math：提供了数学计算函数，例如三角函数、指数函数等。  random：提供了生成随机数的函数。  datetime：提供了处理日期和时间的函数和类。  re：提供了正则表达式功能，用于字符串匹配和处理。  json：提供了处理JSON数据的函数和类。  csv：提供了读写CSV格式文件的函数和类。  urllib：提供了与HTTP协议相关的函数和类，用于发送HTTP请求和接收响应。  socket：提供了网络编程所需的基本功能，例如创建套接字、发送和接收数据等。  除此之外，还有许多其他模块，例如collections、itertools、functools、logging等，它们提供了各种实用功能和工具。使用Python标准库可以大幅度提高编程效率，并且在大多数情况下，它们提供的功能已经足够满足常见需求。1. os模块  import os    # 获取当前工作目录  cur_dir = os.getcwd()  print(cur_dir)    # 创建目录  new_dir = os.path.join(cur_dir, 'new_folder')  os.mkdir(new_dir)    # 列出目录内容  content = os.listdir(cur_dir)  print(content)  这个例子演示了如何使用os模块进行文件和目录操作。通过getcwd()函数可以获取当前工作目录，使用join()函数可以拼接路径，使用mkdir()函数可以创建新目录，使用listdir()函数可以列出目录内容。2. sys模块  import sys    # 打印命令行参数  args = sys.argv  for arg in args:      print(arg)    # 获取Python解释器信息  info = sys.version_info  print(info)  这个例子演示了如何使用sys模块访问Python解释器及其环境的变量和函数。通过argv变量可以获取命令行参数，通过version_info变量可以获取Python解释器版本信息。3. math模块  import math    # 计算正弦值  sin_val = math.sin(math.pi/4)  print(sin_val)    # 计算自然指数  exp_val = math.exp(2)  print(exp_val)    # 向上取整  ceil_val = math.ceil(4.3)  print(ceil_val)  这个例子演示了如何使用math模块进行数学计算。通过sin()函数可以计算给定角度的正弦值，使用exp()函数可以计算自然指数，使用ceil()函数可以将浮点数向上取整。4. random模块import random# 生成随机整数rand_int = random.randint(1, 10)print(rand_int)# 从列表中选择随机元素my_list = ['apple', 'banana', 'orange']rand_item = random.choice(my_list)print(rand_item)  这个例子演示了如何使用random模块生成随机数。通过randint()函数可以生成指定范围内的随机整数，使用choice()函数可以从列表中随机选择一个元素。5. datetime模块import datetime# 获取当前日期和时间now = datetime.datetime.now()print(now)# 格式化时间字符串str_time = now.strftime(\"%Y-%m-%d %H:%M:%S\")print(str_time)  这个例子演示了如何使用datetime模块处理日期和时间。通过now()函数可以获取当前日期和时间，使用strftime()函数可以将日期和时间格式化为指定的字符串格式。6. re模块import re# 查找匹配的字符串pattern = r'hello\\s(\\w+)'text = 'hello world'match_obj = re.search(pattern, text)if match_obj:    print(match_obj.group(1))  这个例子演示了如何使用re模块进行正则表达式匹配。通过search()函数可以在文本中查找与指定模式匹配的字符串，并返回一个匹配对象，使用group()方法可以获取匹配到的字符串。7. json模块import json# 将Python对象转换为JSON字符串data = {'name': 'Alice', 'age': 25}json_str = json.dumps(data)print(json_str)# 将JSON字符串转换为Python对象json_data = '{\"name\": \"Bob\", \"age\": 30}'py_obj = json.loads(json_data)print(py_obj)  这个例子演示了如何使用json模块处理JSON数据。通过dumps()函数可以将Python对象转换为JSON字符串，使用loads()函数可以将JSON字符串转换为Python对象。8. csv模块import csv# 写入CSV文件data = [['Name', 'Age'], ['Alice', 25], ['Bob', 30]]with open('people.csv', 'w', newline='') as file:    writer = csv.writer(file)    writer.writerows(data)# 读取CSV文件with open('people.csv', 'r') as file:    reader = csv.reader(file)    for row in reader:        print(row)  这个例子演示了如何使用csv模块进行CSV文件的读写。通过writerows()函数可以将数据写入CSV文件，使用reader()函数可以读取CSV文件，并且返回以每一行作为元素的列表。9. urllib模块import urllib.request# 发送GET请求并获取响应response = urllib.request.urlopen('http://www.baidu.com')html = response.read()print(html)  这个例子演示了如何使用urllib模块发送HTTP请求，并接收响应。使用urlopen()函数可以发送GET请求并获取响应。响应内容是字节类型的数据，可以使用decode()方法将其转换为文本类型的数据。10. socket模块import socket# 创建套接字sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 连接服务器server_address = ('localhost', 8888)sock.connect(server_address)# 发送和接收数据message = b'Hello, server!'sock.sendall(message)data = sock.recv(1024)print(data)# 关闭套接字sock.close()  这个例子演示了如何使用socket模块进行网络编程。通过socket()函数可以创建套接字对象，使用connect()函数可以连接到指定地址和端口的服务器，使用sendall()函数可以发送数据，使用recv()函数可以接收数据，最后使用close()函数关闭套接字。完整例子以下是一个包含以上标准库的Python代码片段：import osimport sysimport mathimport randomimport datetimeimport reimport jsonimport csvimport urllib.requestimport socket# 使用标准库函数和方法print(os.listdir('.'))print(sys.version_info)print(math.pi)print(random.randint(1, 10))print(datetime.datetime.now())print(re.findall(r'\\b\\w+\\b', 'Hello, World!'))print(json.dumps({'name': 'Alice', 'age': 25}))data = [['Name', 'Age'], ['Alice', 25], ['Bob', 30]]with open('people.csv', 'w', newline='') as file:    writer = csv.writer(file)    writer.writerows(data)response = urllib.request.urlopen('http://www.baidu.com')html = response.read()print(html)sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_address = ('localhost', 8888)sock.connect(server_address)message = b'Hello, server!'sock.sendall(message)data = sock.recv(1024)print(data)sock.close()      这个代码片段演示了如何使用以上标准库。具体地：          os模块：使用listdir()函数列出当前目录下的文件和子目录。      sys模块：使用version_info属性获取Python解释器版本信息。      math模块：使用pi常量获取圆周率。      random模块：使用randint()函数生成指定范围内的随机整数。      datetime模块：使用datetime.now()函数获取当前日期和时间。      re模块：使用findall()函数查找字符串中的单词。      json模块：使用dumps()函数将Python对象转换为JSON格式的字符串。      csv模块：使用writerows()函数将数据写入CSV文件。      urllib.request模块：使用urlopen()函数发送HTTP请求并获取响应。      socket模块：使用套接字对象创建网络连接，发送和接收数据。        最后，这个代码片段的运行结果可以根据具体环境而定。例如，输出当前目录下的文件列表、Python解释器版本信息、圆周率等是固定的；而生成的随机整数、当前日期和时间、从网站获取的HTML内容、服务器返回的数据等则会因为不同的运行环境而不同。"
  },
  
  {
    "title": "Python Class",
    "url": "/posts/11-class/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:16 +0800",
    





    
    "snippet": "类  在Python中，类是一个用于创建对象的蓝图或模板。它定义了一组属性和方法，这些属性和方法都是由在该类实例化时创建的对象共享的。类可以看作是一种自定义的数据类型，用于封装并组织相关的数据和操作。  在Python中，定义一个类需要使用class关键字，其基本语法如下：class ClassName:    # 类变量    class_variable = 0    def __ini...",
    "content": "类  在Python中，类是一个用于创建对象的蓝图或模板。它定义了一组属性和方法，这些属性和方法都是由在该类实例化时创建的对象共享的。类可以看作是一种自定义的数据类型，用于封装并组织相关的数据和操作。  在Python中，定义一个类需要使用class关键字，其基本语法如下：class ClassName:    # 类变量    class_variable = 0    def __init__(self, arg1, arg2):        # 实例变量        self.instance_variable1 = arg1        self.instance_variable2 = arg2    def method1(self):        # 实例方法        pass    @classmethod    def method2(cls):        # 类方法        pass    @staticmethod    def method3():        # 静态方法        pass其中，ClassName是类名，可以按照标识符的规则进行命名。类变量是与类相关联的变量，它被所有该类的实例所共享。实例变量是每个类实例特有的变量，只能由该类实例访问。方法是在类中定义的函数，用于执行某些操作。有三种不同类型的方法：实例方法、类方法和静态方法。  实例方法：这些方法是最常见的方法类型，它们将self作为第一个参数，表示对类实例进行操作。通过实例调用这些方法时，Python会自动传递实例作为第一个参数。  类方法：这些方法使用@classmethod装饰器定义，在方法中第一个参数表示类而不是实例，通常被用来创建工厂函数或在整个类中共享某些属性或方法。  静态方法：这些方法使用@staticmethod装饰器定义，它们与类无关，并且不接收任何特殊的实参。静态方法通常用于执行与类相关但独立于具体类实例的操作。除此之外，Python还支持继承和多态性等面向对象编程的概念，使得类可以更加灵活地组合和复用代码。"
  },
  
  {
    "title": "Python Error",
    "url": "/posts/10-error/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:15 +0800",
    





    
    "snippet": "常见错误      语法错误（SyntaxError）：指代码中存在语法问题，如缺少冒号、括号不匹配等。        执行时错误（RuntimeError）：指程序在执行过程中出现了无法预料的问题，如调用未定义的变量或函数、访问不存在的列表元素等。        类型错误（TypeError）：指数据类型不匹配，如将字符串传递给需要数字类型的函数、将列表传递给需要字典类型的函数等。    ...",
    "content": "常见错误      语法错误（SyntaxError）：指代码中存在语法问题，如缺少冒号、括号不匹配等。        执行时错误（RuntimeError）：指程序在执行过程中出现了无法预料的问题，如调用未定义的变量或函数、访问不存在的列表元素等。        类型错误（TypeError）：指数据类型不匹配，如将字符串传递给需要数字类型的函数、将列表传递给需要字典类型的函数等。        名称错误（NameError）：指尝试访问未定义的变量或函数。        数学错误（ZeroDivisionError）：指除数为零的情况。        文件错误（FileNotFoundError）：指要打开的文件不存在或无法访问。    当程序出现错误或异常时，Python 会在控制台输出相应的错误信息，并且可能会终止程序的执行。为了使程序更加健壮和可靠，我们可以使用异常处理机制来捕获并处理这些错误和异常。      在 Python 中，异常处理机制使用try-except语句来实现。try块中包含可能会引发异常的代码，except块中处理相应的异常，并在需要时执行一些操作。例如：    try:    x = int(input(\"请输入一个整数：\"))    y = 10 / x    print(\"y =\", y)except ValueError:    print(\"您输入的不是整数\")except ZeroDivisionError:    print(\"除数不能为零\")except Exception as e:    print(\"其他错误：\", e)else:    print(\"程序运行成功\")finally:    print(\"程序结束\")        在上述代码中，我们使用try语句尝试从用户输入中获取一个整数，然后计算 10除以该整数。如果用户输入的不是整数或者除数为零，则会引发相应的异常并被except语句捕获。如果没有发生任何异常，则会执行else语句中的代码。无论是否发生了异常，finally语句中的代码都会被执行。  需要注意的是，在处理异常时，可以使用as关键字将异常对象赋值给一个变量，这样可以方便地访问异常的相关信息。同时，还可以使用raise语句手动引发异常，以便更好地控制程序的流程。"
  },
  
  {
    "title": "Python DataStruct",
    "url": "/posts/9-data-strcut/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:14 +0800",
    





    
    "snippet": "list  列表（List）是 Python中最常用的数据结构之一，它可以存储多个元素，并且允许对其中的元素进行添加、删除、修改和排序等操作。列表用方括号 []表示，每个元素用逗号 , 分隔。  以下是一个简单的列表示例：my_list = [1, 2, 3, \"four\", 5.0]  可以通过索引值来访问列表中的元素。索引值从0开始，表示第一个元素，依次类推。例如，要访问上面列表中的第三...",
    "content": "list  列表（List）是 Python中最常用的数据结构之一，它可以存储多个元素，并且允许对其中的元素进行添加、删除、修改和排序等操作。列表用方括号 []表示，每个元素用逗号 , 分隔。  以下是一个简单的列表示例：my_list = [1, 2, 3, \"four\", 5.0]  可以通过索引值来访问列表中的元素。索引值从0开始，表示第一个元素，依次类推。例如，要访问上面列表中的第三个元素（即数字 3），可以使用以下代码：print(my_list[2])  # 输出：3  还可以使用切片（slice）来访问列表中的一部分元素。切片可以理解为提取列表中的一个子集，其语法为 [start:stop:step]，其中 start 表示起始位置，stop 表示结束位置（不包含该位置的元素），step 表示步长（默认为1）。例如，要提取上面列表中的前三个元素，可以使用以下代码：print(my_list[:3])  # 输出：[1, 2, 3]      除此之外，还可以使用内置函数对列表进行操作，例如：    append()：向列表末尾添加一个元素；  extend()：将一个列表中的元素添加到另一个列表的末尾；  insert()：在列表的指定位置插入一个元素；  remove()：从列表中删除指定元素的第一个匹配项；  pop()：移除并返回列表中指定索引处的元素；  sort()：对列表进行排序；      reverse()：反转列表中的元素顺序。    例如，要向上面的列表中添加一个字符串 \"six\"，可以使用以下代码：my_list.append(\"six\")print(my_list)  # 输出：[1, 2, 3, 'four', 5.0, 'six']  还可以使用以下代码将另一个列表 [7, 8, 9] 中的元素添加到该列表的末尾：my_list.extend([7, 8, 9])print(my_list)  # 输出：[1, 2, 3, 'four', 5.0, 'six', 7, 8, 9]stack  堆栈是一种常见的数据结构，它可以用来存储一组元素，其中最后加入的元素最先被取出。也就是说，堆栈遵循“后进先出”的原则（Last InFirst Out, LIFO）。在堆栈中，只允许在顶部进行插入和删除操作，因此堆栈也被称为“栈”（Stack）。  Python 中可以使用列表来实现堆栈。具体来说，可以使用 append() 方法向列表末尾添加一个元素，使用 pop()方法从列表末尾移除一个元素。例如，以下代码演示了如何使用列表实现一个简单的堆栈：stack = []  # 创建一个空栈# 向栈中添加元素stack.append(1)stack.append(2)stack.append(3)# 从栈中取出元素print(stack.pop())  # 输出：3print(stack.pop())  # 输出：2print(stack.pop())  # 输出：1  在上面的代码中，我们首先创建了一个空列表 stack，然后使用 append() 方法向栈中依次添加元素 1、2 和 3。接着，我们使用 pop() 方法从栈中依次取出元素，并分别输出它们的值。由于堆栈遵循“后进先出”的原则，因此最后加入的元素 3最先被取出，其次是 2 和 1。  需要注意的是，如果尝试从空栈中取出元素，将会引发 IndexError 异常。因此，在使用栈时应该先判断栈是否为空。例如，以下代码演示了如何在弹出元素前检查栈是否为空：stack = []if not stack:    print(\"栈为空\")# 尝试从空栈中弹出元素try:    item = stack.pop()except IndexError:    print(\"栈已为空\")else:    print(item)  在上面的代码中，我们首先创建了一个空列表 stack，然后使用 if not stack判断栈是否为空。由于栈为空，因此输出一条提示信息。接着，我们使用 try...except...else...结构来尝试从空栈中弹出元素。由于栈已经为空，因此将会引发 IndexError 异常，并输出一条提示信息。队列  队列是一种常见的数据结构，它可以用来存储一组元素，并且保证最先加入的元素最先被取出。也就是说，队列遵循“先进先出”的原则（FirstIn First Out, FIFO）。在队列中，只允许在队尾进行插入操作，在队头进行删除操作，因此队列也被称为“先进先出队列”（First-In-First-OutQueue，FIFO Queue）。  Python 中可以使用列表来实现队列。具体来说，可以使用 append() 方法向列表末尾添加一个元素，使用 pop()方法从列表头部移除一个元素。例如，以下代码演示了如何使用列表实现一个简单的队列：queue = []  # 创建一个空队列# 向队列中添加元素queue.append(1)queue.append(2)queue.append(3)# 从队列中取出元素print(queue.pop(0))  # 输出：1print(queue.pop(0))  # 输出：2print(queue.pop(0))  # 输出：3  在上面的代码中，我们首先创建了一个空列表 queue，然后使用 append() 方法向队列中依次添加元素 1、2 和 3。接着，我们使用 pop(0)方法从队列中依次取出元素，并分别输出它们的值。由于队列遵循“先进先出”的原则，因此最先加入的元素 1最先被取出，其次是 2 和 3。  需要注意的是，如果尝试从空队列中取出元素，将会引发 IndexError 异常。因此，在使用队列时应该先判断队列是否为空。例如，以下代码演示了如何在弹出元素前检查队列是否为空：queue = []if not queue:    print(\"队列为空\")# 尝试从空队列中弹出元素try:    item = queue.pop(0)except IndexError:    print(\"队列已为空\")else:    print(item)  在上面的代码中，我们首先创建了一个空列表 queue，然后使用 if not queue判断队列是否为空。由于队列为空，因此输出一条提示信息。接着，我们使用 try...except...else...结构来尝试从空队列中弹出元素。由于队列已经为空，因此将会引发 IndexError 异常，并输出一条提示信息。"
  },
  
  {
    "title": "Python Function",
    "url": "/posts/8-function/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:13 +0800",
    





    
    "snippet": "简介  Python函数是一段用来完成特定任务的可重复调用的代码块。它们接受输入参数、执行某些操作并返回结果。函数可以帮助我们组织代码，避免出现重复的代码，并使代码更易于阅读和维护。  在Python中，定义一个函数需要使用def关键字，后面跟着函数名、参数列表和一个冒号。函数体内的代码必须缩进。      以下是一个简单的Python函数示例：    def greet(name):   ...",
    "content": "简介  Python函数是一段用来完成特定任务的可重复调用的代码块。它们接受输入参数、执行某些操作并返回结果。函数可以帮助我们组织代码，避免出现重复的代码，并使代码更易于阅读和维护。  在Python中，定义一个函数需要使用def关键字，后面跟着函数名、参数列表和一个冒号。函数体内的代码必须缩进。      以下是一个简单的Python函数示例：    def greet(name):    print(\"Hello, \" + name + \"!\")  greet(\"John\")        该代码定义了一个名为greet的函数，该函数接受一个参数name，将其与字符串\"Hello, \"和\"!\"连接起来并打印出来。最后一行代码调用这个函数并传递一个名为John的参数。  当你运行这段代码时，它会输出：Hello, John!  除了上面这种简单的函数，Python还支持很多不同类型的函数，包括没有参数的函数、返回值的函数、匿名函数和高阶函数等。定义函数在 Python 中，可以使用 def 关键字定义函数。函数定义语法如下：def function_name(parameters):    \"\"\"函数文档字符串\"\"\"    # 函数体代码    return [expression]  # 可选的返回值其中，function_name 是函数名，parameters是可选的参数列表，用括号包含，多个参数之间用逗号分隔；函数体代码是函数要执行的操作，可以包含任意数量的语句；return语句可选，用于指定函数的返回值。例如，下面是一个简单的函数，将两个数相加并返回结果：def add_numbers(a, b):    \"\"\"    将两个数字相加并返回结果    \"\"\"    result = a + b    return result在这个例子中，add_numbers 是函数名，它接受两个参数 a 和 b。函数体代码将它们相加，并将结果存储在变量 result中。最后，通过 return 语句将结果返回给调用方。函数定义详解  函数名  参数列表  函数体。函数名Python 中的函数名必须遵循标识符命名规则，即由字母、数字和下划线组成，不能以数字开头。建议给函数选用有意义的名字，便于代码的阅读和理解。参数列表函数可以接受零个或多个参数，这些参数传递给函数后，可以在函数内部使用。在 Python 中，参数列表放在括号中，多个参数之间用逗号隔开。例如：def my_func(arg1, arg2, arg3):    # 函数体代码上面的函数定义接受三个参数 arg1、arg2 和 arg3。在 Python 中，参数可以有默认值，这样调用函数时就可以省略对应的参数。例如：def my_func(arg1, arg2=0, arg3='default'):    # 函数体代码在上面的例子中，arg2 有一个默认值为 0，arg3 有一个默认值为 'default'。因此，在调用 my_func时，可以省略这两个参数。如果不指定 arg2，则它将被设置为 0。如果不指定 arg3，则它将被设置为 'default'。函数体函数体是包含在函数定义中的代码块。函数体通常包含一些操作，用于处理输入参数并生成输出结果。在 Python中，函数体由缩进的语句组成，这些语句会在函数被调用时执行。def my_func(arg1, arg2):    # 函数体代码    print(f\"arg1={arg1}, arg2={arg2}\")    result = arg1 + arg2    return result在上面的例子中，my_func 接受两个参数 arg1 和 arg2。函数体包含两行代码，第一行使用 print函数打印参数的值，第二行将 arg1 和 arg2 相加，并将结果返回给调用方。模块      Python 标准库中有很多内置的模块可供使用，例如：          os：提供了访问操作系统功能的接口，如文件操作、进程管理等。      sys：提供了与 Python 解释器及其环境交互的功能，如获取命令行参数、退出程序等。      math：提供了数学运算的函数，如三角函数、指数函数等。      datetime：提供了日期和时间相关的函数操作，如获取当前时间、计算时间差等。            除了标准库外，我们还可以使用第三方库或自己编写的模块来扩展 Python 的功能。导入模块可以使用import语句，例如：    import mathprint(math.sqrt(25))  # 输出 5.0            也可以使用from ... import语句导入模块中的指定函数或变量，例如：    from datetime import datetoday = date.today()print(today)  # 输出格式为 YYYY-MM-DD 的今天的日期            如果想要导入整个模块的所有成员，可以使用from ... import *语句，例如：    from math import *print(sqrt(25))  # 输出 5.0        需要注意的是，当导入模块时，Python 会在指定的路径中查找模块文件。如果模块不存在或不能被找到，则会引发ModuleNotFoundError异常。包  在 Python 中，包是一个目录，其中包含了一组模块和子包。包的主要作用是将相关的模块组织在一起，使得程序设计更加模块化和易于管理。      Python 的标准库中有很多包可供使用，例如：          os：提供了访问操作系统功能的接口，如文件操作、进程管理等。      sys：提供了与 Python 解释器及其环境交互的功能，如获取命令行参数、退出程序等。      math：提供了数学运算的函数，如三角函数、指数函数等。      datetime：提供了日期和时间相关的函数操作，如获取当前时间、计算时间差等。            除了标准库外，我们也可以自己编写包来组织自己的代码。在 Python 中，一个目录要想成为一个包，需要满足以下条件：                  包目录下必须包含一个名为__init__.py的文件，该文件可以为空或者包含一些初始化代码；                    包目录下可以包含若干个模块（.py 文件），这些模块可以相互导入。                    举例来说，假设我们编写了一个名为mypackage的包，其目录结构如下所示：        mypackage/    __init__.py    module1.py    module2.py    submodule/        __init__.py        submodule1.py            其中，mypackage是一个包，包含了module1.py、module2.py和submodule子包。submodule子包中有一个名为submodule1.py的模块。          如果要使用该包中的模块，可以使用import语句，例如：        import mypackage.module1mypackage.module1.foo()  from mypackage.module2 import barbar()  from mypackage.submodule.submodule1 import bazbaz()        需要注意的是，当导入包或模块时，Python 会在指定的路径中查找包或模块所在的目录，并将其添加到sys.path中。如果包或模块不存在或不能被找到，则会引发ModuleNotFoundError异常。"
  },
  
  {
    "title": "Python Controlflow",
    "url": "/posts/7-controlflow/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:12 +0800",
    





    
    "snippet": "流程控制  if  for  while判断控制结构  Python 中的判断控制结构主要有 if-elif-else 和 ternary operator。if-elif-elseif condition1:    # 当条件 1 满足时执行的代码elif condition2:    # 当条件 1 不满足且条件 2 满足时执行的代码else:    # 当条件 1 和条件 2 都不满足...",
    "content": "流程控制  if  for  while判断控制结构  Python 中的判断控制结构主要有 if-elif-else 和 ternary operator。if-elif-elseif condition1:    # 当条件 1 满足时执行的代码elif condition2:    # 当条件 1 不满足且条件 2 满足时执行的代码else:    # 当条件 1 和条件 2 都不满足时执行的代码  其中，condition1、condition2等都是需要判断的条件表达式，可以使用比较运算符、逻辑运算符等来组合成复杂的判断条件。当条件 condition1满足时，执行对应的代码块；否则继续判断下一个条件 condition2，以此类推，直到找到一个满足条件的代码块或者所有条件都不满足时，执行最后的 else 块。ternary operatorresult = value1 if condition else value2  其中，condition 是需要判断的条件表达式，当条件成立时，返回 value1，否则返回 value2。这种语法结构也称为三目运算符，简单明了，通常用于在一行代码中完成简单的条件判断。循环结构for  for 循环通常用于遍历序列类型（如字符串、列表、元组等）中的元素，语法结构如下：for 变量 in 序列:    # 循环体其中，变量 表示接收到的序列元素，序列 是需要遍历的序列，循环会按顺序依次将序列中的元素赋值给 变量，然后执行循环体中的语句。例如：fruits = [\"apple\", \"banana\", \"cherry\"]for fruit in fruits:    print(fruit)上述代码会输出 apple、banana 和 cherry 三个字符串，分别对应 fruits 列表中的三个元素。while  while 循环会在满足条件时重复执行循环体，直到条件不再成立为止。语法结构如下：while 条件:    # 循环体  其中，条件 是判断条件，如果成立则进入循环体执行；否则结束循环。例如：i = 1while i &lt;= 5:    print(i)    i += 1  上述代码会输出数字 1 到 5，因为当 i 的值小于等于 5 时，满足条件，会不断地执行循环体中的代码，每次输出 i 的值，并将 i加 1。当 i 大于 5 时，不再满足条件，循环结束。循环中语句break  break语句可以在循环内部立即终止循环，并跳出循环体。for i in range(10):    if i == 5:        break    print(i)continue  continue语句在循环中用于跳过当前迭代，并进入下一次迭代。for i in range(10):    if i % 2 == 0:        continue    print(i)pass  pass语句在Python中是一个空语句，用于表示占位符，不做任何操作。for i in range(10):    if i == 5:        pass    else:        print(i)range() 函数range() 函数是 Python 内置函数之一，它用于创建一个整数列表，常用于 for 循环中。 range() 函数有三个参数：起始值、终止值和步长。      语法如下    range(start, stop[, step])            说明          start：表示数列的起始值，默认为 0。      stop：表示数列的终止值（不包括），必须指定。      step：表示数列的公差，默认为 1。        返回的结果是一个可迭代对象，可以使用 list() 函数将其转换为列表      例子    # 打印 0 到 4 的整数for i in range(5):    print(i)  # 打印 2 到 8 的偶数for i in range(2, 9, 2):    print(i)            输出：      0  1  2  3  4  2  4  6  8      需要注意的是， range() 函数返回的是一个不可变序列，在 Python 2.x 中叫做 xrange()。如果需要修改序列中的元素，可以使用其他数据类型，如列表或数组。match 语法  match 是 Python 3.10 新增的一种模式匹配语法，也被称为结构化匹配。它提供了更加简洁和易于理解的方式来匹配和分解复杂数据结构，例如元组、列表、字典等。  match 的语法如下：match expression:    case pattern_1:        # 处理 pattern_1 的情况    case pattern_2 if condition:        # 处理 pattern_2 和条件成立的情况    case _:        # 处理其他情况其中 expression 表示要进行匹配的表达式，可以是任意类型的值，如数字、字符串、元组、列表等。 pattern是一种匹配模式，用于匹配 expression 中的值。case 子句用来指定不同的匹配情况，可以指定多个 case 子句，每个子句包含一个 pattern和对应的处理逻辑。多个子句按照出现顺序进行匹配，匹配成功后执行对应的处理逻辑。如果所有的 case 都没有匹配成功，则会执行 _ 子句中的代码块，类似于 switch-case 语句中的 default 分支。  match 进行模式匹配的例子：def match_example(x):    match x:        case 0:            print(\"x is zero\")        case 1:            print(\"x is one\")        case _ if x &gt; 1:            print(\"x is greater than one\")        case _:            print(\"x is a negative number\")match_example(0)    # 输出 \"x is zero\"match_example(1)    # 输出 \"x is one\"match_example(2)    # 输出 \"x is greater than one\"match_example(-1)   # 输出 \"x is a negative number\"  需要注意的是，match 语法仅在 Python 3.10 及以上版本中可用，如果使用较早的 Python 版本，则无法使用。循环技巧  使用 range() 函数来生成一个数列，可以用于循环：     for i in range(10):     print(i)            使用 enumerate() 函数来同时遍历序列的下标和值：     fruits = ['apple', 'banana', 'cherry'] for i, fruit in enumerate(fruits):     print(i, fruit)            使用 zip() 函数来同时遍历多个序列：     fruits = ['apple', 'banana', 'cherry'] prices = [0.5, 0.25, 0.3] for fruit, price in zip(fruits, prices):     print(fruit, price)            使用列表解析式来快速生成一个新的列表：     numbers = [1, 2, 3, 4, 5] squares = [x**2 for x in numbers] print(squares)            使用条件表达式（三元运算符）来简化 if-else 语句：     x = 10 y = 'yes' if x &gt; 5 else 'no' print(y)      "
  },
  
  {
    "title": "Python Introduction",
    "url": "/posts/6-introduction/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:11 +0800",
    





    
    "snippet": "基础语法Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，其语法简洁清晰，易于学习和使用注释在 Python 中，注释用 # 开头，可以单独占据一行或跟在代码后面。# 这是一条注释print(\"hello, world\")  # 这也是一条注释变量x = 5  # 定义一个整型变量y = \"hello\"  # 定义一个字符串变量a, b, c = 1, 2, 3  # 多...",
    "content": "基础语法Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，其语法简洁清晰，易于学习和使用注释在 Python 中，注释用 # 开头，可以单独占据一行或跟在代码后面。# 这是一条注释print(\"hello, world\")  # 这也是一条注释变量x = 5  # 定义一个整型变量y = \"hello\"  # 定义一个字符串变量a, b, c = 1, 2, 3  # 多重赋值基础数据类型  整数(int)：表示整数值，例如：10、20、-30 等  浮点数(float)：表示小数，例如：3.14、-0.5 等  字符串(str)：表示文本，例如：”Hello, World!”、’Python’ 等  布尔值(bool)：表示逻辑值，即 True 或 False  列表(list)：表示一组有序的元素，可以包含不同类型的数据  元组(tuple)：与列表类似，但是不可变，即创建之后不能再改变  集合(set)：表示一组互不相同的元素，无序  字典(dict)：表示一个键值对的集合，其中每个键都是唯一的示例以下是一个包含全部基本数据类型的 Python 代码示例，同时也包含了一些注释：# 定义整数my_int = 10# 定义浮点数my_float = 3.14# 定义字符串my_string = \"Hello, World!\"# 定义布尔值my_bool = True# 定义列表my_list = [1, \"two\", 3.0, True]# 定义元组my_tuple = (4, \"five\", 6.0, False)# 定义集合my_set = {7, \"eight\", 9.0, True}# 定义字典my_dict = {\"name\": \"Tom\", \"age\": 25, \"gender\": \"male\"}# 打印各个变量的类型和值print(type(my_int), my_int)print(type(my_float), my_float)print(type(my_string), my_string)print(type(my_bool), my_bool)print(type(my_list), my_list)print(type(my_tuple), my_tuple)print(type(my_set), my_set)print(type(my_dict), my_dict)  该代码定义了一个整数、一个浮点数、一个字符串、一个布尔值、一个列表、一个元组、一个集合和一个字典，并使用 type()函数打印了它们的类型和值。切片  在Python中，切片是指从一个序列中获取其中一部分的操作。切片可以应用于字符串、列表、元组等序列类型。切片的语法如下：sequence[start:stop:step]其中，sequence 是要切片的序列，start、stop 和 step 分别表示起始位置、终止位置和步长。      举个例子，如果我们有一个字符串 s = 'hello world'，那么取出前 5 个字符的切片代码如下：    s[:5]  # 输出 'hello'            再比如，如果我们有一个列表 lst = [1, 2, 3, 4, 5, 6]，那么取出第 2 到第 5 个元素的切片代码如下：    lst[1:5]  # 输出 [2, 3, 4, 5]        需要注意的是，起始位置默认为 0，终止位置默认为序列长度。如果步长未指定，默认为 1。如果我们要使用步长为负数的切片，需要将起始位置和终止位置颠倒，并且将步长变成正数。"
  },
  
  {
    "title": "Python SyntacticSugar",
    "url": "/posts/5-syntactic_sugar/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:11 +0800",
    





    
    "snippet": "语法糖      列表推导式    列表推导式可以使用一行简洁的代码生成列表，格式为：    [expression for item in iterable]        其中，expression 是需要生成的元素表达式，item 是可迭代对象中的元素，iterable 是可迭代对象。例如，要生成一个包含 1 到 10 的平方的列表，可以使用以下代码：    squares = [x*...",
    "content": "语法糖      列表推导式    列表推导式可以使用一行简洁的代码生成列表，格式为：    [expression for item in iterable]        其中，expression 是需要生成的元素表达式，item 是可迭代对象中的元素，iterable 是可迭代对象。例如，要生成一个包含 1 到 10 的平方的列表，可以使用以下代码：    squares = [x**2 for x in range(1, 11)]print(squares)# 输出：[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]            字典推导式    字典推导式与列表推导式类似，可以使用一行代码生成字典，格式为：    {key_expression: value_expression for item in iterable}        其中，key_expression 和 value_expression 分别是键和值的表达式，item 是可迭代对象中的元素，iterable 是可迭代对象。例如，要生成一个字典，键为从 1 到 5，值为键的平方的字典，可以使用以下代码：    my_dict = {x: x**2 for x in range(1, 6)}print(my_dict)# 输出：{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}            装饰器（Decorator）    装饰器是一种用于装饰函数的语法糖，可以在函数定义前使用 @ 符号，将一个或多个函数“装饰”起来。装饰器本身是一个函数，接受一个函数作为参数并返回一个新的函数。    例如，假设有一个计算函数执行时间的装饰器：    import time  def time_it(func):    def wrapper(*args, **kwargs):        start = time.time()        result = func(*args, **kwargs)        end = time.time()        print(f\"{func.__name__} took {end - start:.6f} seconds\")        return result    return wrapper        这样，在需要计算函数执行时间的函数前加上 @time_it 即可：    @time_itdef my_function():   # some code here            with 语句    使用 with 语句可以让代码更加简洁，同时也可以自动关闭资源。with 语句的格式为：    with expression [as variable]:    with-block        其中，expression 是需要打开的资源对象，with-block 是需要执行的代码块，variable 是可选的变量名，用于存储 expression 返回的对象。例如，要打开一个文件并读取其中的内容，可以使用以下代码：    with open(\"myfile.txt\", \"r\") as f:    contents = f.read()print(contents)        不需要手动调用 f.close() 关闭文件，使用 with 语句后，当代码块执行完毕时，自动关闭文件。        Lambda 表达式    Lambda 表达式是一种匿名函数，可以在一行代码中定义一个函数。格式为：    lambda arguments: expression        其中，arguments 是函数的参数，expression 是函数的返回值表达式。例如，要定义一个将传入的数字加倍的函数，可以使用以下代码：    double = lambda x: x * 2print(double(4)) # 输出：8            map 函数    map 函数可以对一个可迭代对象中的所有元素应用一个函数，并返回一个新的可迭代对象，其中每个元素都是原可迭代对象中的元素经过该函数处理的结果。格式为：    map(function, iterable)        其中，function 是应用于每个元素的函数，iterable 是可迭代对象。例如，要将一个列表中的所有元素平方并返回一个新的列表，可以使用以下代码：    my_list = [1, 2, 3, 4, 5]squares = list(map(lambda x: x**2, my_list))print(squares) # 输出：[1, 4, 9, 16, 25]            filter 函数    filter 函数可以对一个可迭代对象中的所有元素应用一个布尔函数，并返回一个新的可迭代对象，其中仅包含原可迭代对象中满足该布尔函数的元素。格式为：    filter(function, iterable)        其中，function 是应用于每个元素的布尔函数，iterable 是可迭代对象。例如，要从一个列表中筛选出所有的偶数，可以使用以下代码：    my_list = [1, 2, 3, 4, 5]evens = list(filter(lambda x: x % 2 == 0, my_list))print(evens) # 输出：[2, 4]      "
  },
  
  {
    "title": "Python Interpreter",
    "url": "/posts/4-interpreter/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:11 +0800",
    





    
    "snippet": "调用解释器  Python解释器是执行Python代码的程序。它读取源代码，并将其转换为字节码形式，然后在运行时逐行解释和执行这些字节码指令。Python解释器还提供了一个交互式环境，称为Pythonshell，它允许用户在命令行界面中输入Python代码并立即查看其输出结果。  在Python中，有多个不同的解释器可供选择。其中最常用的是CPython，它是官方的Python解释器实现，由...",
    "content": "调用解释器  Python解释器是执行Python代码的程序。它读取源代码，并将其转换为字节码形式，然后在运行时逐行解释和执行这些字节码指令。Python解释器还提供了一个交互式环境，称为Pythonshell，它允许用户在命令行界面中输入Python代码并立即查看其输出结果。  在Python中，有多个不同的解释器可供选择。其中最常用的是CPython，它是官方的Python解释器实现，由C语言编写。CPython解释器支持大多数标准库和第三方库，并且可以在各种操作系统上运行  IDE，它支持多种Python解释器，并提供了许多功能，例如代码自动补全、调试工具和版本控制集成等。例子      打开Python解释器          要打开Python解释器，请在命令行中输入 python命令，并按下回车键。这将启动Python解释器，并显示一个交互式提示符（通常是 &gt;&gt;&gt;），表示您可以开始输入Python代码了。            运行脚本文件          如果您已经编写了一个Python脚本文件，可以使用以下命令在Python解释器中运行它：        python your_script.py                    这将调用Python解释器，并执行指定的脚本文件。            导入模块          Python解释器还允许您导入其他Python模块并使用它们。要导入模块，请使用以下语法：        import module_name              例如，要导入Python标准库中的 math 模块，请使用以下代码：        import math              然后，您就可以使用 math 模块提供的函数和常量。例如，要计算圆的面积，请使用以下代码：        radius = 2.5area = math.pi * radius ** 2            查看帮助文档          Python解释器还提供了一个内置的帮助系统，以便您查找函数和模块的文档。要查看帮助，请在Python解释器中使用以下语法：        help(function_or_module)              例如，要查看 math 模块中的 sqrt() 函数的帮助文档，请使用以下代码：        help(math.sqrt)        这将显示包含函数说明、参数列表和示例用法的文档。    这些技巧可以帮助您更好地打开和使用Python解释器。无论是在学习Python编程还是开发Python应用程序时，都会非常有用。  "
  },
  
  {
    "title": "Python UtilCmd",
    "url": "/posts/3-utilscmd/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:10 +0800",
    





    
    "snippet": "常用的工具命令      pip：Python 包管理器，可用于安装、升级和卸载 Python 模块。        virtualenv：虚拟环境管理器，可用于创建和管理 Python 虚拟环境，使不同项目的依赖包互不干扰。        pytest：用于编写和运行 Python 单元测试的工具，支持测试自动发现和参数化测试等功能。        pylint：Python 代码静态分析...",
    "content": "常用的工具命令      pip：Python 包管理器，可用于安装、升级和卸载 Python 模块。        virtualenv：虚拟环境管理器，可用于创建和管理 Python 虚拟环境，使不同项目的依赖包互不干扰。        pytest：用于编写和运行 Python 单元测试的工具，支持测试自动发现和参数化测试等功能。        pylint：Python 代码静态分析工具，可用于检查代码风格、格式、错误和一致性等问题。        autopep8：Python 代码格式化工具，可用于自动调整代码缩进、空格、引号和换行符等格式问题。        coverage：代码覆盖率工具，可用于确定代码中哪些部分被测试覆盖了，以及哪些部分需要更多测试。        Flask/Django/Pyramid：Python 网络应用框架，可用于快速构建 Web 应用程序。  使用示例      pip          安装模块：        pip install &lt;module_name&gt;                    升级模块：        pip install --upgrade &lt;module_name&gt;                    卸载模块：        pip uninstall &lt;module_name&gt;                    查看已安装的模块列表：        pip list                          virtualenv          创建虚拟环境：        python -m venv &lt;venv_name&gt;                    进入虚拟环境：        source &lt;venv_name&gt;/bin/activate                    退出虚拟环境：        deactivate                          pytest          运行单元测试：        pytest &lt;test_file_or_dir&gt;                    测试自动发现：        pytest --collect-only                    参数化测试：        import pytest@pytest.mark.parametrize(\"test_input, expected_output\",                         [(3, 6), ('hello', 'hellohello'), (2.5, 5)])def test_multiply_by_two(test_input, expected_output):    assert test_input * 2 == expected_output                          pylint          检查代码文件：        pylint &lt;file_name&gt;                    生成 HTML 报告：        pylint --output-format=html &lt;file_name&gt; &gt; report.html                    禁用特定错误或警告：        pylint --disable=&lt;error_code&gt; &lt;file_name&gt;                          autopep8          格式化 Python 文件：        autopep8 --in-place &lt;file_name&gt;                    格式化整个目录下所有 Python 文件：        autopep8 --in-place --recursive &lt;directory_name&gt;                          coverage          运行测试并生成覆盖率报告：        coverage run -m pytest &lt;test_file_or_dir&gt;coverage html                          Flask/Django/Pyramid          创建新项目：        django-admin startproject &lt;project_name&gt;flask init &lt;project_name&gt;pcreate --scaffold=alchemy &lt;project_name&gt;                    启动开发服务器：        python manage.py runserverflask runpserve development.ini                    "
  },
  
  {
    "title": "Python Install",
    "url": "/posts/2-install/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:09 +0800",
    





    
    "snippet": "python install  Mac  Linux  WindowsMac os方法一      打开 Python 官方网站（https://www.python.org/downloads/mac-osx/）。        在“Python releases for Mac OS X”部分中，选择适合您的 Mac 版本的 Python 安装程序。通常，您应该选择最新的稳定版本。   ...",
    "content": "python install  Mac  Linux  WindowsMac os方法一      打开 Python 官方网站（https://www.python.org/downloads/mac-osx/）。        在“Python releases for Mac OS X”部分中，选择适合您的 Mac 版本的 Python 安装程序。通常，您应该选择最新的稳定版本。        下载所选版本的 Python 安装程序。        双击下载的 .pkg 文件以开始安装过程。按照屏幕上的提示完成安装即可。    验证 Python 是否已成功安装。在终端中输入以下命令：     python3 --version              如果您看到类似于 Python 3.x.x 的输出，则表示 Python 已成功安装。            可选：使用虚拟环境。如果您想要使用虚拟环境，请按照上面提到的步骤创建和激活虚拟环境。    注意事项：    如果您已经通过 Homebrew 安装了 Python，则不建议使用二进制安装程序安装 Python，因为这可能会导致系统中存在多个 Python版本，并且它们可能会相互干扰。  在使用虚拟环境时，请确保激活正确的虚拟环境，否则可能会出现意外结果。方法二      打开终端（Terminal）应用程序。您可以在“应用程序”文件夹中找到它。        安装 Homebrew 是一个包管理器，可帮助您轻松地安装和更新软件包。在终端中输入以下命令：     /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"        使用 Homebrew 安装 Python。在终端中输入以下命令：     brew install python            验证 Python 是否已成功安装。在终端中输入以下命令：      python3 --version              如果您看到类似于 Python 3.x.x 的输出，则表示 Python 已成功安装。            可选：安装虚拟环境。虚拟环境可让您在同一台计算机上运行多个 Python 项目，而不会相互干扰。在终端中输入以下命令来安装virtualenv：     pip3 install virtualenv            可选：创建一个新的虚拟环境。在终端中输入以下命令来创建一个名为 myenv 的新虚拟环境：     virtualenv myenv            可选：激活虚拟环境。在终端中输入以下命令来激活刚才创建的虚拟环境：     source myenv/bin/activate        此时，您应该看到终端的命令提示符前面出现了 (myenv) 字样，表示虚拟环境已激活。  Linux方式一：使用包管理器安装大多数 Linux 发行版都提供了 Python 的预编译包，您可以使用包管理器直接从官方仓库中安装。以下是常见发行版的命令：Debian/Ubuntu：sudo apt-get updatesudo apt-get install python3CentOS/Fedora/RHEL：sudo yum install python3方式二：使用源代码编译安装      下载 Python 源码。您可以从 Python 官方网站（https://www.python.org/downloads/）下载最新版本的 Python 源代码。        解压源代码包。在终端中进入下载目录，并输入以下命令：     tar xf Python-3.x.x.tgz        其中，Python-3.x.x.tgz 是您下载的 Python 源代码包的文件名。        进入解压后的源代码目录。在终端中进入解压后的目录：     cd Python-3.x.x            配置编译选项。在终端中输入以下命令来配置编译选项：     ./configure --enable-optimizations --with-ensurepip=install        这条命令将启用一些优化选项，并安装 pip 工具。        编译源代码。在终端中输入以下命令以开始编译源代码：     make -j 2        这会使用 2 个 CPU 核心进行编译，以加快编译速度。如果您希望更快地编译代码，请将数字 2 更改为您计算机上可用的 CPU 核心数。        安装 Python。在终端中输入以下命令以将 Python 安装到默认位置：     sudo make altinstall        如果您希望将 Python 安装到不同的位置，请使用以下命令：     sudo make altinstall prefix=/path/to/install        其中，/path/to/install 是您希望安装 Python 的路径。        验证 Python 是否已成功安装。在终端中输入以下命令：     python3 --version        如果您看到类似于 Python 3.x.x 的输出，则表示 Python 已成功安装。  Windows方式一：使用官方安装程序      访问 Python 官方网站（https://www.python.org/downloads/windows/）。        在“Stable Releases”栏目中，选择最新版本的 Python 安装程序。通常，您应该选择和您的操作系统位数相同的版本（例如，32 位或 64位）。        下载所选版本的 Python 安装程序。        双击下载的 .exe 文件以开始安装过程。按照屏幕上的提示完成安装即可。        验证 Python 是否已成功安装。在命令提示符窗口中输入以下命令：     python --version        如果您看到类似于 Python 3.x.x 的输出，则表示 Python 已成功安装。  方式二：使用包管理器进行安装      安装 Chocolatey 包管理器。Chocolatey 是一个 Windows 平台的包管理器，可帮助您轻松地安装和更新软件包。在管理员权限的Powershell 窗口中输入以下命令：     Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))            使用 Chocolatey 安装 Python。在管理员权限的 Powershell 窗口中输入以下命令：     choco install python            验证 Python 是否已成功安装。在命令提示符窗口中输入以下命令：     python --version        如果您看到类似于 Python 3.x.x 的输出，则表示 Python 已成功安装。  "
  },
  
  {
    "title": "Python Base",
    "url": "/posts/1-base/",
    "categories": "Language, Python",
    "tags": "Server, Python, Python Base",
    "date": "2022-05-24 10:00:08 +0800",
    





    
    "snippet": "简介  Python是一种高级编程语言，于1991年由Guido van Rossum创建。它的设计理念是强调可读性、代码简洁、易于维护和扩展，这使得Python在许多领域得到了广泛应用。  作为一种解释型语言，Python不需要像C或Java这样的编译程序来将代码转换为机器语言，而是直接在运行时解释代码。这使得Python具有一些显著的优点，例如快速开发原型、交互式编程和动态类型。  Py...",
    "content": "简介  Python是一种高级编程语言，于1991年由Guido van Rossum创建。它的设计理念是强调可读性、代码简洁、易于维护和扩展，这使得Python在许多领域得到了广泛应用。  作为一种解释型语言，Python不需要像C或Java这样的编译程序来将代码转换为机器语言，而是直接在运行时解释代码。这使得Python具有一些显著的优点，例如快速开发原型、交互式编程和动态类型。  Python支持多种编程范式，包括面向对象、函数式、过程式编程等。同时，它也具有一些独特的特性，比如自带垃圾回收、动态内存管理、异常处理等。  Python的标准库非常丰富，涵盖了各种领域，包括文件I/O、网络编程、数据库连接、图形用户界面开发等。此外，还有许多流行的第三方库和框架，如NumPy、SciPy、Pandas、Django、Flask等，使得Python成为数据科学、Web开发、人工智能等领域最受欢迎的语言之一。官方地址  Python 教程  语言参考手册  标准库学习版本选择  如果您要学习 Python，首先需要确定使用的 Python 版本。目前，Python 有两个主要版本：Python 2 和 Python 3，但是 Python 2 已于2020 年停止支持，因此建议选择 Python 3。  在 Python 3 中，有许多不同的版本可供选择。最新的版本是 Python 3.10，它包含了很多新特性和改进。然而，在某些情况下，您可能需要使用旧版Python，因为某些库或框架可能不支持最新版本的 Python。这就是为什么很多人仍然在使用 Python 3.7 或 Python 3.8。  由于 Python 的版本升级较频繁，不同版本之间也存在一些差异。因此，您需要根据自己的需求来选择适合自己的 Python 版本。  当您确定了要使用的 Python 版本后，可以从 Python 官方网站上下载相应版本的 Python安装程序。安装过程非常简单，只需按照提示进行即可。学习路线      入门阶段：了解 Python 的基础语法、数据类型、流程控制语句和函数等，建议通过阅读教材、视频教程或参加培训班进行学习。        进阶阶段：深入学习 Python 的标准库和第三方库，掌握常用的数据结构和算法，熟悉 Python编程中的常见问题和技巧。建议通过实际编程练习、阅读优秀代码和参与开源项目等方式提高自己的编程能力。        实践阶段：应用 Python 解决实际问题，例如爬虫、数据分析、机器学习、Web 开发、游戏开发等领域，建议尝试挑战一些小型项目或参与开源项目，获取更多实践经验。  在学习 Python 的过程中，可以使用一些工具和资源来辅助学习，例如：      Python 解释器和 IDE：可以选择官方的 CPython 解释器和 PyCharm、VS Code 等集成开发环境。        在线资源：可以使用 Python 官网、Stack Overflow、GitHub、博客等在线资源获取学习资料和交流经验。        社区活动：可以参加本地 Python 用户组、线上技术分享、编程比赛等社区活动，与其他 Python 开发者互动和交流。  方法      入门教程: 开始学习 Python 最好的地方是通过入门教程。Python 官网提供了一个非常好的入门教程，名为 “Python 教程”。您可以在此处：https://docs.python.org/3/tutorial/index.html 找到它。        练习题: 在您了解基础知识后，可以尝试做一些练习题来巩固所学内容。例如，LeetCode、HackerRank 和 Codewars 等编程挑战网站都有Python 相关的练习。        系统学习: 除了入门教程外，还有很多优秀的 Python 学习资源。例如，在 Codecademy 上，你可以找到一个完整的 Python 学习路径。Udacity 和 Coursera 等在线课程平台也有很多 Python 学习资源。        实践项目: 学习语言最好的方法就是使用它创建实际项目。这将帮助你深入了解 Python 并提高你的编程技能。您可以从构建简单的Web 应用程序或计算机游戏开始，并逐步增加您的项目难度。  学习推荐（书籍….）  书籍：          《Python编程：从入门到实践》（Eric Matthes 著）      《流畅的Python》（Luciano Ramalho 著）      《Python核心编程》（Wesley Chun 著）      《Python Cookbook》（David Beazley 和 Brian K. Jones 著）        网址：          Python 官方文档      Codecademy Python 课程      w3schools Python 教程      Python 中文社区      "
  },
  
  {
    "title": "DataStructure（02142）",
    "url": "/posts/DataStructure/",
    "categories": "Cc, SelfStudy, ComputerBasics",
    "tags": "SelfStudy",
    "date": "2022-03-31 21:19:55 +0800",
    





    
    "snippet": "数据结构导论（02142）第一章 概论（重点）1 引言  数据结构：是计算机组织数据和存储数据的方式  计算机解决问题步骤          建立数学模型      设计算法      编程实现算法        程序=数据结构+算法  通常操作：查找、读取、插入、删除、更新  合理的数据结构有什么用          可降低程序设计的复杂性      提高程序的执行效率      2 基本...",
    "content": "数据结构导论（02142）第一章 概论（重点）1 引言  数据结构：是计算机组织数据和存储数据的方式  计算机解决问题步骤          建立数学模型      设计算法      编程实现算法        程序=数据结构+算法  通常操作：查找、读取、插入、删除、更新  合理的数据结构有什么用          可降低程序设计的复杂性      提高程序的执行效率      2 基本概念和术语  数据：所有被计算机存储、处理的的对象  数据元素：是数据这个集合的一个个体积数据的基本单位      数据项：数据元素常常分为若干个数据项，是数据的具有意义的最小单位          数据-&gt;数据元素-&gt;数据项        逻辑结构：元素之间的结构关系（集合、线性、树形、图结构）线性和非线性          线性结构：除第一个和最后一个数据元素外，每个数据元素只有一个前驱和一个后继数据元素      树结构：除根结点外，每个数据元素只有一个前驱数据元素，可有 0 个或若干个后继数据元素。      图结构：每个数据元素可有 0 个或若干个前驱数据元素和 0 个或若干个后继数据元素。      集合结构：数据元素同”属于一个集合”之间没有任何联系。        物理结构：存储结构（顺序、链式、索引、散列），数据在计算机内的表示称为数据的存储结构          存储结点      数据元素之间关联方式的表示      分类                  顺序存储结构：借助数据元素的相对存储位置来表示数据的逻辑结构；                          线性表的顺序存储方法：将表中的结点一次存放在计算机内存中一组连续的存储单元中                                链式存储结构：借助数据元素地址的指针表示数据的逻辑结构。          索引存储结构：借助索引表中的索引指示各存储节点的存储位置。          散列存储结构：用散列函数指示各节点的存储位置。                      运算：在逻辑结构上施加的操作，逻辑结构加工  加工型运算：操作改变原逻辑结构的值  引用型运算：不改变原有逻辑结构的值（查找、读取、插入、删除、更新）算法及描述  算法 规定了求解给定类型问题，所需的所有 处理步骤 及 执行顺序 是给定类型问题能在有限时间内被机械的求解  算法特性（对特定问题求解步骤的描述，他是指令的有穷序列）          有穷性：在执行有穷步后结束      确定性：每一步必须明确地定义      可行性：每一步都可以同步已经实现的操作完成      输入：可以零个或多个输入      输出：一个或多个输出（特定关系的量）      4 算法分析  算法设计满足          正确性：对于合法输入产生符合要求的输出      可读性：易读、添加注释      健壮性：非法输入是，能够作出反应而不会崩溃      效率高切内存消耗小：运行时间短，储存制算法执行过程中所需的最大内存空间        算法时空性：时间复杂度、空间复杂度；目的提高算法的效率  考虑两个度量分析          时间复杂度：运行时需要的总步数，通常时问题规模的函数（大 O 表示）                  常数 O(1)＜ 对数阶 O(log2n) ＜ 线性阶 O(n) ＜ 线性对数阶 O(nlog2n) ＜ 平方阶 O(n^2) ＜ 多项式阶 O(n^C) ＜ 指数阶 O(C^n)          时间复杂度分析基本策略：从内向外分析，从最深层开始分析          看有几层循环，一层循环是 O(n)或者 O(log2n)；两层循环是 O(n^2) ；三层循环是 O(n^3) （一般规律如此，具体问题具体分析）                    空间复杂度：执行时所占用的储存空间，通常时问题规模的函数,运行过程中临时占用存储空间大小的度量                  程序代码所占用的空间          输入数据所占用的空间          辅助变量 所占用的空间（估算时间复杂度，一般值分析辅助变量所占用的空间)                    5 小结第二章 线性表（重点）1 线性表的基本概念  线性表是有 n(n&gt;=0)个数据元素（结点）组成的有限序列          n 定义长度，n=0 称为空表      非空（n&gt;0）      数据元素（1&lt;=i&lt;=n）      1:1 的关系        非空的线性表          有且仅有一个起始结点 a1 ,没有直接前驱，有且仅有一个直接后继 a2；      有且仅有一个终端结点 an，没有直接后继，有且仅有一个直接前驱 an−1；      其余的内部结点 ai（2≤i≤n-1）都有且仅有一个直接前驱 ai−1 和一个直接后继 ai+1        线性表的基本运算：初始化、求表长度、取表元、定位、插入、删除（区分引用和加工型操作）2 线性表的顺序存储  定义：顺序表是线性表的顺序存储结构，一段连续内存存放的线性表  特点          顺序表是用 一维数组实现 线性表，数组下标是元素相对地址      逻辑上相邻元素，在存储物理位置也是相邻的 单元中      线性表的逻辑结构 与 存储结构一致      可以对数据元素实现随机读取        存储地址计算          每个结点类型相同、占用存储空间大小相同      例如结点占用 L 个存储单元，其中第一个单元存储地址则是该结点的存储地址      设表开始结点 a1 的存储地址 d，结点 ai 的存储地址为LOC(ai) 公式：LOC(ai) = d+(i−1)*L （必考）            顺序表插入运算          当表空间已满，不可在插入操作      插入位置非法，不可正常插入操作      插入新的结点 x，插入位置 i=n+1 时，才无需移动结点，直接将 x 插入表的末尾      长度变为 n+1      需要移动 n-i+1              元素平均移动次数 n/2 时间复杂度 O(n)        void InsertSeqList( Seqlist *L DataType x int i ){  int j;  if ( i &lt; 1 || i &gt; L.length + 1 )        exit( \"位置 错 误\" );  if ( L.length == MaxSize )        exit( \"溢出\" );  for ( j = L.length - 1; j &gt;= i; j-- )        L.data[j] = L.data[j - 1];      /* 依次后移   L.data[ i-1] = x; */  L.length++;}                          删除操作运算          只需要删除终端结点，无需移动结点      长度-1      需要移动n-i+1              元素平均移动次数 n-1/2 时间复杂度 O(n)        void DeleteSeqList( SeqList *L, int i ){  int j;    if ( i &lt; 1 || i &gt; L.length )    Error( \" 位置 错 误 \" );  for ( j = i; j &lt; L.length; j++ )    L.data[j - 1] = L.data[j];  L.length--;}                      优点          无需表示该的单元的逻辑关系增加额外存储空间      方便的随机取表任意结点        缺点          插入删除运算不方便，必须移动大大量的结点      顺序表要求占用连续的存储空间，需要预先分配内存，表长变化较大是，难以确定合适储存规模      3 线性表的链接存储  线性表的链式存储值存储结构是链式的，常见的有（单链表、循环链表、双向链表）  存储表示          用一组内存的存储单元存放      链表中结点的逻辑次序和物理次序不一定相同，必须存储指示后续结点地址信息      date 数据域      next 存放即诶单直接后继的地址（位置）的指针域（链域）      NULL 空指针^      head 头指针变量，存放链表中第一个结点地址            单链表：(Head|exit)-&gt;(k|^)                  插入运算（ai-1~ai）                  找到 ai-1（p） 存储 x          生成 x          p 指针域指向 x，然后插入 x                      x 结点指针域指向 ai            void InsertLinkList( LinkList head, Data x, int i )     /* 在表中head的第i个数据元素结点之前插入一个以X为值的新结点。 */{  Node *p, *q;  if ( i == 1 )    q = head;  else q = GetLinkList( head, i - 1 );            /* 找第i-1个数据元素结点 */  if ( q == NULL )                                /* 第i-1个结点不存在 */    exit( \" 找到 插入位置 \" );  else{ p  = malloc( sizeof(Node) );       /* 生成新结点 */        p-&gt;data = x;                            /* 生成新结点指向X */        p-&gt;next = q-&gt;next;                      /* 新结点链域指向*q的后继结点 */  1        q-&gt;next = p;                            /* 修改*q的链域 */              2  }}// 特别要注意：上面1和2二行代码不可颠倒顺序，否则*q链先断了会找不到。                                                  删除运算                  找到 i-1 结点，存在继续，否则结束                      删除 i 结点，释放对应的内存            void DeleteLinkList( LinkList head, int i ){  Node *q;  if ( i == 1 )    p = head;  else p = GetLinkList( head, i - 1 );    /* 先找待删结点的直接前驱 */  if ( p ！ = NULL &amp;&amp; p-&gt;next != NULL )  {    q = p-&gt;next;              /* P指向待删结点 */    p-&gt;next = q-&gt;next;              /* 移出待删结点 */    free( q );                      /* 释放已移出结点P的空间 */  }  else printf( \" error \" );}                                          4、5 其它运算在单链表的实现、其他链表  单向循环链表：如果第一个结点指针域指向第一个结点构成循环，任意结点出发都能够扫描整个链表          普通链表的终端结点next只为NULL      循环链表终端结点next指向头结点      导致循环链表中结点只有一个指针            双向循环链表          链表中有两个指针域：一个指向后继结点、一个指向前驱结点（双向链表）      Prior | date | next      头 prior 指向最后一个结点，最后一个结点 next 指向头结点              删除        q  = p-&gt;next;p-&gt;next  = p-&gt;next-&gt;next;p-&gt;next-&gt;prior = p;free( q );                            插入        t-&gt;prior = p;t-&gt;next  = p-&gt;next;p-&gt;next-&gt;prior = t;p-&gt;next  = t;                    6 顺序实现与链式实现的比较  存储密度 = 数据域占用存储量/整个存储节点占用存储量            时间复杂度      顺序表      链表                  读      O(1)      O(n)              找      O(n)      O(n)              插      O(n)      O(n)              删      O(n)      O(n)      7 小结            基于空间考虑      顺序表      链表                  分配方式      静态分配      动态分配              存储密度      1      &lt;1        分配方式          顺序表：静态分配                  程序执行之前必须明确规定存储规模。          若线性表长度 n 变化较大，则存诸规模难于预先确定估计过大将造成空间浪费，          估计太小又将使空间溢出机会增多                    链表：动态分配                  只要内存空间尚有空闲，就不会产生溢出          当线性表的长度变化较大          难以估计其存储规模时，以采用动态链表作为存储结构为好                      存储密度          顺序表:1                  当线性表的长度变化不大，易于事先确定其大小时          为了节约存储空间，宜采用顺序表作为存储结构                    链表：&lt; 1                  存储密度是指一个结点数据本身所占的存储空间和整个结点所占的存储空间之比，假设单链表一个结点本身所占的空间为 D，指针域所占的空间为 N，则存储密度为：D/(D+N)，一定小于 1                    第三章 栈、队列和数组（重点）  栈和队列何以看作特殊的线性表1 栈  定义：栈只能在表一端(表尾)进行插入和删除的线性表          允许插入删除一端(尾部)称为栈顶(top),另一端表头称为栈底(bottom)      表中没有元素称空栈        特点          进栈push;出栈pop删除      先进先出 (LIFO)      用途：常用于暂时保存待有处理的数据        顺序栈：是一组连续的存储单元一次放栈中的每个元素(初始端为栈低)  链式栈：链式存储,运算受限单链表,插入删除受限表头位置上进行栈顶指针就是链表的头指针2 队列(Queue)  定义: 是一种运算受限的线性表，只允许一端插入在另一端删除          允许删除的一端为队头(front),允许插入的一端为队尾(rear)        特点          先进先出 (FIFO)      用途：常用于暂时保存待有处理的数据        实现方式          顺序实现：顺序存储,由一个一维数组(存储元素)                  循环队列                          上溢条件：sq.rear=-maxsize-1(队满)              下溢条件：sq.rear==sq.front(队列空)              假溢出：极端情况会出现上溢,为了客服假溢出引入循环队列              头尾连接              插入：rear=(sq.rear+1)%maxsize              删除：front=(sq.front+1)%maxsize              下溢-队空：CQ.front==CQ.rear              上溢-队满：(CQ.rear+1)%maxsize==CQ.front                                          链接实现                  使用一个带有头结点的单链表来表示队列          头结点 exit 域指向队列首结点,尾指针指向队列尾结点                    3 数组、应用  数组可以看成一种特殊的线性表，顺序存储；每一个元素值和一个下表组成,一般具有上界下界  数组          定义                  一维内存单元连续(又称向量)          二维存储方式两种                          列序为主              主序为主(C 语言)                                随机存取结构                    读写:给一定下标读取和修改元素      寻址公式                  例如，二维数组 Amn 按”行优先顺序”存储在内存中，假设每个元素占用 k 个存储单元。元素 aij 的存储地址应是数组的基地址加上排在 aij 前面的元素所占用的单元数。因为 aij 位于第 i 行、第 j 列，前面 i 行一共有 i×n 个元素，第 i 行上 aij 前面又有 j 个元素，故它前面一共有 i×n+j 个元素，因此，aij 的地址计算函数为：LOC(aij)=LOC(a00)+(i*n+j)*k                      矩阵的压缩存储          矩阵是一种常用的数据对象,来描述一个二维数组      矩阵存储下进行元素随机存储      存储密度为 1      矩阵中零元素存在大量的零元素,队矩阵造成极大的浪费,为了节省空间,对矩阵进行压缩存储      压缩存储:即多个相同元素的非零只分配一个存储空间,对零元素不分配空间      特殊矩阵压缩分类                  对称矩阵          三角矩阵(上三角、下三角)                    稀疏矩阵      4 小结第四章树和二叉树（重、难点）  非线性结构  1:N 关系1 树的基本概念  概念          定义：是 n(n&gt;=0)个结点有限集      有且仅有一个特定的称为根结点      其余结点可分为 m(m&gt;=0)个互相不交集的子集,其中每个子集有是一颗树,并称其为子树      递归是树的固有特性      逻辑表示                  直观表示          嵌套括号法          凹入表示法                      相关术语          结点：由一个元素及若干个指向其他结点的分支所组成      度                  结点的度：该结点子树数(分支)          树的度：树中结点的度最大值                    叶子(终端结点)：度为零的结点      非终端结点：度不为零的结点      结点层次：从根开始算起,根为第一层      树的高度：所有结点层次树的最大值称该树的高度或深度      有序树：左右不能互换,有次序,最左子树的根称第一个孩子      无序树：各个结点的子树是无序的,可以互换      森林：m(&gt;=0)课树的集合      结点和边的关系：n 个结点的树,共有 n-1 条边      2 二叉树  任何一棵树都可以与二叉树相互转换  定义          二叉树是 n（n&gt;=0）个结点有限集合，或空（n=0）      每课子树都是二叉树        特点          二叉树可以是空，称空二叉树      每个结点最多是两个孩子      子树有左，右，之分次序不能颠倒            与树的比较                                       结点          子树          结点顺序                                      树          n&gt;=0          不定（有限）          无                          二叉树          n&gt;=0          &lt;=2          有（左、右）                          二叉树的性质          在二叉树的第 i(i&gt;=1)层上至多有 2i-1 个结点。(i&gt;=1)；至少 1 个      深度为 k(k&gt;=1) 的二叉树至多有 2k－1 个结点；至少 K 个      对任何一棵二叉树，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0 ＝ n2 ＋ 1。即：叶结点数 n0=度为 2 的结点数 n2+1              下图其中度为 2 的结点数共有 5 个，即 ABCEF（有 2 个孩子的，如 G 就不是），叶子共有 6 个，即 IJKLMH(没有结点，度为 0 的)，得出这二叉树终端结点数=度为 2 的结点数+1，即 6=5+1        graph TB;A((A))B((B))C((C))E((E))F((F))G((G))H((H))I((I))J((J))K((K))L((L))M((M))A--&gt;BA--&gt;CB--&gt;EB--&gt;FE--&gt;IE--&gt;JC--&gt;GG--&gt;MF--&gt;KF--&gt;LC--&gt;H                    满二叉树:深度为 k(k&gt;=1)且有2^k-1个结点的二叉树；下图满二叉树结点 2^3-1=7        graph TB;1((1))2((2))3((3))4((4))5((5))6((6))7((7))1--&gt;21--&gt;32--&gt;42--&gt;53--&gt;63--&gt;7            完全二叉树:深度为 K 的二叉树中，K-1 层结点数是满的(2k-2)，K 层结点是左连续的(即结点编号是连续的)      满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树过      3 二叉树的存储结构  顺序存储          一组连续的存储单元存储      必须把二叉树所有结点安排一个恰当的序列      对二叉树进行编号，然后用一维数组存储，其中编号为 i 的结点存储在数组中的下标为 i 对的分量中–称为以编号为地址策略      树从根起，自上层至下层，每层子左至右给所有结点编号                  缺点对存储空间造成极大的浪费（深度为 H 且只有 H 个结点右单只树需要 2^h-1 个结点存储空间）          若经常需要插入删除树中结点是，顺序方式不是很好                      链式存储          画二叉链 必考      4 二叉树的遍历  遍历二叉树：二叉树是非线性的，因而需要寻找一种规律（或次序），能把二叉树上的各结点都访问一次且只访问一次  遍历规则          D-根；L-左；R-右        graph TB;  A((根节点 D))  B((左子树 L))  C((右子树 R))  A--&gt;B  A--&gt;C      遍历分类          例子        graph TB;A((A))B((B))C((C))D((D))E((E))F((F))G((G))H((H))I((I))J((J))K((K))nil((nil))nille((nil))A--&gt;BA--&gt;CB--&gt;DB--&gt;EE--&gt;nilleE--&gt;ID--&gt;nilD--&gt;HC--&gt;GC--&gt;FF--&gt;JF--&gt;K                  先序遍历(DLR)-根左右 A-&gt;B-&gt;D-&gt;H-&gt;E-&gt;I-&gt;C-&gt;F-&gt;J-&gt;K-&gt;G                  根-&gt;左-&gt;右 首先访问根结点，其次便利根的左子树，最后遍历根右子树，对每棵子树同样操作                  void   preorder( bitreptr r )  {    /*先序遍历以r为根的二叉树*/    if ( r == NULL )      return;    printf( r-&gt;data );         /*访问根结点*/    preorder( r-&gt;lchild ) ；    preorder( r-&gt;rchild );    /*先序遍历以r的右孩子为根的右子树*/  };                            中序遍历(LDR)-左根右 D-&gt;H-&gt;B-&gt;E-&gt;I-&gt;A-&gt;J-&gt;F-&gt;K-&gt;C-&gt;G                  左-&gt;根-&gt;右 首先遍历根的左子树，其次访问根节点，最后遍历右子树                  void   inorder( bitreptr r )  {    /*中序遍历以r为根的二叉树*/    if ( r == NULL )      return;    inorder( r-&gt;lchild ) ；    /*中序遍历以r的左孩子为根的左子树*/    printf( r-&gt;data );              /*访问根结点*/    inorder( r-&gt;rchild );           /*…….*/  }                            后序遍历(LRD)-左右根 H-&gt;D-&gt;I-&gt;E-&gt;B-&gt;J-&gt;K-&gt;F-&gt;G-&gt;C-&gt;A                  左-&gt;右-&gt;根 首先遍历根的左子树，其次访问右子树，最后访问根节点                  void   postorder( bitreptr r )  {    /*后序遍历以r为根的二叉树*/    if ( r == NULL )      return;    postorder( r-&gt;lchild ) ；    /*后序遍历以r的左孩子为根的左子树*/    postorder( r-&gt;rchild ) ；    printf( r-&gt;data );       /*访问根结点*/  }                    5 树和森林  树的存储结构          孩子链表表示法：child|next                  child：存放孩子结点在表头数组中的序号          exit：指向下一个孩子结点                                                                孩子兄弟链表示法（二叉链表表示）（son              data              brother）                                                son：指向第一个孩子结点          brother：指向该结点的下一个兄弟结点                    双亲表示法        树、森林、二叉树 之间转换          树-&gt;二叉树                  各兄弟之间加连线          对任一结点，除最左孩子，抹掉该结点与其余孩子的各枝          以根为轴心，将连线顺指针转 45 度                    森林-&gt;二叉树                  将每棵树转换成相应的二叉树          将（1）中得到的各颗二叉树的根结点看做是兄弟链接起来                    二叉树-&gt;一般树                  从根结点起          该结点左孩子和左孩子右枝上的结点一次作为该结点孩子          重复（1）                          树和森的遍历                  树                  先序遍历：先序先访问根结点，然后一次先序遍历根的每A-&gt;B-&gt;C-&gt;D-&gt;E          后序遍历：先依次后续遍历每棵子树，最后访问根结点B-&gt;D-&gt;C-&gt;E-&gt;A          层次遍历：遍历每个兄弟结点A-&gt;B-&gt;C-&gt;E-&gt;D                graph TB;A((A))B((B))C((C))D((D))E((E))A--&gt;BA--&gt;CA--&gt;EC--&gt;D                    森林的遍历                  先序：访问森林中每棵树的根结点；先序遍历森林中第一棵树的根结点的子树组成的森林；先序遍历除去第一棵树之外其余的树组成的森林。          中序：中序访问森林中第一棵树的根结点的子树组成的森林；访问第一棵树的根结点；中序遍历除去第一棵树之外其余的树组成的森林；                    6 判定树和哈夫曼树  解题思路：先求哈夫曼树，再求哈夫曼编码          求哈夫曼树的口诀                  构造森林全是根          选用两小造新树          删除两小添新人          重复，2，3 剩单根                    7 小结第五章 图（重点）  邻接矩阵 、邻接表存储结构；深度优先和广度优先；求最小生成树的 prim 算法1 图的基本概念      图的定义          图 G：是有集合 V 合成 E 组成，记成 G=(V,E)                  v：顶点集（非空）          E：边集（可空），可只有顶点，没边                    边是顶点的有序对或无序对（反映两点之间的关系）                  有向图：边顶点有序对的图（用箭头指明方向）          无向同：边是顶点的无序对的图                    网状结构（比线性（线性表）、层次（图））更复杂，多对多(N:N)      注意：                  集合可空          边集中不允许出现相同的边                          基本术语          顶点（Vertex）：图中的数据元素      &lt;Vi,Vj&gt;：有向图中，顶点 Vi 到顶点 Vj 的边，也成弧                  弧头（终端点）箭头端          弧尾（初始点）无箭头端                    完全图（顶点数 n）                  无向完全图：边数=n*(n-1)/2的无向图          有向完全图：边数=n*(n-1)的有向图                    权：与图中的边相关的数      子图：图 G 和 G′,若有 V(G′)∈=V(G)和 E(G′)∈=E(G),则称 G′为图 G 的子图      邻接：若(Vi,Vj)∈E(G)，则称 Vi 和 Vj 互为邻接点      关联：若(Vi,Vj)∈E(G)，则称边(Vi,Vj)关联于顶点 Vi 和 Vj;                  注意                          邻接是指顶点之间的关系，而关联是指边与顶点间的关系              若弧&lt;Vi,Vj&gt;∈E(G)，则称 Vj 是 Vi 的邻接点                                          度                  无向图：顶点 Vi 的度为与 Vi 相关联的边的个数；D(Vi)用（ ）表示          有向图用&lt; &gt;表示                          出度：顶点 Vi 的出度为以 Vi 为尾的出边数              入度：顶点 Vi 的入度为以 Vi 为头的入边数              度：有向图的度=入度+出度                                一边带二度，两度组一边                    路径：顶点 Vp 至顶点 Vq 的路径是顶点序列      路径长度：路径上边或弧的数目      简单路径：除第一个和最后一个外，其余的各个顶点均不相同的路径      回路：第一个和最后一个顶点相同的路径（也称环）      简单回路：第一个和最后一个顶点相同的简单路径                  回路中可以有多个圈，而简单回路只能有一个圈                    连通：无向图中，若从顶点 Vi 到 Vj 顶点有路径，则称 Vi 和 Vj 是连通的      连通图和连同分量（针对无向图而言）      生成树：含有该连通图的全部顶点的一个极小连通子图。若连通图 G 的顶点个数为 n，则 G 的生成树的变数为 n-1                  边&gt;n-1，一定有环          边&lt;n-1，一定不连同                    生成森林：在非连通图中，每个连通分量都可得到一个极小连通子图，也就是生成树。这些生成树就组成了一个非连通图的生成森林。      基本运算                  建立图 GreateGraph(G,V,E)          取顶点信息 Getvex(G,u)          取边信息 Getarc(G,u,v)          查询第一个邻接点 FirstVex(G,u)          查询下一个邻接点 NextVex(G,u,v)          插入顶点 InsertVex(G,v)          删除顶点 DeleteVex(G,v)          插入边 InsertArc(G,v,w)          删除边 DeleteArc(G,v,w)          遍历图 Travers(G,tag)                    2 图的存储结构  没有顺序存储结构，可以借助二维数组表示，也叫做邻接矩阵；共有邻接矩阵，邻接表，十字链表，邻接多重等存储结构….      邻接矩阵表示法（也叫二维数组）                  图的邻接矩阵：表示图的各顶点之间关系的矩阵                              表示方法                          有边 1 表示              无边 0 表示              实例：脑补无向图（1-2，1-3，1-4，2-3，3-4）                              1,2,3,4    1[0,1,1,1]    2[1,0,1,0]    3[1,1,0,1]    4[1,0,1,0]                                无向图的邻接矩阵是对称的          从邻接矩阵容易判断任意两顶点间是否有边相联；容易求出各顶点的度          无向图：顶点 Vi 的度 D(Vi)=矩阵中第 i 行的 1 总和          有向图：OD(Vi)=矩阵中第 i 行的 1 总和，I D(Vi)=矩阵中第 i 列的 1 总和                            带权图(网)的邻接矩阵                  有 n 个结点，对应就会有 n*n 的方阵                          邻接表示法（连式）          n 个顶点、e 条边的无向图，则其邻接表的表头结点数为 n，链表结点总数为 2e；      对于无向图，第 i 个链表的结点数为顶点 Vi 的度；      对于有向图，第 i 个链表的结点数为顶点 Vi 的出度；      在边稀疏时，邻接表比邻接矩阵省单元；      邻接表表示在检测边数方面比邻接矩阵表示效率要高。      3 图的遍历  从图 G 的某一顶点 V 出发，顺序访问各顶点一次      方法：为了克服顶点的重复访问，设立辅助数组（visited[n]）    visted[i]=\\left\\{\\begin{aligned}1=&amp;顶点i已被访问过 \\\\0=&amp;顶点i未被访问过\\\\\\end{aligned}\\right.        遍历分类                  深度优先搜索发（DFS）必考                          为克服顶点的重复访问，设立一标识向量 visited[n] - 图可用邻接矩阵或邻接表表示          DFS 规则具有递归性，故需用到栈          搜索到达某个顶点时(图中仍有顶点未被访问)，如果这个顶点的所有邻接点都被访问过，那么搜索就要回到前一个被访问过的顶点，再从该顶点的下一未被访问的邻接点开始深度优先搜索。          深度搜索的顶点的访问序列不是唯一的                    广度优先搜索发（BFS）考点                  类似于树的层次遍历的过程（遍历所有的兄弟结点）          过程：中某一点 Vi 出发，首先访问 Vi 的所有邻接点（w1，w2，…，wt），然后再顺序访问 w1，w2，…，wt 的 所有未被访问过的邻接点…., 此过程直到所有顶点都被访问过          图可用邻接矩阵或邻接表表示          顶点的处理次序——先进先出，故需用到队列          思想                          所有结点标记置为”未被访问”标志；              访问起始顶点，同时置起始顶点”已访问”标记；              将起始顶点进队列              当队列不为空时重复执行以下步骤；                                  取当前队头顶点；                  对与队头顶点相邻接的所有未被访问过的顶点依次做：                                          访问该顶点                      置该顶点为”已访问”标记,并将它进队列；                                                        当前队头元素顶点出队；                  重复进行，直到队空时结束。                                                                        求图的连通分量                  判断连通性：调用一次 DFS 或 BFS 得到一顶点集合之后与 V(G)比较，若两集合相等，则图 G 是连通图，否则不连通          求图的连通分量：图遍历的一种应用                    4 图的应用      最小生成树：连通图 G=(V,E)，从任一顶点遍历，则图中边分成两部分：E(G) = T(G)+ B(G)          T(G):遍历通过的边      B(G):剩下的边（即遍历时未通过的边）        深度优先生成树：按照深度优先遍历而生成的树  广度优先生成树：按照广度优先遍历而生成的树  图的生成树不是唯一的  最小生成树也不是唯一的  最小生成树：给一个带权图，构造带权图的一颗生成树，使树中所有边权总和为最小      最小生成树的构造算法          Prim 算法：适用于稠密最小生成树      Kruskal 算法：构造的最小生成树不唯一，但权和相同，适合与求边稀疏的网的最小生成树            拓扑排序：拓扑有序序列的构造过程称          AOV 网：对 AOV 网构造顶点线性序列（…i,…,k,…j,…）i 是 j 的前趋，则 i 在 j 之前，若 i、k 间无路径，则或 i 在 k 前，或 k 在 i 前。这样的线性序列称为拓扑有序序列      拓扑排序算法：避免重复查找，可将入度为 0 的顶点入度域串链成一个链式栈                  将全体入度为 0 的顶点入栈；          链栈非空时，反复执行：                          弹出栈顶元素 Vj 并将其输出；              检查 Vj 的出边表，将每条出边（Vj，Vk）的终点 Vk 的入度域减 1；              若 Vk 的入度为 0，则 Vk 入栈。                                若输出的顶点数小于 N，则输出有回路；否则，拓扑排序结束。                    5 小结第六章查找1 基本概念  查找表：是由同一类型的数据元素构成的集合，查找中的核心  查找：给定 K 值，寻找 K 的数据元素  静态查找表：进行的是引用型运算          基本运算                  建表          查找          读表中元素                      动态查找表：进行的是加工型运算          基本运算                  初始化          查找          读表中元素          插入          删除                    树查找（二分查找，B 树查找）      哈希查找        查找成功：在数据元素集合中找到了要查找的数据元素  查找不成功：在数据元素集合中没有找到要查找的数据元素2 静态查找表  二分法查找          静态查找：二分查找，索引顺序表查找      动态查找：二叉排序树找，哈希查找        顺序表中查找：二分法查找法          从表中最后一个记录开始顺序进行查找，若当前记录的关键字=给定值，则查找成功；否则，继续查上一记录…；若直至第一个记录尚未找到需要的记录，则查找失败。包括”二分查找，索引顺序表查找”二种方法      优点：简单，对表无要求      缺点：比较次数多      算法                  设立岗哨                    思想：：每次将处于查找区间中间位置上的数据元素与给定值 K 比较，若不等则缩小查找区间并在新的区间内重复上述过程，直到查找成功或查找区间长度为 0（查找不成功）为止。可使下次查找范围缩小一半        分块查找：索引顺序查找          查找过程（把数据分为若干个块，然后在块中再查找）                  先建立最大（小）关键字表-索引表（有序）          查找索引表，以确定所查找元素块号          在相应的块中按顺序查找关键字为 K 的记录                    3 二叉排序树  定义：是种特殊的、增加了限制条件的二叉树  条件          左子树上所有结点的值都小于它的根值，如左子树为空除外。      右子树上所有结点的值都大于它的根植，如右子树为空除外      每一个子树也要分别满足上二个条件，即一层一层都是这样条件        总结：二叉排序树上进行查找，如查找成功，则是从根结点出发走了一条从根结点到待查结点的路径；如查找不成功，则是从根结点出发走了一条从根到某个叶子的路径。因些与二分查找类似，关键字比较的次数不超过二叉树的深度，对于同一组结点，由于建立二叉排序树时插入结点的先后次序不同，所构成的二叉排序树的形态与深度也不同，含有 n 个结点的二叉排序树不是唯一的。也就是说，二叉排序树上的查找长度不仅与结点数 n 有关，也与二叉排序树的生成过程有关  插入原则：必须要保证插入一个新结点后，仍为一棵二叉排序树，这个结点是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子4 散列表  哈希表          散列函数（哈希函数）：关键字与元素地址的函数      散列地址：由散列函数决定数据元素的存储位置，该位置称为散列地址      散列查找：关键字-&gt;散列函数转换-&gt;位置上有无元素      散列表：通过散列法建立的表称为散列表        冲突          散列表的实现：链池址法      优点：直接由关键字通过哈希函数计算出哈希地址，查找效率高      缺点：常发生冲突，影响查找效率      5 小结第七章排序（重点）1 概述  数据排序：一个文件记录按照关键字不减（不增）次序排列，是文件成为有序的文件，此过程称为排序  稳定排序：若排序后相同的关键字的记录保持原来相对次序  不稳定排序：反之稳定排序  排序类型          内部排序：全部数据存与内存 只考                  插入排序：又分直接插入排序，折半插入（二分法）排序，表插入和希尔排序几种，我们重点掌握直接插入排序就可          交换排序：又分冒泡排序，快速排序          选择排序：又分直接选择排序，堆排序          并归排序：它和和前几种完全不同的排序，它又分为有序序列合并，二路归并排序                    外部排序：需要对外存进行访问的排序过程      2 插入排序  过程：对 R_1，…，R_i−1 已排好序，有 K_1≤K_2≤….≤K_i−1，现将 K_i 依次与 K_i−1，K_i−2，…进行比较，并移动元素，直到发现 R_i 应插在 R_j 与 R_j+1 之间(即有 K_j ≤ K_i ＜ K_j+1 )，则将 R_i 插到 j+1 号位置上，形成 i 个有序序列。（i 从 2 ～ n）      算法          存储空间 n+1；（1 为附加空间）      时间复杂度 O(n^2)              稳定性：稳定排序        void straightsort( list r );{                                               /* 用直接插入排序法对r[1]…r[n]进行排序 */  for ( i = 2; i &lt;= n; i++ )                    /* n为表长，从第二个记录进行插入 */  {    r[0] = r[i];                         /* 第i个记录复制为岗哨 */    j = i - 1;    while ( r[0].key &lt; r[j].key )            /* 与岗哨比较，直到健不大于岗哨键值 */    {      r[j + 1] = r[j];                 /* 将第j个记录赋值给第j+1个记录 */      j  = j - 1;    }    r[j + 1] = r[0];                       /* 将第i个记录插入到序列中 */  }}                    3 交换排序      冒泡排序          基本思想：通过多次重复比较、交换相邻记录而实现排序；每一趟的效果都是将当前键值最大的记录换到最后。它是对 n 个元素排序，所历经的趟数至少为 1，至多为 n-1              原理：通过两两数进行多次对比，把最大的数放在最后面，如下面多次比较才得到第一趟结果把 49 放在最后面，这就是冒泡的原理(21，25，49，25，16，08)            第一趟：21，25，25，16，08，49    第二趟：21，25，16，08，25，49    第三趟：21，16，08，25，25，49    第四趟：16，08，21，25，25，49    第五趟：08，16，21，25，25，49                Void bubbleSort( list r, int n ){                                                       /* 用冒泡排序法对r[1]…r[n]进行排序 */  /* flag:标志文件是否已排好序 */  for ( i = 1; i &lt;= n - 1; i++ )  {    flag = 1;                               /* 若循环中记录未作交换,则说明序列已有序 */    for ( j = 1; j &lt;= n - i; j++ )      if ( r[j + 1].key &lt; r[j].key )      {        flag  = 0;    /* 排序前先为0，若在一趟起泡中交换了记录，则置为1 */        p  = r[j]; r[j] = r[j + 1];        r[j + 1] = p;      }    if ( flag )      return;  }}                      快速排序      基本思想：通过分部排序完成整个表的排序；首先取第一个记录，将之与表中其余记录比较并交换，从而将它放到记录的正确的最终位置，使记录表分成两部分{其一（左边的）诸记录的关键字均小于它；其二（右边的）诸记录的关键字均大于它}；然后对这两部分重新执行上述过程，依此类推，直至排序完毕    void  quickpass( list r, int h, int p ){  /* 对顺序表r中的子序列r[h]至r[p]进行快速排序 */  i = h;    j = p;  /* 左右指针置初值 */  x = r[h];         /* 取处理元素（即作为枢轴记录） */  while ( i ＜ j  )       /* 左右指针未碰头则反复做： */  {    while ( r[j].key &gt; x.key &amp;&amp; i &lt; j )      --j;    /*右边未找到小关键字，则右指针j继续左移*/    if ( i &lt; j )    /*右边找到比枢轴记录小的记录，则将其送到左边*/    {      r[i] = r[j];      ++i;    }    while ( r[i].key &lt;= x.key &amp;&amp; i &lt; j )      ++i;    /*边未找到大关键字，则左指针i继续右移*/    if ( i &lt; j )                    /*左边找到比枢轴记录大的记录，则将其送到右边*/    {      r[j] = r[i];      - -j;    }  }  r[i] = x;                               /*枢轴记录定位*/  if ( h &lt; i - 1 )    quickpass( r, h, i - 1 );       /*对左子序列进行快速排序*/  if ( j + 1 &lt; high )    quickpass( r, j + 1, p );       /*对右子序列进行快速排序*/}        算法分析          空间：n+log2n; （log2n 为附加空间—栈）      时间：≤O(nlog2n);                  注：若初始记录表有序或基本有序，则快速排序将蜕化为冒泡排序，其时间复杂度为 O(n2)；          即：快速排序在表基本有序时，最不利于其发挥效率。                    稳定性：不稳定排序。      4 选择排序      直接选择：以重复选择的思想为基础进行排序                  过程：设记录 R_1，R_2…，R_n，对 i=1，2，…，n-1，重复下列工作：                  在 R_i，…，R_n 中选最小(或最大)关键字记录 R_j；          将 R_j 与第 i 个记录交换位置，即将选到的第 i 小的记录换到第 i 号位置上                void  select( list r, int n ){ /*用选择排序法对r[1]….r[n]进行排序*/ for ( i = 1; i &lt; = n - 1; ++i ) {  k = i;                                  /*选择第i小的记录，并交换位*/  for ( j = i + 1; j &lt;= n; j++ )   if ( r[j].key &lt; r[k].key )      /*在r.[i]…r.[n-1]中找最小者*/    k = j;  if ( k != i )                           /*交换记录*/  {   temp = r[i];   r[i] = r[k];   r[k] = temp;  } }}                            分析                  空间：n+1； （1 为附加空间）          时间：C 总=∑ni=1(n-i)=(n2-1)/2≈O(n2)          稳定性：不稳定排序；                          堆排序          需要解决问题                  如何由一个初始序列建成一个堆？          如何在输出堆元素之后调整剩余元素成为一个新堆？                    分析                  空间：n+1； （仅需 1 个附加空间）          时间：O（nlog2n)          稳定性：不稳定排序；                    5 并归排序  有序序列的合并：比较各个子序列的第一个记录的键值，最小的一个就是排序后序列的第一个记录。取出这个记录，继续比较各子序列现有的第一个记录的键值，便可找出排序后的第二个记录。如此继续下去，最终可以得到排序结果  二种并归排序          思路                  n 个记录的表看成 n 个，长度为 1 的有序表          两两归并成 n/2 个，长度为 2 的有序表（n 为奇数，则还有 1 个长为 1 的表）          再两两归并为 n/2 /2 个，长度为 4 的有序表，再两两归并直至只剩 1 个，长度为 n 的有序表，共 log2n 趟                    算法分析                  空间：n+n；（需 n 个附加空间）          时间：O（nlogn)          稳定性：稳定排序；                    6 小结            排序方法      平均时间      最坏情况      辅助存储      稳定性                  简单排序(插入、冒泡、直接选择)      O(n2)      O(n2)      O(1)      稳定排序(除直接选择是不稳定外)              快速排序      O(nlog2n)      O(n2)      O(log2n)      不稳定排序              堆排序      O(nlog2n)      O(nlog2n)      O(1)      不稳定排序              归并排序      O(nlog2n)      O(nlog2n)      O(n)      稳定排序      "
  },
  
  {
    "title": "InternetPrinciples（04735）",
    "url": "/posts/InternetPrinciples/",
    "categories": "Cc, SelfStudy, ComputerBasics",
    "tags": "SelfStudy",
    "date": "2022-03-20 13:57:01 +0800",
    





    
    "snippet": "计算机网络原理（04735）第一章 计算机概述1 计算机网络基本概念网络协议      网络通讯实体之间的在数据交换过程中需要遵循的规则或约定        三要素          语法（syntax）      语义（semantics）      时序（timing）      网络功能（核心功能：资源共享）  硬件资源共享  软件资源共享  信息资源共享网络分类      按覆盖范围...",
    "content": "计算机网络原理（04735）第一章 计算机概述1 计算机网络基本概念网络协议      网络通讯实体之间的在数据交换过程中需要遵循的规则或约定        三要素          语法（syntax）      语义（semantics）      时序（timing）      网络功能（核心功能：资源共享）  硬件资源共享  软件资源共享  信息资源共享网络分类      按覆盖范围分类          个域网：PAN 1-10m      局域网：LAN 10m-1km      城域网：MAN 5-50km      广域网：WAN 几十到几千米            按拓扑结构分类          星形拓扑结构：易监管，故障诊断隔离；中央结点网络瓶颈，一旦故障全网瘫痪；受限中央结点      总线型拓扑结构：所需电缆数少，易于扩展；通信范围受限，故障诊断与隔离难，容易发生冲突      环形拓扑结构：所需电缆短，可以使用光纤，易于避免冲突；某结点故障全网瘫痪，加入新结点撤出比较麻烦，存在等待时间      网状拓扑结构：可靠性高，一条或多态线路故障，网络仍然可联通；结构复杂，造假成本高，选路协议复杂      树形拓扑结构：易于扩展，故障隔离容易；对根结点可靠性高，根结点故障，导致大范围无法通讯      混合拓扑结构：大多数实际网络拓扑属于混合网络（Internet）；易扩展，构建不同规模，可根据需求选网络结构；网络结构复杂，管理维护复杂        按交换方式分类          电路交换      报文交换      分组交换        按网络用户分类          公用网      私有网      2 计算机网络结构  网络边缘：计算机、服务器、智能手机、智能传感器……      网络接入          电话拨号揭露      非对称数字用户线路 ADSL      混合光纤同轴 HFC 揭露      局域网      移动网络接入        网络核心：分组交换网络设备构成，主机之间数据中继与转发3 数据交换技术  概念：实现在大规模网路核心上进行数据传输的技术基础  电路交换：最早出现的一种交换方式（电话网络最早、最大的电路）          优点：实时性高、时延和时延抖动小。      缺点：突发数据传输，信道利用率低，传输速率单一            交换网络：          建立链接      传输数据      拆除电路        报文交换：储存-转发交换方式          什么是报文：发送方把要发送的信息附加上发送/接收主机的地址和控制信息      优点：信道利用率高      缺点：时延长，可能会报文过多而丢弃报文        分组交换：包交换，存储-转发交换方式          将待传输的数据（报文）分割成较小的独立的数据块      4 计算机网络性能      速率与带宽          速率：网络单位时间内传送的数据量，用以描述网络传输数据的快慢;bit/s（位每秒）      带宽                  通信和信号处理领域，指的是信号的频带宽度，即信号成分的最高频率与最低频率之差。单位：Hz（赫兹）          计算机网络领域，指的是一条链路或者信道的数据传输能力，也就是最高数据速率，单位：bit/s（位每秒）                          时延：跳步的时间总和即为一个分组从源主机到达目的主机的时延          数据从网络中的一个结点（主机或者交换设备）到达另一个结点所需要的时间      在分组交换网络中：通常将连接两个结点的直接链路称为一个”跳步”，简称”跳”              公式                  结点处理时延：$dc$;此类延时较小，往往忽略          排队时延：$dq$;排队时延不确定          传输时延：$dt=L/R$;分组在输出链路发送时，从发送第一位开始，到发送完最后一位需要的时间                          L：分组长度bit              R：链路带宽bit/s                                传播时延：$dp=D/V$信号从发送端出来，经过一段物理链路到达接收端需要的时间。                          D：物理链路长度m              V：信号传播速度m/s                                一个分组经过一个跳步需要的时间：$dh=dc+dq+dt+dp$；一般只需要计算$dt+dp$                      时延带宽积：物理链路的传播时延与链路带宽的乘积，记为 G          公式：$G=传播时延*链路带宽$ G=dp*R                  传播时延的单位：s          带宽的单位： bit/s          时延带宽积的单位：bit                      丢包率：丢失分组和发送分组之比。反映网络的拥塞程度          $Ns$：发送分组数      $Nr$：接收分组数      公式：$\\eta= \\frac{Ns-Nr}{Ns}$        吞出量：在单位时间内源主机通过网络向目的主机实际送达的数据量，记为 Thr；对于分组交换网络，源主机到目的主机的吞吐量在理想情况下约等于瓶颈链路的带宽，即等于链路的带宽中的最小值      例题：设主机 A 和主机 B 由一条带宽为 R=108bit/s、长度为 D=100m 的链路互连，信号传播速率为 V=250000km/s。如果主机 A 从 t=0 时刻开始向主机 B 发送长度为 L=1024bit 的分组          主机 A 和主机 B 间的链路传输时延 dt:答案：$dt=L/R=1024bit÷108bit/s=1.024×10-5s$      主机 A 发送该分组的传播时延 dp。答案：$dp=D/V=100m÷250000km/s=100÷250000×103m/s=4×10-7s$      该分组从主机 A 到主机 B 的延迟 T。（忽略结点处理时延和排队时延）答案：$T=dt+dp=1.024×10-5s+4×10-7s=1.064×10-5s$      在 t=dt 时刻，分组的第一位在何处。（说明原因）答案：分组的第一位已到达主机B，因为：dt&gt;dp      主机 A 与主机 B 间链路的时延带宽积 G答案：$G=dp×R=4×10-7s×108bit/s=40bit$      5 计算机网络体系结构      概念          用户之间进行信息交换                  硬件：主机、链路、交换设备          协议                    协议最典型的划分方式，采用分层方式组织协议      分层核心思路是上层功能建立在下层更能基础上，每一层内均要遵守一定的通信规则协议      计算机网络体系结构：计算机网络划分的层次以及各层协议的集合；这种分层体系结构是按照功能划分的，不是按照实现方式划分的            OSI 参考模型：国际化标准组织（ISO）；开放系统互连（open system interconnection）                  含义：端到端层：传输层、会话层、表示层、应用层                  数据：（PDU：协议数据单元）在垂直的层次中自上而下地逐层传递至物理层          实通信：物理层的两个端点进行物理通信          虚拟通信：对等层不直接进行通信          中间系统（路由器）：通常只实现物理层、数据链路层和网络层功能          结点到结点层：物理层、数据链路层、网络层                            七层概述（高-&gt;低）                  7-&gt;应用层：提供网络服务（文件传送、电子邮件、P2P 等）报文          6-&gt;表示层：处理应用实体之间交换数据的语法。          5-&gt;会话层：用户与用户之间的连接。建立会话时核实双方身份、费用、对话控制与管理等          4-&gt;传输层：第一个端到端的层次。复用/分解，端到端的可靠数据传输、连接控制、流量控制、拥塞机制等；数据段或报文段          3-&gt;网络层：数据转发与路由；分组或包          2-&gt;数据链路层：有效的差错控制；帧          1-&gt;物理层：无结构的比特流传输；比特流或位流                            主要功能                  1-3：完成数据交换和数据传输，称为网络低层          4：底层于高层之间传输层衔接          5-6：完成信息处理服务的功能，称为网络高层                          TCP/IP 参考模型          最大、最重要的计算机网络—因特网的体系结构可以采用 TCP/IP 参考模型描述      4-&gt;应用层、 报文 、OSI（应用层、表示层、会话层）：Internet 常见的网络应用（WWW、HTTP、FTP、邮件【SMTP、POP3】）；面向链接服务（TCP）、面向无连接服务（UDP）      3-&gt;传输层、 段 、OSI（传输层）：应用层将用户数据按照特定的应用层协议封装好，接下来由传输层的协议负责把这些数据传输到接收方主机上对等的应用程序。TCP 协议、UDP 协议      2-&gt;网络互连层、 数据报、 OSI（网络层）：核心；解决把数据分组发往目的网络或主机的问题。路由选择，IP、ICMP、IGMP、BGP、OSPF、RIP 协议等      1-&gt;网络接口层、 帧、 OSI（数据链路层、物理层）：没有真正描述这一层的实现。具体的实现方法将随着网络类型的不同而不同            五层参考模型：结合OSI和TCP/IP 提出总和理论需求和实际网络的五层参考模型          应用层 报文      传输层 段      网络层 数据报      链路层 帧      物理层 比特流      6 计算机网络与因特网发展简史  分组交换技术提出因特网      历史          1967 年发布第一个 ARPAnet 第一分组交换分组交换计算机网络 分组交换网之父      1969 年第 ARPAnet 建成有四个分组交换机互连网络      1972 年第 ARPAnet 发展到 15 个交换结点      20 世纪 70 年代早期与中期，除了 ARPAnet 之外，还诞生许多其他的分组交换网络（ALOHAnet、Telenet）；发展三个因特网核心网络协议：TCP、UDP、IP      20 世纪 70 年代末， ARPAnet 已连接大约 200 台主机。因特网已现雏形      20 世纪 80 年代，因特网连接的主机数量达到 100000 台      20 世纪 90 年代，因特网祖先 ARPAnet 已不复存在      20 世纪 90 年代后五年，因特网快速发展与变革的时期，企业和高校、甚至个人开始接入因特网      2000 年开始，因特网进入爆发式发展期      第二章 网络应用1 计算机网络应用体系结构      客户端/服务器（C/S）结构网络应用          最典型、最基本的网络应用      网络应用通信的双方分为服务器程序和客户程序      特征                  通信只在客户和服务器之间进行，用户与用户之间不进行直接通信          主动发起通信的一方是客户程序，被动接受通信的一方是服务器          服务器程序先运行，做好接受通信的准备                          P2P（peer to peer）          通信双方没有传统意义上的客户服务器之分，地位对等，通信双方都具备客户与服务器的特征      文件分发、文件共享、视频流服务等应用中，P2P 表现出优越的性能            混合结构网络应用          C/S 应用和 P2P 应用相结合      既有中心服务器的存在，也有对等端间的直接通信      2 网络应用通讯基础原理  网络应用的基本通讯过层：运行在不同主机上的应用进程间以C/S方式进行通信  C/S 方式：服务器端运行的是服务器进程，被动等待客户请求服务；客户端运行的是客户进程，主动发起通信，请求服务器进程提供服务  应用进程之间遵循应用层协议交换应用层报文。还需要通过层间接口（应用编程接口 API）将报文传递给相邻的传输层  典型的网络应用编程接口是套接字（Socket）  对于一个传输层协议，需要为与其接口的每个套接字分配一个编号，标识该套接字，该编号称为端口号（IP+端口号）  Internet 传输层只提供两类服务：（TCP、UDP）3 域名系统（DNS）  概念          域名系统（domain naming system）      域名解析原理：为了实现域名解析，域名系统会建立分布式数据库，储存域名与IP地址的映射关系                  主机域名：www.baidu.com -&gt;域名解析-&gt; IP地址：220.181.38.251                      层次化域名空间          域名的命名方式：层次树状结构命名方式，每个域名有不同的级别的域名构成，各个层级域名之间用点分隔      www.sina.com.cn                  www：三级域名          sina：二级域名          com：通用顶级域名          cn：国家顶级域名                    顶级域名分类                  1）国家顶级域名：cn，us，uk等          2）通用顶级域名：com，org，gov，edu等          3）基础结构域名：只有一个（arpa，反向域名解析）                          域名服务器：以区为管理范围单位          本地（默认）域名服务器：在主机网络地址配置是，都会配置用于保存被查询域名信息              根据保存的域名信息在解析过程中的作用分类                  根域名服务：最重要的域名服务器，全球 13 个 a ～ m（保存所有顶级域名服务器的域名和 IP 地址）          顶级域名服务（TLD 服务）：负责管理在该顶级域名服务器（cn）注册的所有二级域名          权威域名服务：保存该区中的所有主机的域名和 IP 地址的映射          中间域名服务：不是以上三种的域名服务器                      域名解析过程          递归解析：主机进行域名查询时，本地域名服务器没有被查询域名信息，则本地域名服务器代理主机查询根域名服务器      迭代解析：主机进行域名查询时，本地域名服务器没有被查询域名信息，则先求助于根域名服务器      总结：无论是递归还是迭代，本地服务器不能直接响应解析结果，都需要从根域名服务器开始查询      4 万维网应用  万维网应用：web 应用          主要包括：浏览器、web 服务器、超文本传输协议 HTTP                  浏览器：Web 应用的客户软件、客户代理。          Web 服务器：服务器软件、存储管理供用户请求浏览的 Web 页面（Web 文档）          超文本传输协议（HTTP）：客户和服务器间的交互基于的协议                    统一资源定位符号（universal resource locator，URL）                  URL 地址：存放对象的主机域名（或 IP 地址）＋对象的路径名；URL 寻址方式确保万维网上的每一个 web 页面或者对象都有一个唯一的标识符                          HTTP：超文本传输协议（Hyper Text transfer protocol，HTTP）          概述                  Web 应用的应用层协议，定义浏览器如何向 Web 服务器发送请求，以及 Web 服务器如何进行响应          HTTP/1.0 和 HTTP/1.1                    HTTP 链接                  HTTP 基于传输层的 TCP 传输报文。浏览器在向服务器发送请求之前，首先建立 TCP 连接，然后才发送 HTTP 请求报文，接收 HTTP 响应报文（C/S）          RTT （Round Trip Time）： 作为一个时间单位来使用（HTTP 客户进程向服务器请求建立连接：从客户发送连接请求，到客户收到服务器连接确认，用时一个往返时间）                    使用 TCP 策略不同                  非之久链接的 HTTP（tcp 用一次就断开了）                          非持久连接（一条连接）（8 个 RTT）              并行连接（多条连接）（4 个 RTT）                                持久连接的 HTTP（TCP 不断开）                          非流水方式持久连接（5 个 RTT）              流水方式持久连接（3 个 RTT）                                                  HTTP 报文                              请求报文和响应报文                          请求：浏览器（客户端）发送给 Web 服务器              响应：Web 服务器发送给浏览器                              请求报文                                                                                                   请求报文                                                                                                  起始行                      请求行：&lt; URL &gt;                                                              首部行                                                                                     空白行                                                                                     报文主体                                                                                                                                   请求方法：                                                                                            方法                          简介                                                                                                                      GET                          请求读取由 URL 所标识的信息，是最常见的方法                                                                          HEAD                          请求读取由 URL 所标识的信息的首部                                                                          POST                          给服务器添加信息                                                                          OPTION                          请求一些选项的信息                                                                          PUT                          在指明的 URL 下存储一个文档                                                                                                                                                响应报文：状态码用于服务器向客户端通告响应情况                                                      响应格式                                                                                                                       响应报文                                                                                                                      起始行                          状态行：                                                                          首部行                                                                                                     空白行                                                                                                     报文主体                                                                                                                                                     HTTP 状态码：3 位十进制数，利用第一位十进制数字区分 5 类状态码                                                                                            状态码类别                          取值范围                          作用                          说明                                                                                                                      1xx                          100-199                          信息提示                          通告信息，可能还需要进一步交互                                                                          2xx                          200-299                          成功                          成功完成客户请求的操作，并进行响应                                                                          3xx                          300-399                          重定向                          表示资源已移走，需要向新 URL 发请求                                                                          4xx                          400-499                          客户端错误                          由于客户端请求错误，无法成功响应                                                                          5xx                          500-599                          服务器错误                          由于服务器端错误，无法成功响应                                                                                                                          常见的状态码                                                                                            状态码                          短语                          含义                                                                                                                      100                          Continue                          已成功收到了请求的初始部分，请客户端继续                                                                          200                          OK                          成功，所请求信息在响应报文中                                                                          301                          Moved Permanently                          重定向                                                                          400                          Bad Request                          客户端请求错误                                                                          401                          Unauthorized                          未授权，需要输入用户名和密码                                                                          404                          Not Found                          客户端请求的对象，在服务器上不存在                                                                          451                          Unsupported Media Type                          不支持的媒体类型                                                                          505                          HTTP Version Not Supported                          请求使用的 HTTP 版本，服务器不支持                                                                                                                                                              Cookie          HTTP 服务器不保存客户的任何信息，被称为无状态协议;引入 Cookie 机制，用于用户跟踪      小型文本文件（Cookie）：网站为了辨别用户身份、进行会话跟踪而储存在用户本地终端上的数据      Cookie 技术主要包括 4 部分内容                  1）HTTP 响应报文中的 Cookie 头行：用户的 Cookie ID，用户偏好等。          2）用户浏览器在本地存储、维护和管理的 Cookie 文件。          3）HTTP 请求报文中的 Cookie 头行：用户已访问过的网站再次访问时，浏览器会检索本地 Cookie 文件。          4）网站在后台数据库中存储、维护 Cookie 信息：分配用户 ID、每个 ID                    分类                  保存在硬盘中的 Cookie 称为永久 Cookie，关闭浏览器不影响 Cookie          保存在内存中的 Cookie 称为会话 Cookie，关闭浏览器 Cookie 消失                    用途                  1）网站可以利用 Cookie 的 ID 来准确统计网站的实际访问人数、新访问者和重复访问者的人数对比、访问者的访问频率等数据          2）网站可以利用 Cookie 限制某些特定用户的访问          3）网站可以存储用户访问过程中的操作习惯和偏好          4）记录用户登录网站使用的用户名、密码等信息          5）电子商务网站利用 Cookie 可以实现”购物车”功能                    5 Internet 电子邮件  概述          邮件服务器：发送和接收邮件、向发信人报告邮件传送情况（已交付、被拒绝、丢失等）、 用户注册、 分配存储空间      用户代理：电子邮件应用的客户端软件（Outlook，Apple Mail，Fox Mail）      简单邮件传输协议（SMTP）：实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输；默认端口 25      邮件读取协议（POP3、IMAP、HTTP）                  POP3：第三版邮局协议          IMAP：互联网邮件访问协议          HTTP：Web 邮件系统的邮件读取协议                      SMTP（simple mail transfer protocol ，SMTP）          实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输      使用传输层 TCP 实现可靠数据传输，使用的端口号是 25                  过程                          握手阶段              邮件传输阶段              关闭阶段                                          特点                  1）SMTP 只能传送7 位ASCLL码文本内容，包括 SMTP 命令、应答消息以及邮件内容,优化方案互联网邮件扩展（multipurpose internet mail extensions，MIME）          2）SMTP 传送的邮件内容中不能包含CRLF.CRLF，因为该信息用于标识邮件内容的结束。          3）SMTP 是推动协议。（补充：HTTP 是”拉动”协议）。          4）SMTP 使用TCP 连接是持久                      邮件读取协议：比较流行的邮件读取协议：以拉动方式运行          POP3                  使用 TCP，默认端口110          交互阶段                          授权、事务处理、更新阶段（quit）                                          IMAP-互联网邮件访问协议（Internet Message Access Protocol，IMAP）：                  IMAP 服务器将每个邮件与一个文件夹进行关联，通过 IMAP 收件人可以对邮件进行移动、查询、阅读、删除等操作          IMAP 维护了 IMAP 会话的用户状态的信息。并且允许用户代理只读取部件的部分内容                    HTTP：web 邮件系统的的邮件读取协议      6、7 FTP、P2P 应用  FTP（file transfer protocol）：          在互联网的两个主机间实现文件互传的网络应用的应用层协议      FTP 是 C/S 方式实现客户、服务器之间的双向文件传输。      FTP 服务器器进程分为两部分：主进程，负责接受新的客户请求；      若干从进程，负责处理单个客户请求      FTP 应用结构：控制进程的端口号 21，传送数据的端口号 20        P2P 应用          客户/服务器体系结构过于依赖服务器，一旦服务器出现故障，会引起单点故障。P2P 体系结构对服务器的的依赖很小      特点                  应用的对等方是用户的计算机。          很强的应用规模伸缩性。          应用在对等方之间进行          应用充分聚集利用了端系统的计算能力以及网络传输宽带                    8 Socket 编程  类型          数据报类型套接字SOCK_DGRAM、面向传输层 UDP 接口传输层      流式套接字SOCK_STREAM、面向传输层 TCP 接口传输层      原始套接字SOCK_RAW、面向网络层协议（如 IP、ICMP 等）接口 网络层        函数          创建套接字：socket（ ）      绑定套接字的本地端点地址： bind（ ）      设置监听：listen（ ）      建立连接：                  TCP 客户端：connect（ ）          TCP 服务端：accept（ ）                    接收数据：                  TCP：recv（ ）          UDP：recvfrom（ ）                    发送数据：                  TCP：send（ ）          UDP：sendto（ ）                    关闭套接字：close（ ）      第三章 传输层1 传输层的基本服务      传输的功能          核心任务：应用进程之间提供端到端的逻辑通信服务      功能                  对应用层报文进行分段和重组          面向应用层实现复用与分解          实现端到端的流量控制          拥塞控制          传输层寻址          对报文进行差错检测          实现进程间的端到端可靠数据传输控制                    并不是所有的传输层协议都要实现所有的功能，大部分传输层协议            传输层寻址与端口          传输层就是为了支持不同的主机，不同操作系统上的应用程序之间的通信，必须要使用统一的寻址方法对应用进程进行标识      单个计算机中，不同应用进程用进程标识符（进程 ID）来区分                  TCP/IP 网络体系结构的解决方法                          在传输层使用端口（port）              全网利用IP地址+端口号，唯一标识一个通信端点                                                  端口号为16位整数，可以编号65536 $2^{16}$                                            端口              描述              用处                                                          0-1023              熟知端口号              服务端                                      1024-49151              登记端口（IANA 登记防止重复）              服务端                                      49152-65535              短暂端口号              客户端                                                  常用端口号                                            端口号              描述                                                          20、21              FTP 文件传输协议端口号                                      25              SMTP 简单邮件传输协议端口号                                      53              DNS 域名服务器端口号                                      80              HTTP 超文本传输协议端口号                                      110              POP3 第三版的邮局协议端口号                                                无连接服务与面向连接服务                            无连接服务（UDP）          面向连接服务（TCP）                                      数据传输之前：无需与对端进行任何信息交换（”握手”），直接构造传输层报文段并向接收端发送          数据传输之前：需要双方交换一些控制信息，建立逻辑连接，然后再传输数据，传输结束后还需要拆除连接                          例如：邮政系统的信件通信          例如：电话通信                    2 传输层的复用与分解  概述          多路复用与多路分解：支持众多应用进程共用同一传输层协议，能准确的将接收的数据交付给不同的应用进程，称为传输层的多路复用与多路分解      多路复用：：在源主机，传输层协议从不同的套接字收集应用进程发送的数据块，并为每个数据块封装上首部信息（包括用于分解的信息）构成报文段，然后将报文段传递给网络层；多个进程同时利用同一个传输层协议      多路分解：在目的主机，传输层协议读取报文段中的字段，标识出接收套接字，进而通过该套接字，将传输层的报文段中的数据交付给正确的套接字        无连接的多路复用与多路分解（UDP）          分配方法                  UDP 自动分配未使用端口          创建 UDP 套接字，通过调用bind() 函数为该套接字绑定一个特定端口                    UDP 套接字二元组：&lt;目的IP地址，目的端口号&gt;        面向连接          TCP 套接字四元组：&lt;源IP地址，源端口号，目的IP地址，目的端口号&gt;      3 停-等协议与滑动窗口协议  可靠原理          概述                  internet 传输层的两个协议：TCP 、UDP          TCP 可靠传输服务，将报文交给 IP 传送，而 IP 尽力服务，也就是不可靠，必须采取措施才能使其在基于不可靠的网络层上实现可靠传输                    不可靠传输信道的不可靠性方面                  比特差错：1100——0110          乱序：先发的数据包后到达，后发的数据包先到达                          发送：1、2、3、4、5              接收：2、1、5、4、3                                数据丢失：中途丢失，不能达到目的地                          发送：1、2、3、4、5              接收：1、3、4、5                                          采取措施                  差错检测：利用差错编码实现数据包传输过程中的比特差错检测（甚至纠正）          确认：接收方向发送方反馈接收状态                          ACK（肯定确认）；NAK（否定确认）              肯定确认：Positive Acknowledgement，正确接收数据              否定确认：Negative Acknowledgement，没有正确接收数据                                重传：发送方重新发送接收方没有正确接收的数据                          发送方接收到 NAK，表示接收方没有正确接收数据，则将出错的数据重新向接收方发送                                序号：确保数据按序提交                          对数据包进行编号。可以避免由于重传引起的重复数据被提交的问题                                计时器：解决数据丢失问题                          发送方发送数据后启动计时器，如超时还未收到接收方的确认。主动重发数据包，从而纠正数据丢失问题                                          有效、合理地综合应用上述措施，可以设计实现可靠数据传输的协议                  停-等协议与滑动窗口协议                      停等协议          工作流程                  1）发送方发送经过差错编码和编号的报文段，等待接收方的确认。          2）接收方如果差错检测无误且序号正确，则接收报文段，并向发送方发送 ACK，否则丢弃报文段，并向发送方发送 NAK          3）发送方如果收到 ACK，则继续发送后续报文段，否则（NAK 超时）重发刚刚发送的报文段                    细节                  差错控制：报文段、ACK、NAK 数据包均需要进程差错编码以便进行差错控制          序列号：只需要 1 位就够了（区分是新发的报文还是重传的报文）          ACK 和 NAK：利用重复 ACK 代替 NAK（对上一个正确接手的报文段再次进行确认【ACK0】）          ACK 和 NAK 差错：有错推断                      滑动窗口          停等协议不足（性能差、信道利用率低）      流水线协议（管道协议）：允许发送方没有收到确认前发送多个分组（最典型的流水线协议滑动窗口协议）      流水线协议可靠传输，改进                  增加分组序号（多位）          发送方和接收方可以缓存多个分组                    特点                  发送方依序流水方式（1，2，3，4，5）发送分组，接收方接手分组按序向上提交          发送方对已发送的未收到确认的分组，必须缓存，必要时重发，发送方可以连续发送多个未收到确认的分组（取决于缓存能力）          接收方对未按按序到达的分组，必须缓存或者丢弃并确认（取决于缓存能力）                    滑动窗口协议的窗口                  发送窗口（$Ws$）：发送方可以发送未被确认分组最大数量          接手窗口（$Wr$）：接手方可以缓存的正确到达到达分组的最大数量                    滑动窗口协议，根据窗口的大小，两种代表性的滑动窗口协议                  1）回退 N 步协议：GBN 协议（Go-Back-N）                          发送窗口 Ws≥1 ，接收窗口 Wr=1。                                  发送端缓存能力高，可以在没有得到确认前发送多个分组                  接收端缓存能力很低，只能接收 1 个按序到达的分组，不能缓存未按序到达的分组                                            发送方响应事件                                  上层调：：窗口未满，用”下一个可以序号”编号并发送分组，否则拒绝发送新的数据                  收到 1 个 ACKn：GBN 采用累积确认方式，即发送方收到 ACKn 时，表明接收方正确接收序号 n 以及序号小于 n 的所有分组                  计时器超时：发送方只使用一个计时器，对”基序号”指向的分组计时；如超时，如超时，重发当前发送窗口中所有已发送但未确认的分组，即”回退 N 步”，因为接收方 Wr=1，无缓存能力                                            接收方                                  Wr=1，只能接收”基序号”所指向的分组                  如接收方正确接收到序号为基序号，则发送一个 ACKn，接收窗口滑动到序号 n+1 的位                  接收到的序号不是 n 或者分组差错等，则发送 ACKn-1。                                            总结                                  在差错较低的情况下，信道利用率会得到很大提高                  如果信道误码率或者丢包率较高，导致大量重发，信道传输能力降低                  GBN 适合低误码率、低丢包率、带宽高时延积信道，且对接收方缓存能力要求低                                                              2）选择重传协议：SR 协议（Selective Repeat）                          选择重传（SR）通过让发送方仅重传那些未被接收确认（出错或者丢失）的分组，避免了不必要的重传              发送窗口 WS ＞ 1，接收窗口 Wr ＞ 1。很多 SR 协议 WS 、Wr 大小相等。                                  发送端缓存能力高                  接送端缓存能力高                                            发送方响应                                  上层调用，请求发送数据：检查”下一个可用序号”，位于发送窗口内则发送，否则缓存或者返回给上层                  计时器超时，发送方对每个分组进行计时，超时则重发该分组                  收到 ACKn：SR 协议对 n 进行判断。如 n 在当前窗口内，则标记已接收（刚好是基序号，窗口向右滑动到最小未被确认序号处）；其他情形不做响应                                            接收方                                  正确接收到序号在接收窗口范围内的分组 PTKn，发送 ACKn，窗口滑动                  正确接收到序号在接收窗口左侧的分组 PTKn，这些分组在之前已经正确接收并提交，丢弃 PTKn，并发送 ACKn，窗口不滑动                  其他情况，直接丢弃分组，不做任何响应                                                                        4 用户数据包协议（UDP）user datagram protocol  基本知识          概述                  Internet 传输层协议          提供无连接、不可靠、数据报尽力传输服务          通讯进程之间没有握手过程          UDP 没有拥堵控制机制          实现了复用与分解以及简单的差错检测          DNS 使用 UDP 应用层协议的例子                    选择 UDP 原因特点                  应用进程容易控制发送什么数据以及何时发送。可能会出现分组的丢失和重复          无需建立连接；DNS 使用的主要原因          无连接状态，无需维护连接状态          首部开销小，只需要8 个字节；而 TCP 需要 20 字节                      数据报结构          首部（每个字段长度都是2个字节，共8个字节）                  源端口号目的端口号：实现复用和分解          长度：指示 UDP 报文段中的字节数（首部和数据总和）          校验和：接收方使用来检测数据报是否出现差错                          校验和          提供差错检测功能      检测 UDP 报文段从源到目的传送过程中，其中数据是否发送了改变      计算规则                  所有参与运算的内容按16 位对齐求和          求和过程中遇到溢出（即进位）都被回卷（即进位与和的最低位再相加）          最后得到的和取反码，就是 UDP 的校验和，填入 UDP 数据报的校验和字段                    计算内容包括：UDP 伪首部、UDP 首部、应用数据；UDP 协议好 17              示例                  数值 1：0110 0110 0110 0000          数值 2：0101 0101 0101 0101                      数值 3：1000 1111 0000 1100                                                            操作                  1                  4                  3                  2                  1                  4                  3                  2                  1                  4                  3                  2                  1                  4                  3                  2                  1                                                                              数值 1                                     0                  1                  1                  0                  0                  1                  1                  0                  0                  1                  1                  0                  0                  0                  0                  0                                                  数值 2                                     0                  1                  0                  1                  0                  1                  0                  1                  0                  1                  0                  1                  0                  1                  0                  1                                                  1+2                                     1                  0                  1                  1                  1                  0                  1                  1                  1                  0                  1                  1                  0                  1                  0                  1                                                  数值 3                                     1                  0                  0                  0                  1                  1                  1                  1                  0                  0                  0                  0                  1                  1                  0                  0                                                  1+2+3                  1                  0                  1                  0                  0                  1                  0                  1                  0                  1                  1                  0                  0                  0                  0                  0                  1                                                  益处回卷                                     0                  1                  0                  0                  1                  0                  1                  0                  1                  1                  0                  0                  0                  0                  1                  0                                                  取反码                                     1                  0                  1                  1                  0                  1                  0                  1                  0                  0                  1                  1                  1                  1                  0                  1                                                                        总结                  UDP 提供差错检测，但是它没有差错恢复能力只是          简单地丢弃差错报文段，或者将受损的报文段交给应用程序并给出警告          由应用程序处理出错报文                    5 传输控制协议（Transmission Control Protocol，TCP）  概述          提供面向连接、可靠、有序、字节流传输服务      特点                  应用进程之间先建立连接，而且该连接只供通讯双方（2 个端点）使用          传输数据：无差错、不丢失、不重复、按序到达          面向字节流：字节序列；应用程序和 TCP 的交互是一个个数据块，TCP 把他们看做是无结构字节流          全双工通讯：通讯双方进程在任何时候都能发送和接收数据                    最大报文段长度（Maximum segment size，MSS）：报文段中封装的应用层数据的最大长度        报文段结构          概述：TCP 报文段有首部字段和一个数据字段组成（将文件划分成长度 MSS 的快，最后一块除外），一个快封装成一个TCP报文段      1）源端口字段，目的端口号字段：占 16 位；复用和和分解上层应用的数据      2）序号字段、确认序号字段：32 位                  序号字段：TCP 的序号是对每个应用层数据的每个字节进行编号          确认序列号字段：期望从对方接收数据的字节序号，即该序号对应的字节尚未收到          TCP 采用累计确认机制                    首部长度字段：占 4 位，指出 TCP 段的首部长度（字段值为 5，表示首部长度 20 字节）      保留字段：占 6 位，保留为今后使用，目前值为 0      URG、ACK、PSH、RST、SYN、FIN 各占 1 位，标志位字段，共 6 位，取值位0或1                  紧急 URG=1，紧急指针字段有效，优先传送。          确认 ACK=1，确认序号字段有效；          ACK=0 时，确认序号字段无效。推送 PSH=1，尽快将报文段中的数据交付接收应用进程，不要等缓存满了再交付。          复位 RST=1，TCP 连接出现严重差错，释放连接，再重新建立 TCP 连接。          同步 SYN=1，该 TCP 报文段是一个建立新连接请求控制段或者同意建立新连接的确认段。          终止 FIN=1，TCP 报文段的发送端数据已经发送完毕，请求释放连接                    接收窗口字段：占 16 位 ，向对方通告我方接收窗口的大小，实现 TCP 流量控制      校验和：占 16 位，和 UDP 的校验和的计算方法相同      紧急指针字段：占 16 位                  URG=1 时，才有效。指出在本 TCP 报文段中紧急数据共有多少个字节                    选择字段长度可变，最短为 0 字段      填充字段，取值为 0，目的是为了整个首部长度是 4 个字节的整数倍数            TCP 连接管理                  连接管理：连接建立于连接拆除（三次握手）                  主机 A 于主机 B 建立 TCP 连接                          主机 A 的 TCP 向主机 B 发出连接请求 SYN 报文段（第一次握手）SYN=1;seq=x;              一旦包含 SYN 报文段的 IP 数据报到达主机 B，SYN 报文段被从数据报中提取出来，主机 B 的 TCP 接到连接请求段后，如同意建立连接，则发回确认的 SYNACK 报文段（第二次握手）。                                            流程图                  sequenceDiagram        participant C as 客户端        participant S as 服务端        C-&gt;&gt;S: SYN=1,seq=x (第一次握手)        S--&gt;&gt;C: SYN=1，ACK=1，seq=y， ack_seq=x+1 (第二次握手)        C-&gt;&gt;S: ACK=1，seq=x+1，ack_seq=y+1（第三次握手）客户端同意                          第一次握手（客户端进入SYN_SEND同步发送）                                  SYN=1：建立连接请求控制段                  seq=x（seq 表示序号的意思）：表示传输的报文段的第 1 个数据字节的序列号是 x，此序列号代表整个报文段的序号                                            第二次握手（服务端由LISTEN进入SYN_RCVD（同步收到））                                  SYN=1：同意建立新连接的确认段                  ACK=1：确认序号字段有效                  seq=y：服务器告诉客户机确认报文段的序列号是 y。                  ack_seq=x+1：表示已经收到了序列号为 x 的报文段，准备接收序列号为 x+1 的报文段                                            第三次握手（当客户机发送 ACK 时，进入ESTABLISHED状态；当服务器收到 ACK 后，也进入ESTABLISHED状态）                                  ACK=1：确认序号字段有效                  seq=x+1：客户机此次的报文段的序列号是 x+1                  ack_seq=y+1：客户机期望接收服务器序列号为 y+1 的报文段                  第三次握手可携带数据                                                              为什么要三次握手                          第一次握手：客户发送请求，此时服务器知道客户能发              第二次握手：服务器发送确认，此时客户知道服务器能发能收              第三次握手：客户（数据）发送确认，此时服务器知道客户能收                                                  连接拆除（4 次挥手）                              流程图            sequenceDiagram    participant C as 客户端    participant S as 服务端    C-&gt;&gt;S: FIN=1，seq=u (第一次挥手)    S--&gt;&gt;C: ACK=1，seq=v，ack_seq=u+1 (第二次挥手)    S--&gt;&gt;C: FIN=1，ACK=1，seq=v+1，ack_seq=u+1 (第三次握手)    C-&gt;&gt;S: ACK=1，seq=u+1，ack_seq= v+1+1（第四次挥手）                          第一次挥手                                  客户向服务器发送释放连接报文段：（FIN=1，seq=u）                  FIN=1：发送端数据发送完毕，请求释放连接                  seq=u：传输的第一个数据字节的序号是 u                  客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待 1 状态）                                            第二次挥手                                  ACK=1：确认字号段有效。                  ack_seq=u+1：服务器期望接收客户数据序号为 u+1。                  seq=v：服务器传输的数据序号是 v                  服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）                  客户端收到 ACK 段后，由FIN_WAIT_1进入FIN_WAIT_2                                            第三次挥手                                  FIN=1：请求释放连接                  ACK=1：确认字号段有效                  ack_seq=u+1：表示服务器期望接收客户数据序号为 u+1                  seq=v+1：表示自己传输的第一个数据字节的序号是 v+1                  服务器状态由CLOSE_WAIT进入LAST_ACK（最后确认状态）                                            第四次挥手                                  ACK=1：确认字号段有效。                  ack_seq=v+1+1：表示客户期望接收服务器数据序号为 v+1+1。                  seq=u+1：表示客户传输的数据的序号是 u+1。                  客户端状态由FIN_WAIT_2进入TIME_WAIT，等待 2MSL 时间，进入CLOSED状态                  服务器在收到最后一次 ACK 后，由LAST_ACK进入CLOSED                                                                          流量控制          概述                  协调发送方与接收方的数据发送与接收速度，避免发送方发送数据太快，超出接收方接收能力和处理力          利用窗口协议，但不是简单的滑动窗口协议                    实现机制                  建立连接，双方固定大小缓冲空间          接收窗口字段（16 位），向对象通告接收窗口大小（剩余空间）          不能超过最近一次接收端通告的接收窗口大小                      用塞控制          概念                  太多的主机以太快的速度向网络中发送太多的数据，超出了网络处理能力          导致大量数据分组拥挤在中间设备队列中等待转发，网络性能显著下降的现象                    拥塞的后果                  1）数据分组通过网络的时间显著增加          2）队列满导致大量分组被丢弃                    用塞控制                  通过合理调度、规范、调整向网络中发送数据的主机数量          发送速率、数据量，以避免拥塞或消除已发生的拥塞                    窗口调控基本策略（Additive Increase Multiplicative Decrease，AIMD）                  网络未发送拥堵时，逐渐”加性”增大窗口          网络拥塞时”乘性”减小窗口                    算法                  慢启动                          建立连接时，使用慢启动拥塞控制算法调整拥塞窗口              RTT：发送端发出一个报文段到接收这个报文段的确认单时间间隔                                用塞避免                          为了防止拥塞窗口增长而引起的网络拥塞              设置一个拥塞窗口阈值              当拥塞窗口大于等于阈值时，每经过 1 个 RTT，拥塞窗口的值加 1              当前拥塞窗口中所有报文段全部发送并且接收并成功确认，拥塞窗口的值加 1 “加性增加”              例子                                  当前拥塞窗口为 24MSS，当前阈值为 16MSS。                  新的阈值：为当前拥塞窗口的一半 24MSS÷2=12MSS                  新的拥塞窗口：直接调整为 1MSS                                            调整好新的阈值和新的拥塞窗口后，重新执行慢启动算法。”乘性减小”                                快速重传                          接收端收到 3 次重复确认，则推断被重复确认的报文段已经丢失              于是立即发送被重复确认的报文段                                快速恢复                          当发生 3 次重复确认时，网络拥塞程度不是很严重。              阈值和拥塞窗口的调整方法：不再重新从慢启动阶段开始，而是直接从新的阈值开始，直接进入拥塞避免阶段                                          第四章网络层1 网络层服务  任务：承载传输层报文段的网络层数据报从源主机送达到目的主机，中间经过多跳路由器      功能          转发：当输入链路接收到一个分组后，路由器需要决策通过哪条输出链路将分组发送出去，并将分组从输入接口转移到输出接口              路由选择：当分组从源主机流向目的主机时，必须通过某种方式决定分组经过的路由或路径                  计算分组经过的路由的算法（路由选择算法、路由算法）          路由器基于某种算法计算路由，将路由信息存储到路由器转发表中                      每个路由器上有一张转发表（路由表）                                                            目的地址                  输出地址                                                                              地址 1                  1                                                  地址 2                  2                                                                        连接建立：网络层连接是从源主机到目的主机经过的一条路径，这条路径所经过的每个路由器等网络设备都要参与网络层连接的建立                  是否在网络提供连接服务                          提供连接服务的虚电路（VC）网络              提供无连接服务的数据报网络                                          2 数据报网络与虚电路网络  数据报网络          概述：按照目的主机地址进行路由选择的网络（因特网是按照 IP 目的地址进行路由选择，因此因特网是一个典型的数据报网络）      特点                  每个数据分组单独处理（称数据报），每个数据报都携带源目的主机地址信息          通信之前，不需要建立连接（称无连接）          发送接收次序不一定相同，路径也可能不一致，接收方需要重组（传输层）          丢失差错检测，由通信双方的传输层协议（TCP）解决          分组到达分组交换机路由器,通过分组交换机的转发表(目的地址映射到某个输出链路的转发表)决策适合的输出链路,转发表更新(1-5m)                          虚电路网络（Virtual circuit，VC）          虚电路                  源主机到目的主机的一条路径上建立的一条网络层逻辑连接，为区别于电路交换中的电路，称为虚电路          每条虚电路都有虚电路号，称为虚电路标识（VCID）                    虚电路网络：在网络层提供面向连接的分组交换服务。双方通信前先虚电路建立连接，通信结束后再拆除连接      一条虚电路（VC）由 3 个要素构成                  从源主机到目的主机之间的一条路径（一系列的链路和分组交换机）。因此分组是顺序到达的          该路径上的每条链路的虚电路标识（VCID）          分组交换机的转发表（VCID 转换表）中记录虚电路标识的接续关系          建立一条新的 VC，VCID 转换表添加一行新表项                    虚电路交换与电路交换                  类似，都是面向连接的，顺序发送，建立连接都需要开销          电路交换提供稳定的传输速率和延迟时间          虚电路是分组交换提供统计多路复用传输服务                    虚电路分类                  永久型（PVC）：提前建立，长期使用的虚电路，建立时间可以忽略          交换型（SVC）：根据需要临时建立，通信结束后拆除，建立和拆除时间开销较大。                    虚电路交换与数据报交换的差别                  虚电路网络（ATM 网络）通常由网络完成这些功能，由端系统提供无差错数据传送服务，而端系统则可以很简单          数据报网络（Internet）通常网络实现的功能很简单，如基本的路由与转发，顺序控制、差错控制和流量控制等功能则由端系统来完成                            虚电路交换和数据报交换比较                                            项目              虚电路网络              数据报网络                                                                         是否建立连接              先建立连接              不建立连接                                                     地址              每个分组含有一个短的虚电路号              每个分组包含源和目的端地址                                                     分组顺序              按序发送，按序接收              按序发送              ，不一定按序接收                                      路由选择              建立 VC 时需要路由选择，之后所有分组都沿此路由转发              每个分组独立路由选择                                                     典型网络              X.25、帧中继、ATM              因特网                                                         3 网络互连与网络互连设备  异构网络互连          主要是指两个网络的通信技术和运行协议的不同      基本策略：协议转换和构建虚拟互连网络                  协议转换                          采用一类支持异构网络之间协议转换的网络中间设备              来实现异构网络之间数据分组的转换与转发              网桥、应用网关、交换机或者是多协议路由器                                构建虚拟互联网络：在异构网络基础上构建一个同构的虚拟互联网络（IP 网络）                    异地同构网络：实现两个异地同构网络互连的典型技术是隧道技术      例： MPLS（Multiple Protocol Lable Switching）：多协议标记交换网络。            路由器          概述                  最典型的网络层设备          具有多个输入端口和多个输出端口的专用计算机          主要任务就是获取与维护路由信息以及转发分组          路由器从功能体系结构角度：输入端口、交换结构、输出端口、路由处理器                            输入端口：查找，转发，到达分组 缓存排队功能（下图，输入端口接收与处理数据过程）            graph LR        A(线路端接) --&gt;B(数据链路处理 协议,封装)        B(数据链路处理 协议,封装) --&gt;C(查找 转发 排队)        C(查找 转发 排队) --&gt;D(交换结构)            交换结构：分组被转发至哪个输出端口已经确定，具体的工作由交换结构来完成                  分类                          基于内存交换：输入端口（中断方式）-&gt; 内存（路由处理器）-&gt; 输出端口              基于总线交换                                  输入端口和输出端口连接在一条数据总线上                  无须路由处理器介入即可实现交换功能                  总线是独占式，一个分组通行，其他排队                                            基于网络交换                                  使用一个复杂的互联网络来实现交换结构                  克服单一、独占所带来的限制并行交换传输，但输出端口相同，也需要排队                                                              比较                          基于内存交换：性能最低，路由器价格最便宜              基于网络交换：性能最高，路由器价格昂贵                                                  输出端口：提供缓排队功能，从队列中取出分组进行数据链路层数据帧的封装，通过物理线路端发送出去                              概述(下图输出端口处理数据过程)                          1）先到先服务（FCFS）调度策略；                              2）按优先级调度、按 IP 数据报的服务类型调度                    graph LR        A(交换结构) --&gt;B(排队 缓存管理)        B(排队 缓存管理) --&gt;C(数据链路处理 协议,封装)        C(数据链路处理 协议,封装) --&gt;D(线路端接)        D(线路端接)--&gt;E(XXXXXX)                                                        路由器处理器：路由器的 CPU，负责执行路由器的各种指令                  1）执行命令          2）路由协议运行          3）路由计算以及路由表的更新和维护                    路由器匹配规则                  检索路由表，没有则选择默认路由转发          匹配成功，则选择对应接口          有多条匹配成功，选择前缀匹配成功最长的路由项，即最长前缀匹配优先原则（网络号）                    4 网络层拥塞控制  网络拥塞：用户对网络资源（包括链路带宽、存储空间和处理器处理能力等）的总需求超过了网络固有的容量          流量控制与拥塞控制                  流量控制：发送方根据接收方的的接收能力（缓存，速度）调整发送速率和数据量，关注点到点的流量          拥塞控制：主要考虑端系统之间网络环境，确保网络能够承载所达到的流量          例子                          A 地到 B 地的车辆放行              考虑 B 地停车能力，流量控制              考虑 A 地到 B 地经过的路网不塞车，拥塞控制                                          原因                  1）缓冲区容量有限          2）传输线路的带宽有限          3）网络结点的处理能力有限          4）网络中某些部分发生了故障                    改进                  增加网络资源（拥塞防止）          减下网络负载（拥塞消除）                    网络层拥塞控制措施                  流量感知路由          准入控制          流量调节          负载脱落                      流量感知路由          概述：                  网络抽象为一张带权无向图，路由器抽象为图的结点，链路抽象为图的边          每一条链路有自己的链路费用（例如：时延小，权值小）          权值根据网络负载动态调整，可以将网络流量引导到不同的链路上，均衡网络负载，延缓或者避免拥塞的发生          流量感知路由是一种拥塞预防措施，在一定程度上缓解和预防拥塞的发生          可能发生震荡现象                      准入控制          广泛应用于虚电路网络的拥塞预防技术      思想：对新建虚电路审核，如果新建立的虚电路会导致网络变得拥塞，那么网络拒绝建立该新虚电路        流量调节：在网络发生拥塞时，通过调整发送方发送数据的速率来消除拥塞。          抑制分组：感知到拥塞的路由器选择一个被拥塞的数据报，给该数据报的源主机返回一个抑制分组      背压：抑制分组在从拥塞结点到源结点的路径上的每一跳，都发挥抑制作用        负载脱落          有选择地主动丢弃一些数据报，来减轻网络负载，从而缓解或消除拥塞      选择丢弃哪些数据报是关键，通常与上层应用有关      5 Internet 网络层  IPV4          概述                  Internet 网络层最核心的协议          定义了如何封装上层协议（如 UDP、TCP）的报文段；          定义了 Internet 网络层寻址（IP 地址）以及如何转发 IP 数据报等内容；两个版本：IPv4 和 IPv6                    格式                  1）版本号：4 位。IP 的版本号。          2）首部长度：4 位。IP 数据报的首部长度：20B-60B（假设第一个字节（8 位）：表示 IPv4，首部长度 4X5=20 字节）          3）区分服务：8 位。在旧标准种称为服务类型（Type Of Service，TOS）字段，用来指示期望获得哪种类型的服务          4）数据长度：16 位。IP 数据报的总字节数，包括首部和数据部分          5）标识：16 位。标识一个 IP 数据报。每产生一个 IP 数据报，IP 协议的计数器加 1。                          该字段的重要用途：在 IP 数据报分片和重组过程中用于标识属于同一 IP 数据报。              该字段不可唯一标识一个 IP 数据报                                6）标志：3 位                          DF 【Don’t Fragment】（禁止分片）：0=允许分片；1=禁止分片              MF【More Fragament】（更多分片）：0=未分片或者最后一片；1=是分片且不是最后一个                                7）片偏移字段（13 位）：以 8B 为单位。表示一个 IP 数据报分片与原 IP 数据报的数据的相对偏移量                          当该字段值为 0 时，且 MF=1， 则表示这是一个 IP 分片，且是第一个分片                                8）生存时间：8 位。Time-To-Live ，TTL。表示 IP 数据报在网络中可以通过的路由器数（或跳步数）          9）上层协议：8 位，指示该 IP 数据报封装的是哪个上层协议                          TCP–6              UDP–17                                10）首部校验和：16 位，利用校验和实现对 IP 数据报首部的差错检测          11）源 IP 地址：32 位 发出 IP 数据报的源主机的 IP 地址          12）目的 IP 地址：32 位。IP 数据报的需要送达的主机的 IP 地址          13）选项：长度可变          14）数据：存放 IP 数据报所封装的传输层报文段                    IP 数据报分片                  概述                          一个 IP 数据报从源主机到目的主机传输过程中，可能经过多个运行不同数据链路层协议的网络              不同数据链路层协议所能承载的网络层数据报的最大长度不尽相同              以太网承载数据最大长度1500字节              最大传输单元（Maximum Transmission Unit ， MTU）：数据链路层帧能承载的最大数据量。受 MTU 限制                                数据报长度超过 MTU，DF=0 时分片，DF=1 时丢弃，MF 标志位，最后一个分片是 0，其余分片全部是 1          注意事项                          IP 分片的协议版本、标识、源 IP、目的 IP 直接继承原数据报对应的值              IP 分片重组任务由目的主机的 IP 完成                                  是否属于同一个数据报                  是否是最后一个分片                  IP 分片的先后顺序                                                              原则                          尽可能少分片              一个最大分片可封装的数据字节数最好是 8 的倍数              假设数据报总长度为 L 字节，MTU 为 M 字节。且 L&gt;M，DF=0。                                计算方法（例子）                          发送一个总长度为 3400 字节的 IP 数据报，通过 MTU=1500 字节的链路转发。如何分片                                  解析                                          因为 MTU=1500 字节：对于一个分片来说包括两部分内容：首部+数据一个分片可以封装的数据字节数：1500-20=1480 字节                      IP 数据报的总长度：3400 字节 IP 数据报的数据长度：3400-20=3380 字节分片数：3380÷1480=2.28（3 片）                      偏移量                                                  第 1 片的片偏移量：0÷8=0                          第 2 片的片偏移量：1480÷8=185                          第 3 片的片偏移量：2960÷8=370                                                                                                                                                                  IPv4 的编址          概述                  Pv4 地址的长度为 32 位，共有 232 个不同的 IP 地址，约为 43 亿个          表示法：点分十进制标记法          一台主机可以拥有多个 IP 地址          IP 地址两部分                          前缀（Prefix）：即网络部分（Net ID）。用于描述主机所归属的网络              后缀（Postfix）：即主机部分（Host ID）。用于表示主机在网络中的唯一地址                                                  分类                  A、B、C 类：地址可以用于标识网络中的主机或路由器          D 类：作为组广播地址                      E 类：地址保留                                                            类                  前缀长度                  前缀                  首字节                                                                              A                  8 位                  0xxxxxxx                  0-127                                                  B                  16 位                  10xxxxxx xxxxxxxxx                  128-191                                                  C                  24 位                  110xxxxx xxxxxxxxx xxxxxxxxx                  192-223                                                  D                  不可用                  1110xxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx                  224-239                                                  E                  不可用                  1111xxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx                  240-255                                                                                表示                  前缀中的后几位：表示网络地址个数          后缀位数：表示这类网络中的 IP 地址总数                                                    类              前缀              前缀固定              前缀中的后几位表示网络地址              每个网络中 IP 地址总数                                                          A              8              0              7 位，27=128 个              $2^{24}$个                                      B              16              10              14 位，214 个              $2^{16}$个                                      C              24              110              21 位，221 个              $2^{8}$个                                          特殊地址                  本地主机地址：0.0.0.0/32，获取 IP 地址的时候可以用。新加入的主机通过 DHCP 请求 IP 地址          有限广播地址：255.255.255.255/32，表示广播地址。此网络内所有主机都可以收到          回送地址：127.0.0.0/8，例如 127.0.0.1.ping 一下，网络是否畅通                            私有地址：一部分分类地址保留用于内部网络。这部分分类地址可以在内网使用，但不能在公共互联网上使用                                            私有地址类别              范围                                                          A 类              10.0.0.0——10.255.255.255 （或 10.0.0.0/8）                                      B 类              172.16.0.0——172.31.255.255（或 172.16.0.0/12）                                      C 类              192.168.0.0——192.168.255.255（或 192.168.0.0/16）                                          无类地址                  无类地址中，网络前缀不再被设计为定长的 8 位、16 位、24 位，而变成可以是 0-32 位的任意值          网络地址书写形式：a.b.c.d/x。                            子网划分                  概述：为了缓解地址空间不足，提高 IP 地址空间利用率：另外的两种策略子网化和超网化          子网化：将一个较大的子网划分为多个较小子网的过程。（大变小）          超网化：将具有较长前缀的相对较小的子网合并为一个具有稍短前缀的相对较大的子网。（小变大）                      子网掩码                          子网掩码：定义一个子网的网络前缀长度；              子网掩码位数：32 位              书写形式：二进制，点分十进制              取值规则：对应网络前缀，全部为 1。其余位（主机部分），全部为 0              例子：                                  子网地址：213.111.0.0/24；子网掩码：255.255.255.0；网络前缀（24）位，主机位（8）位                  子网地址：213.111.0.0/23；子网掩码：255.255.254.0；网络前缀（23）位，主机位（9）位                                                                          假设某子网中的一个主机的 IP 地址是 203.123.1.135，子网掩码是 255.255.255.192                                          那么该子网的子网地址是什么?                                  与运算；0&amp;0=0； 0&amp;1=0； 1&amp;0=0； 1&amp;1=1                  子网地址是 203.123.1.128/26                                                            直接广播地址是什么?                                  子网掩码的反码与主机 IP 地址按位或运算                  反码：1 变为 0；0 变为 1                  0 || 0 = 0； 1 || 0 = 1； 0 || 1 = 1； 1 || 1 = 1；                  直接广播地址：203.123.1.191                                                            该子网 IP 地址总数是多少?                                  IPV4 地址共 32 位，分为网络位+主机位。                  通过子网掩码可以确定网络位，                  则主机位为：32-网络位。IP 地址总数：2 （主机位数）。                  主机位有 32-26=6 位，即有 26=64 个 IP 地址总数。                                                            该子网的可分配 IP 地址数是多少?                                  在 IP 地址总数中子网地址占一个，广播地址占一个，不能分配给主机和路由器接口。                  所以，可分配 IP 地址总数：IP 地址总数-2（子网地址占头，广播地址占尾。）                  该子网的可分配 IP 地址数是 64-2=62 个                                                            可分配 IP 地址范围是多少？                                  子网地址：203.123.1.128（头）（第一小题已经算出）                  广播地址：203.123.1.191（尾）                  可分配 IP 地址范围是： 203.123.1.129〜203.123.1.190                                                              路由聚合                          概述：路由器转发表由网络地址、子网掩码、下一跳地址、路由器接口组成。网络地址、子网掩码可以合并给出              规则                                  只有一条路由匹配成功（默认路由除外），选择该路由表项转发 IP 数据报。                  匹配成功的路由表项不止一条，选择网络前缀最长的那条。                  没有一条匹配成功，通过默认路由转发 IP 数据报                                            总结                                  减少路由表项数，提高路由效率，将可以聚合在一起的子网聚合成一个大的子网。子网划分的逆过程                  前提：具有相同的路由”路径”，即”下一跳地址”和”接口”相同                                                                          动态主机配置（DHCP）          概述：当组织分配到一个网络地址块后，就可以为该组织内的主机和路由器接口分配 IP 地址      分配方式                  静态分配：网络管理员手动配置          动态分配：动态主机配置协议（DHCP）来分配                    端口号                  DHCP 服务器端口号67          DHCP 客户端口号68                    DHCP 工作过程                  服务器发现：广播方式          服务器提供：广播方式          请求：广播方式          DHCP 确认                      网络地址转换（Network Address Translation，NAT）          作用：IPv4 址分配殆尽，很多主机使用私有地址，但是在公共网络上私有地址是无效的      工作原理                  从内网出去的 IP 数据报，将其 IP 地址替换为 NAT 服务器拥有的合法的公共 IP 地址以及端口号，并将替换关系记录到 NAT 转换表中；          从公共互联网返回的 IP 数据报，依据其目的 IP 地址与目的端口号检索 NAT 转换表，并利用检索到的内部私有 IP 地址和端口号替换目的 IP 地址和端口号，然后将 IP 数据报转发到内部网络                    外网访问内网                  NAT 穿透技术          在外网主机主动与内网主机发起通信之前，先在 NAT 转换表建立好内外网映射（静态配置、动态配置：UPnP），使内网运行的服务以 NAT 公网地址的”合法”身份”暴露”出去                          互联网控制报文协议（Internet Control Message Protocol ，ICMP）          进行主机或路由器间的网络层差错报告与网络探测      类型                  差错报告报文                          终点不可达              源点抑制              时间超时              参数问题              路由重定向                                询问报文                          回声请求/应答              时间戳请求/应答                                            IPv6          概述                  版本字段：指出协议版本号。          流量类型：和 IPv4 的区分服务（TOS）字段相似。          流标签：用来标识一系列数据报的流。          有效载荷长度字段：IPv6 数据报中数据的字节数量。          下一个首部：用来标识 IPv6 数据报要上交给上层的协议是那个，比如 TCP 还是 UDP。          跳数限制：与生存时间 TTL 功能类似。          源 IP 地址和目的 IP 地址：与 IPv4 意义一样。          数据：数据报中承载的有效载荷。          IPV6 基本首部 40 字节。                    表示方法                  8 组冒号分隔的十六进制数：5000：0000：00A1：0128：4500：0000：89CE：ABCD          连续多组 0000 可以用：：代替；：：只能出现一次          在 IPv6 地址中嵌入 IPv4 的点分十进制：6700：：89A1：0321：206.36.45.19                    分类                  单播：可以标识网络中唯一的主机或路由器接口，可做源地址和目的地址。          组播：标识网络中的一组主机，可做目的地址。          任播：也是标识网络中的一组主机，但是当向一个任播地址发送数据报的时候，只有该任播地址组内某个成员收到数据报，可做目的地址                    IPv4 到 IPv6 的迁移                  双协议栈：网络结点同时具备发送 IPv4 与 IPv6 数据报的能力          隧道：通信源端与目的端都提供 IPv6 服务，但是途径一段 IPv4 网络。在 IPv6 数据报进入隧道前的最后一个路由器上，该路由器将整个 IPv6 数据报封装进 IPv4 数据报中，再转发，在出口处再从 IPv4 数据报中提取 IPv6 数据报的有效荷载                    6 路由算法与路由协议  路由选择算法的分类          网络层的另一项重要功能：路由选择      带权无向图：将网络抽象为一个带权无向图 G=（N，E），N 表示结点集合，E 是边的集合      分类                  是否需要全局信息                          全局式路由选择算法-典型：链路状态路由选择算法（LS 算法）静态动态              分布式路由选择算法-典型：距离向量路由选择算（DV 算法）                                静态动态                          静态：人工配置              动态：自动计算最佳路由。LS、DV                                是否敏感                          敏感              迟钝                                            链路状态路由选择算法          链路状态路由选择算法是一种全局式路由选择算法，每个路由器在计算路由时，需要构建出整个网络的拓扑图      链路状态路由选择算法：利用 Dijkstra 算法求最短路径        距离向量路由选择算法          距离向量路由选择算法是一种异步的、迭代的分布式路由选择算法。该算法的基础是 Bellman-Ford 方程（简称 B-F 方程）      网络中每个结点 x，估计自己到网络中所有结点 y 的最短距离，记为 Dx（y），称为结点 x 的距离向量。            层次化路由选择          合理的网络规模范围                  全局式路由选择算法(链路状态路由选择算法（LS 算法）)          分布式路由选择算法(距离向量路由选择算（DV 算法）)                    层次化路由选择：大规模网络路由选择最有效可行的解决方案      自治系统（autonomoussystem，AS）：大规模的互联网按组织边界、管理边界、网络技术边界或功能边界划分为多个自治系统。每个自治系统由运行相同路由协议和路由选择算法的路由器组成                  每个自治系统存在至少一个与其他自治系统互连的路由器，负责与其他自治系统交换路由可达信息，称为网关路由器                    大规模互联网的路由划分为两层：                  自治系统内路由选择：基于所在自治系统采用的路由选择算法、计算到达自治系统内目的网络的路由          自治系统间路由选择：网关路由器运行自治系统间路由选择协议，负责其他自治系统的路由可达性信息                          Internet 路由选择协议          内部网关协议（Interior Gateway Protocol，IGP）（Internet 自治系统内路由选择协议）；典型：RIP、OSPF                  RIP（routing information protocol）                          路由信息协议              最早的自治系统内路由选择协议之一，基于距离向量路由选择算法              特性                                  第一、RIP 在度量路径时采用的是跳数，每条链路的费用都为 1。                  第二、RIP 的费用定义在源路由器和目的子网之间，最短路劲费用是指最短路劲经过的子网数量                  第三、RIP 被限制的网络直径不超过 15 跳的自治系统内使用，16 表示无穷大，表示目的网络不可达                                            RIP 是应用进程的实现，使用传输层的 UDP 报文来封装传输 RIP 报文              RIP 仍然是网络层协议，因为 RIP 实现的是网络层的功能                                OSPF（Open Shortest Path First）                          开放最短路径优先协议              基于链路状态路由选择算法的 IGP，使用 Dijkstra 算法求最短路径              优点                                  安全-OSPF 报文，经过认证。可以防止恶意侵入者将不正确的信息注入道路由器转发表中                  支持多条相同费用路径：允许使用多条相同费用路径，这样防止在具有多条从源到目的的费用相同的路径时，所有流量都发往其中一条路径                  支持区别化费用度量：同一条链路，根据 IP 数据报不同，设置不同的费用度量，实现不同类型网络流量的分流                  支持单播路由与多播路由：单播：只有一个源点网络和一个终点网络多播：在多播通信中，有一个源点和一组终点，这是一对多的关系                  分层路由：OSPF 支持在大规模自治系统内进一步进行分层路由                                                                                外部网关协议（Exterior Gateway Protocol，EGP）：Internet 自治系统间路由选择协议；典型：BGP                  BGP（Border Gateway protocol）                          边界网关协议              实现跨自治系统的路由信息交换。典型版本是 BGP4              BGP 封装进 TCP 报文段              每个 AS 可以通过 BGP 实现如下功能                                  1）从相邻 AS 获取某子网的可达性信息                  2）向本 AS 内部的所有路由器传播跨 AS 的某子网的可达信息                  3）基于某子网可达性信息和 AS 路由策略、决定到达该子网的最佳路由                                            BGP 也是由应用进程实现，传输层使用 TCP                                  通过 179 号端口建立半永久的 TCP 连接。交换 BGP 报文                  TCP 连接两端的路由器称为 BGP 对等端方                  发送报文的过程称为 BGP 会话                  分为内部 BGP 会话和外部 BGP 会话                                            BGP 报文的 4 中类型                                  1）OPEN（打开）报文，用来与 BGP 对等方建立 BGP 会话                  2）UPDATE（更新）报文，用来通告某一路由可达性信息，或者撤销已有路由                  3）KEEPALIVE（保活）报文，用于对打开报文的确认，或周期性地证实会话的有效                  4）NOTIFICATION（通知）报文，用来通告差错                                            属性                                  1）AS-PATH：AS 路径                  2）NEXT-HOP：一个开始 AS-PATH 的路由接口                                                                        第五章 数据链路层与局域网1 数据链路层服务  概述：负责通过一条链路，从一个结点向另一个物理链路直接相连的相邻结点，传送网络层数据报，中间不经过任何其他交换结点  数据链路          在物理链路之上      基于通信协议来控制数据帧传输的逻辑数据通路      其主要依赖硬件实体是：网卡（NIC，网络适配器）        结点          从数据链路层来看，主机、路由器等统称为结点      链路：相邻结点的通信信道称为链路      数据链路层传输的数据单元是：帧        数据链路层提供的服务          1）组帧                  数据链路层将要传输的数据（网络层 IP 数据报）封装成帧，称为组帧或者成帧          帧头（帧首）：发送结点和接收结点的地址（MAC）信息          帧尾：用于差错检测的差错编码          帧定界：识别一个帧的开始和结束                    2）链路接入                  物理链路可以分为：点对点链路和广播链路          点对点链路：发送结点和接收结点独占信道链路          广播链路：通信链路被多个结点共享，会彼此干扰，导致传输失败          结点必须运行 MAC 协议（媒介访问控制协议）协调各结点共享物理传输媒介                    3）可靠交付                  可靠数据传输原理，停-等协议，滑动窗口协议都适用          无线链路（出错率高）：支持可靠数据传输          光纤、双绞线（出错率低）：不提供可靠数据传输服务                    4）差错控制                  数据链路层帧在物理媒介上的传播过程，可能会出现比特翻转的差错          误比特率：一段时间内出现差错的比特数/传输比特总数。与线路信噪比有很大关系          措施：差错控制                    2 差错控制  概述          信号在信道传输过程中，会受到各种噪声的干扰，从而导致传输差错      随机噪声——随机差错或独立差错      冲击噪声——突发差错      差错控制就是通过差错编码技术，实现对信息传输差错的检测，并基于某种机制进行差错纠正和处理        差错编码基本方式          检错重发：                  发-待发送数据差错编码，在通过信道传输          收-利用差错编码检测，出错，请求重发数据加以纠正，知道正确为止          停-等，滑动窗口                    前向纠错 FEC（利用纠错编码）                  发-纠错编码，发包含纠错编码的帧          收-利用纠错编码差错检测，对错误的帧纠错          使用：单工链路、对实时性要求比较高的应用。                    反馈校验                  接-原封不动发回          发-通过对比接收端反馈 若有不同，立即重传数据，直到一致为止          优点：原理简单，易于实现，无须差错编码          缺点：需要相同传输能力的反向信道，传输效率低，实时性差                    检错丢弃                  网络应用对可靠性要求不高，可以采用不纠正出错数据，直接丢弃错误数据          只适用于实时性高的系统                      差错编码基本原理          在待传输数据信息基础上，附加一定的冗余信息。冗余信息：与数据信息建立某种关联关系      接收方检测冗余信息与数据信息的关联关系是否存在，存在则没有错误，否则就有错误        差错控制检错与纠正能力  典型差错编码          奇偶                  奇校验码：奇数位出错能检测出来，偶数位发生错误无法检测出来          偶校验码：奇偶校验可以实现 50%的检错率          优点：编码简单、编码效率高、开销最小的检错编码；          缺点：检错率不高                    汉明码      循环冗余码：在数据链路层广泛应用的差错编码。（检错码）      3 多路访问控制协议  概述          点对点信道：一对一通信方式，信道被双方独享      广播信道（共享介质）：一对多通信方式，信道上连接的点很多，信道被结点共享。必须使用多路访问控制协议来协调结点的数据发送      MAC 协议的根本任务：解决信道的共享问题        信道划分 MAC 协议：利用多路复用技术实现信道共享的 MAC 协议          频分多路复用 FDM：在频域内将信道带宽划分为多个子信道，将原始信号调制到对应的某个子信道的载波信号上，使同时传输的多路信号在整个物理信道带宽的允许范围内频谱不重叠，从而共用一个信道      时分多路复用 TDM      波分多路复用 WDM      码分多路复用 CDM        随机访问 MAC 协议          ALOHA 协议      CSMA 载波监听多路访问协议（先听后说）      CSMA/CD 带冲突检测的载波监听多路访问协议（先听后说，边听边说）        受控接入 MAC 协议          集中式控制：轮询技术      分散式控制：是令牌技术      4 局域网  概述          局域网（LAN）：局部区域网络，覆盖面积小，网络传输速率高，传输的误码率低      局域网常见的拓扑类型：星形网络，总线型网络，环形网络等      为了使数据链路层更好地适应多种局域网标准，IEEE802 委员会将局域网的数据链路层拆分为两个子层                  逻辑链路控制（Logical Link Control，LLC）子层（名存实亡）          介质访问控制（medium access control，MAC）MAC 子层                      数据链路层寻址与 ARP          概述：数据链路层的帧，需要携带发送结点的数据链路层地址，以及接收结点的数据链路层地址，标识帧的发送方与接收方      MAC 地址                  MAC 地址（物理地址、局域网地址）：MAC 地址具有唯一性，每个网络适配器对应一个MAC地址          MAC 地址空间的分配：由电气和电子工程师协会（IEEE）统一管理                          IEEE 分配前 24 位的 MAC 地址块              后 24 位由生产公司分配                                表示                          以太网和 IEEE 802.11 无线局域网，使用的 MAC 地址长度为 6 字节（48 位）。一共有 248 个可能的 MAC 地址              通常采用十六进制表示法，每个字节表示一个十六进制数，用 - 或：连接起来              例如                                  00-2A-E1-76-8C-39 或 00：2A：E1：76：8C：39                                            16 进制：0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F              Mac 广播地址：FF-FF-FF-FF-FF-FF                                          地址解析协议                  根据本网内目的主机或默认网关的IP地址获取其 MAC 地址          基本思想                          在每一台主机中设置专用内存区域，称为 ARP 高速缓存（也称 ARP 表）              存储该主机所在局域网中其他主机和路由器的 IP 地址与 MAC 地址的映射关系              ARP 通过广播 ARP 查询报文，来询问某目的 IP 地址对应的 MAC 地址，即知道本网内某主机的 IP 地址，可以查询得到其 MAC 地址                                注意的两点                          （1）ARP 查询分组是通过一个广播帧发送的；而 ARP 响应分组是通过一个标准的单播帧发送的              （2）ARP 是即插即用的，一个 ARP 表是自动建立的，不需要系统管理员来配置                                            以太网          概述：以太网（ethernet）：目前为止最流行的有线局域网技术。以太网与 IEEE802.3 是等价的      以太网成功的原因                  1）以太网是第一个广泛部署的高速局域网。          2）令牌环网、FDDI（纤分布式数据接口）和 ATM（异步传输模式）等比以太网技术更复杂、昂贵，阻止了网络管理员改用其他技术          3）以太网数据速率也快，比起其他技术，毫不逊色          4）以太网硬件价格极其便宜，网络造价成本低                    经典以太网技术                  1）采用粗同轴电缆连接的总线型以太网（10Base-5）（10：10Mbit/s ；BASE：传输信号为基带信号；5：5 个网段、单段最大传输距离为 500 米）          2）数据传输速率为 10Mbit/s，无连接不可靠          3）MAC 协议采用 CSMA/CD 协议          4）相距最远主机信号往返的传播时延为 51.2μs，所以以太网最短帧长为 64 字节                      交换机          网桥                  工作在数据链路层，和交换机功能类似。对数据帧实现转发          适合用户数不太多和通信量不太大的局域网          典型网桥：透明网桥，一种即插即用设备。局域网上的站点并不知道所发送的帧经过哪几个网桥                    交换机（转发与过滤）                  交换机可以认为是多端口的网桥，目前应用最广泛的数据链路层设备          交换机的基本工作原理：                          当一帧到达时，交换机首先需要决策将该帧丢弃还是转发              如果是转发的话，还必须进一步决策应该将该帧转发到哪个（或哪些）端口去              以目的 MAC 为主键查询内部转发表（无须转发、选择性转发、泛洪）                                优点                          消除冲突              支持异质链路              网络管理                                            虚拟局域网          划分方法                  基于交换机端口划分：每个交换机端口属于一个 VLAN。          基于 MAC 地址划分：按主机 MAC 地址定义 VLAN 成员          基于上层协议类型或地址划分：根据数据中的上层协议类型（IP）或者地址（IP 地址）定义 VLAN 成员                    5 点对点链路协议  点对点链路协议：点对点协议（PPP 协议）、高级数据链路控制协议（HDLC 协议）  PPP：适合单个发送方和单个接收方的点对点链路          PPP 的一个典型应用是家庭用户拨号上网      功能                  成帧          链路控制协议：启动线路、检测线路、协商参数、关闭线路          网络控制协议：协商网络层选项                    不要求 PPP 实现的功能                  差错纠正          流量控制          按序交付                    PPP 的字节填充：PPP 帧的长度都是整数字节。特殊的控制转义字节01111101        HDLC 协议：应用于点对点链路和点对多点链路          HDLC 有 3 种类型的帧（根据控制位的不同）                  信息帧（I 格式 Information）          管理帧（S 格式 Supervisory）          无序号帧（U 格式 Unnumbered）                    HDLC 协议是面向位的协议：位填充技术      第六章物理层  从物理层角度来看，计算机网络通信的本质就是数据通信1 数据通信基础  数据通讯基础概念          消息与信息                  消息：人类能够感知的描述          信息：一个抽象的概念。消息中所包含的有意义的内容，消息是信息的载体                    通信                  本质是在一点精确或近似地再生另一点的信息          通信系统：一般是指电通信，能够实现通信功能的各种技术、设备和方法的总体                    信号：在通信系统中，特别是电通信系统，信息在传输通道中传播的载体，称之为信号      数据：对客观事物的性质状态以及相互关系等进行记载的符号及其组合，可以是数字、文字、图像等，也可以是其他抽象符号      信道：信道是信号传输的介质                  狭义信道：仅是指信号的传输介质          广义信道：不仅是传输介质，而且包括通信系统中的一些转化装置                      数据通讯系统模型          数据通信系统的构成                  计算机网络是典型的数据通信系统          通信系统的作用是将消息从信源传送到一个或多个目的地          能够实现信息传输的一切技术设备和传输介质的集合称为通信系统                    模拟通信与数字通信:信道传输的是模拟信号称为模拟通信系统；信道传输的是数字信号称为数字通信系统                  模拟：是指信号的因变量完全随连续消息的变化而变化的系号（电视图像、电话语音）          数字：是指表示消息的因变量是离散的，自变量时间的取值也是离散的信号（计算机数据、电话、数字电视）                    数据通信方式                  数据传输方向                          单向通信：无线电广播              双向交替通信（半双工）：对讲机              双向同时通信（全双工）：电话网、计算机网络                                数据传输时空顺序                          并行通信：一个字节，每一位一个通道，全部位同时传送。              串行通信：一条通道，每一位依次在这条通道上传输                                数据同步技术                          异步通信：发送字符，不需建立同步时钟，实现简单，传输效率低适用低速网络。              同步通信：发送数据块（包含多个字符），双方建立同步时钟，实现复杂，传输效率高适用高速网络                                数据通信系统的功能                          1）信道的利用：多个通信设备共享，多路复用技术              2）接口及信号产生：保证信源、信宿与传输系统之间的信息交互              3）同步：发送与接收器之间达成约定              4）差错检测与纠正：发现信号失真，并纠正              5）寻址与路由：具有多条路径的网络选择合适的路径进行数据传              6）网络管理：规划、设置、监控、调度与维护              7）安全保证：数据在传输过程中不被改变，不被非法用户获                                          2 物理介质  物理介质是网络中传输信息的载体  分类          导引型传输介质（有线）                  以导线为传输介质，信号沿导线进行传输，信号的能量集中在导线附近，因此传输效率高，但是部署不灵活          方式                          架空明线（基本淘汰）              双绞线              同轴电缆（被双绞线替代）              光纤：利用了光的全反射现象                                          非导引型传输介质（无线）      3 信道与信道容量  概述          信道就是信号在通信系统中传输的通道      无线通信：信道就是电磁波传输通过的空间      有线通信：信道就是导向性线缆        信道分类与模型          信道                  狭义信道：信号传输介质。          广义信道（简称信道）：包括信号传输介质和通信系统的一些变换装置（发送设备、接收设备、天线、调制器等）。          广义信道按功能划分：调制信道、编码信道                    调制信道            信道传输特性                  概述                  模拟信源：电话机发出，可以通过信源编码转换为数字基带信号；          数字信源：计算机发出。          数字信号两种传输方式：基带传输、频带传输                            数字基带传输编码              信道容量4 基带传输  基带传输基本概念          信号码（绝对码）                  单极不归零码          双极不归零码          单极归零码          双极归零码          差分码（相对码）                    传输码                  AMI 码：双相码；米勒码          CMI 码：nBmB 码；nBmT 码；                    5 频带传输  频带传输基本概念  频带传输中的三种调制方式          二进制数字调制      多进制数字调制      正交幅值调制 QAM      6 物理层接口规程  物理层接口概述          物理层完成数据终端设备之间的比特流传输、包括物理链路的建立、维护和拆除的规范和标准，同时也定义物理层接口通信标准      物理层接口协议解决的问题：主机、工作站等数据终端设备与通信线路上的通信设备之间的接口问题                  数据终端设备 DTE（计算机）：Data Terminal Equipment          数据电路终端设备 DCE（调制解调器）：Data Circuit-Terminating Equipment                      物理层接口特性          机械特性：指明通信实体间硬件连接口的机械特点，尺寸、引线数目和排列      电气特性：规定了物理连接上，导线的电气连接及有关电路特性      功能特性：指明物理接口各条信号线的用途等      规程特性：通信协议，指明利用接口传输比特流的全过程，传输事件发生的合法顺序，包括事件的执行顺序和数据传输方式      第七章无线与移动网络1 无线网络  无线网络基本结构          概述                  无线主机：运行应用程序的终端设备（计算机、智能手机）          无线链路：主机通过无线链路连接到基站或者另一台无线主机          基站：关键部分。如蜂窝网的蜂窝塔（cell tower）、IEEE802.11 的 AP          网络基础设施：通常是大规模有线网络，如 internet                    自组织网络（Ad Hoc Network）：又称特定网络。        无线链路与无线网络特性          无线链路特征：通过无线链路连接到基站，不同无线链路技术传输速率和传输距离不同      有线网络与无线网络的重要区别在数据链路层和物理层，无线链路有别于有线链路主要表现                  信号强度的衰减          干扰          多径传播                    导致碰撞的两种情况                  1）隐藏终端          2）衰减                    2 移动网络  移动网络基本原理          无线网络不一定是移动网络，但移动网络一定是无线网络      移动性分析                  从网络层角度分析用户的移动性          移动结点的地址始终保持不变          可用的有线基础设施的支持                    移动互联网体系结构                  1）归属网络（家网）：一个移动结点的永久居所。          2）归属代理（家代理）：在一个归属网络中代表移动结点执行移动管理功能的实体。一般配置在路由器上。          3）外部网络（被访网络）：移动结点所在的非归属网络。          4）外代理：在外部网络中代表移动结点执行移动管理功能的实体                      寻址：移动结点从一个网络移到另一个网络保持地址不变          解决方案                  外部网络可以通过向其他所有网络发通告，告诉它们该移动结点正在它的网络中          将移动性功能从网络核心搬到网络边缘，由该移动结点的归属网络（归属网络）来实现                      移动结点的路由选择3 无线局域网 IEEE802.11  IEEE 802.11 系列标准  IEEE 802.11 体系结构          基站：接入点（AP）      基本服务集（BSS）：包含一个或多个无线站点和一个接入点的中央基站。        IEEE 802.11 的 MAC 协议  IEEE 802.11 帧          控制帧      数据帧      管理帧      4 蜂窝网络5 移动 IP 网络6 其他典型无线网络简介小结第八章网络安全基础1 网络安全概述2 数据加密  数据加密基本概念  传统加密方式：替代密码、换位密码  对称密钥加密：DES、三重 DES、AES、IDEA  非对称/公开密钥加密：RSA、 Diffie-Hellman3 消息完整性与数字签名4 身份验证5 密钥分发中心与证书认证6 防火墙与入侵检测系统防火墙  防火墙是能够隔离组织内部网络与公共互联网，允许某些分组通过而阻止其他分组进入或离开内部网络的软件、硬件或者软件硬件结合的一种设施      防火墙分类                  无状态分组过滤器                  最经典的部署在内网和网络边缘路由器上的防火墙                    有状态分组过滤器      引用网关      7 网络安全协议电子邮件对网络安全的需求  机密性：不被第三方阅读邮件内容  完整性：传输过程不被篡改；通过完整性验证可以判断是否被篡改  身份认证性：接收方能确认发送方的身份  抗抵赖性：接收方能预防发送方抵赖自己发送过的事          安全电子邮件标准（PGP 标准：Pretty Good Privacy）PGP 提供的服务：邮件加密、报文完整性、数字签名      SSL/TLS      SSL/TLS 介于应用层和传输层之间，类似于会话层，可作为基础协议栈的一部分，也可直接嵌入到浏览器中使用        SSL 可以提供的服务：机密性、完整性、身份认证等安全服务。    SSL 协议栈          SSL 是介于 TCP 和 HTTP 等应用层协议之间的一个可选层，绝大多数应用层协议可以直接建立在 SSL 协议之上，SSL 不是单独的协议，而是两层协议        SSL 使用的加密算法有          公开密钥加密算法：SSL 主要使用 RSA，其他多种公钥加密算法也支持      对称密钥加密算法：SSL 支持 DES 分组密码、3DES 分组密码等      MAC 算法：MD5 或 SHA-1            SSL 的握手过程          客户发送其支持的算法列表，以及客户一次随机数 nonce，服务器从算法列表中选择算法，并发给客户自己的选择、公钥证书和服务器端一次随机数 nonce。      客户验证证书，提取服务器公钥，生成预主密钥，并利用服务器的公钥加密预主密钥，发送给服务器，实现密钥的分发      客户与服务器基于预主密钥和一次随机数，分别独立计算加密密钥和 MAC 密钥，包括前面提到的 4 个密钥      客户发送一个针对所有握手消息的 MAC，并将此 MAC 发送给服务器      服务器发送一个针对所有握手消息的 MAC，并将此 MAC 发送给客户      IPSec  VPN 的实现技术很多，其中最安全使用最广泛的是IPSec安全点的邮件对网络安全的需求包括机密性、完整性、身份认证和抵抗赖性  IPsec 是网络层使用最广泛的安全协议，但 IPsec 不是一个单一的协议，而是一个安全体系  IPsec 提供的安全服务包括机密性、数据完整性、源认证和防重放攻击等。提供不同服务模型的两个协议分别是 ESP 和 AH 协议  IPsec 有两种典型的传输模式          传输模式      隧道模式      "
  },
  
  {
    "title": "Jekyll Github Readme",
    "url": "/posts/github-jekyll/",
    "categories": "Dev, Blog",
    "tags": "Blog",
    "date": "2022-02-12 22:58:36 +0800",
    





    
    "snippet": "Supported macOS versions  Monterey (macOS 12)  Big Sur (macOS 11)  Catalina (macOS 10.15)Older macOS versions might work, but we don’t officially support them.Install RubyTo install Jekyll on macOS...",
    "content": "Supported macOS versions  Monterey (macOS 12)  Big Sur (macOS 11)  Catalina (macOS 10.15)Older macOS versions might work, but we don’t officially support them.Install RubyTo install Jekyll on macOS, you need a proper Ruby development environment.While macOS comes preinstalled with Ruby, we don’t recommend using that versionto install Jekyll. This external article goes over the various reasonswhy you shouldn’t use the system Ruby.Instead, you’ll need to install a separate and newer version of Ruby using aversion manager such as asdf, chruby, rbenv, or rvm. Version managersallow you to easily install multiple versions of Ruby, and switch between them.We recommend chruby because it’s the simplest and least likely to cause issues.The instructions below are an excerpt from this detailed external guide toinstall Ruby on Mac. They work best if you’re setting up development toolsfor the first time on your Mac. If you’ve already tried to install Ruby orJekyll on your Mac, or if you run into any issues, read that guide.Step 1: Install HomebrewHomebrew makes it easy to install development tools on a Mac./bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"Step 2: Install chruby and the latest Ruby with ruby-installInstall chruby and ruby-install with Homebrew:brew install chruby ruby-installInstall the latest stable version of Ruby:ruby-install rubyThis will take a few minutes, and once it’s done, configure your shell toautomatically use chruby:echo \"source $(brew --prefix)/opt/chruby/share/chruby/chruby.sh\" &gt;&gt; ~/.zshrcecho \"source $(brew --prefix)/opt/chruby/share/chruby/auto.sh\" &gt;&gt; ~/.zshrcecho \"chruby ruby-\" &gt;&gt; ~/.zshrcIf you’re using Bash, replace .zshrc with .bash_profile. If you’re not sure,read this external guide tofind out which shell you’re using.Quit and relaunch Terminal, then check that everything is working:ruby -vIt should show  or a newer version.Next, read that same external guide for important notes aboutsetting and switching between Ruby versions with chruby.Install JekyllAfter installing Ruby with chruby, install the latest Jekyll gem:gem install jekyllTroubleshootingSee Troubleshooting or ask for help on our forum."
  },
  
  {
    "title": "项目架构图",
    "url": "/posts/work/",
    "categories": "Dev, Utils",
    "tags": "Left",
    "date": "2022-01-23 13:32:25 +0800",
    





    
    "snippet": "本地组项目架构图层次结构1 表示层  移动端 websocket 客户端消息通讯2 应用程序层3 服务层  网络服务          ws      http      4 数据访问层：redis  redis mp  redis save5 基础设施层  docker-compose  Prometheus+Grafana  save log模块和组件  hall  gs  log-se...",
    "content": "本地组项目架构图层次结构1 表示层  移动端 websocket 客户端消息通讯2 应用程序层3 服务层  网络服务          ws      http      4 数据访问层：redis  redis mp  redis save5 基础设施层  docker-compose  Prometheus+Grafana  save log模块和组件  hall  gs  log-server  publisher（礼包服务）  ferry（地址分配）  manger-server数据流方向技术栈  go  GitHub import          iris      cron      组织结构图"
  },
  
  {
    "title": "Leetcode 数组",
    "url": "/posts/leetcode-arrary/",
    "categories": "Dev, Algorith",
    "tags": "Dev, Go, leetcode",
    "date": "2022-01-01 19:08:09 +0800",
    





    
    "snippet": "两数之和  题目连接      题目解释          给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个整数，并返回它们的数组下标。      你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。      你可以按任意顺序返回答案。            示例 1    输入：nums = ...",
    "content": "两数之和  题目连接      题目解释          给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个整数，并返回它们的数组下标。      你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。      你可以按任意顺序返回答案。            示例 1    输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]            示例 2    输入：nums = [3,2,4], target = 6输出：[1,2]            示例 3    输入：nums = [3,3], target = 6输出：[0,1]            PS          2 &lt;= nums.length &lt;= 10^4      -10^9 &lt;= nums[i] &lt;= 10^9      -10^9 &lt;= target &lt;= 109^      只会存在一个有效答案            进阶          想出一个时间复杂度小于 O(n2)            题目    func twoSum(nums []int, target int) []int {}            解题                  暴力枚举                  时间复杂度（On^2）；使用双层 for 循环                func twoSum(nums []int, target int) []int {  for i := 0; i &lt; len(nums); i++ {    for j := i + 1; j &lt; len(nums); j++ {      if target == nums[i]+nums[j] {        return []int{i, j}      }    }  }  return nil}                            查找表法（用其一哈希表）                              map 中保存 nums 值            target-nums中每个 对比结果是否在 map 中            存在 map 中就返回                            func twoSum(nums []int, target int) []int {    tmpMap := make(map[int]int)    for key, value := range nums {      if value, ok := tmpMap[target-value]; ok {        return []int{key, value}      }      tmpMap[value] = key    }    return nil  }                    删除有序数组中的重复项      题目连接        题目说明  给你一个 升序排列 的数组 nums ，请你原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：  更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。      返回 k 。    判题标准:系统会用下面的代码来测试你的题解:int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) {    assert nums[i] == expectedNums[i];}如果所有断言都通过，那么您的题解将被 通过 。  示例 1：输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。  示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。      提示：    1 &lt;= nums.length &lt;= 3 * 10^4  -10^4&lt;= nums[i] &lt;= 10^4      nums 已按 升序 排列    题目  func removeDuplicates(nums []int) int {  }  解题  func removeDuplicates(nums []int) int {    if len(nums) == 0 {      return 0    }    slow := 1    for fast := 1; fast &lt; len(nums); fast++ {      if nums[fast] != nums[fast-1] {        nums[slow] = nums[fast]        slow++      }    }  return slow  }移除元素  题目连接      题目解释    题目说明给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地修改输入数组 。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以 「引用」 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以\"引用\"方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) {   print(nums[i]);}示例 1：输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。提示：  0 &lt;= nums.length &lt;= 100  0 &lt;= nums[i] &lt;= 50      0 &lt;= val &lt;= 100    题目func removeElement(nums []int, val int) int {}      题解                  方法一 自己写的          func removeElement(nums []int, val int) int {    if len(nums) == 0 {      return 0    }    // 暴力求解    for i := 0; i &lt; len(nums); i++ {      if nums[i] == val {        nums = append(nums[:i], nums[i+1:]...)        i--      }    }    return len(nums)  }                            方法二(双指针)          func removeElement(nums []int, val int) int {    left, right := 0, len(nums)    for left &lt; right {      if nums[left] == val {        nums[left] = nums[right-1]        right--      } else {        left++      }    }    return left  }                    搜索插入位置      题目连接        题目说明          给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。      请必须使用时间复杂度为 O(log n) 的算法。            示例 1:    输入: nums = [1,3,5,6], target = 5输出: 2            示例 2:    输入: nums = [1,3,5,6], target = 2输出: 1            示例 3:    输入: nums = [1,3,5,6], target = 7输出: 4            提示:          1 &lt;= nums.length &lt;= 10^4      -10^4 &lt;= nums[i] &lt;= 10^4      nums 为 无重复元素的 升序排列数组      -10^4 &lt;= target &lt;= 10^4            题目    func searchInsert(nums []int, target int) int {}            解题      func searchInsert(nums []int, target int) int {    if len(nums) == 0 {      return 0    }    n := len(nums)    ans := n    left, right := 0, n-1    for left &lt;= right {      mid := (right-left)&gt;&gt;1 + left      if target &lt;= nums[mid] {        ans = mid        right = mid - 1      } else {        left = mid + 1      }    }    return ans  }      加一  题目连接      题目说明          给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。      最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。              你可以假设除了整数 0 之外，这个整数不会以零开头。                    示例                  1                  输入：digits = [1,2,3]  输出：[1,2,4]  解释：输入数组表示数字 123。                          2                  输入：digits = [4,3,2,1]  输出：[4,3,2,2]  解释：输入数组表示数字 4321。                          3                    输入：digits = [0]    输出：[1]                            提示          1 &lt;= digits.length &lt;= 100  0 &lt;= digits[i] &lt;= 9                          题目    func plusOne(digits []int) []int {}            解题                  情况 1                              如果输入                          [8,9,9] -&gt; [9,0,0]                                            思路:                          倒序查看元素是否不等 9              当遍历到 8 时候,会把 8++              然后遍历 8 后面所有的元素,后面元素全部修改为 0              返回即可                                                情况 2                  如果输入                  [9,9,9] -&gt; [1,0,0,0]          [9] -&gt; [1,0]                            思路                  再循环中只要不能 9 就直接跳过了          再下面直接增加数组然后直接第一个 index 改为 1 即可                          解题      func plusOne(digits []int) []int {    for i := len(digits) - 1; i &gt;= 0; i-- {      if digits[i] != 9 {        digits[i]++        for j := i + 1; j &lt; len(digits); j++ {          digits[j] = 0        }        return digits      }    }    r := make([]int, len(digits)+1)    r[0] = 1    return r  }      "
  },
  
  {
    "title": "Leetcode 解题方式",
    "url": "/posts/leetcode-okay/",
    "categories": "Dev, Algorith",
    "tags": "Dev, Go, leetcode",
    "date": "2022-01-01 11:08:09 +0800",
    





    
    "snippet": "解题方式暴力枚举查找表哈希表双指针",
    "content": "解题方式暴力枚举查找表哈希表双指针"
  },
  
  {
    "title": "Leetcode Readme",
    "url": "/posts/leetcode-readme/",
    "categories": "Dev, Algorith",
    "tags": "Dev, Go, leetcode",
    "date": "2022-01-01 07:08:08 +0800",
    





    
    "snippet": "LeetCode  中国站  国际站  PS          建议在中国站做完之后，可以去看下国际站，国际上对题目的理解        解题语言全部使用 Golang解题顺序  按照 Tag 分类  从简单到困难解题方法  先思考、写出方法  写出伪代码  写出自己答案  运行查看结果 维度  复习          第一遍：解题      第二遍：写出最优解题方案      第三遍：最快...",
    "content": "LeetCode  中国站  国际站  PS          建议在中国站做完之后，可以去看下国际站，国际上对题目的理解        解题语言全部使用 Golang解题顺序  按照 Tag 分类  从简单到困难解题方法  先思考、写出方法  写出伪代码  写出自己答案  运行查看结果 维度  复习          第一遍：解题      第二遍：写出最优解题方案      第三遍：最快时间写出解题答案      解题 Tag顺序  数组  链表  哈希表  字符串  双指针罚  栈与队列  二叉树  回溯算法  贪心算法  动态规划  单调栈  Other算法性能分析  详细可以查看本站文章：DataStructure  时间复杂度：运行时需要的总步数，通常时问题规模的函数（大 O 表示）          常数 O(1)＜ 对数阶 O(log2n) ＜ 线性阶 O(n) ＜ 线性对数阶 O(nlog2n) ＜ 平方阶 O(n^2) ＜ 多项式阶 O(n^C) ＜ 指数阶 O(C^n)      时间复杂度分析基本策略：从内向外分析，从最深层开始分析      看有 几层循环，一层循环是 O(n)或者 O(log2n)；两层循环是 O(n^2) ；三层循环是 O(n^3) （一般规律如此，具体问题具体分析）        空间复杂度：执行时所占用的储存空间，通常时问题规模的函数,运行过程中临时占用存储空间大小的度量          程序代码所占用的空间      输入数据所占用的空间      辅助变量 所占用的空间（估算时间复杂度，一般值分析辅助变量所占用的空间）      "
  },
  
  {
    "title": "ClickHouse",
    "url": "/posts/clickhouse-base/",
    "categories": "Dev, Database, Clickhouse",
    "tags": "Database, NoSQL",
    "date": "2021-04-08 12:48:54 +0800",
    





    
    "snippet": "ClickHouse 是一个用于实时分析的开源列式数据库管理系统 (DBMS)，它最初由俄罗斯的 Yandex 公司开发，并且在 2016 年开源。下面是一些关于 ClickHouse 的介绍、优缺点以及一些最大阈值的信息：介绍  列式存储 ：ClickHouse 是一个列式存储的数据库，这意味着它将数据按列而不是按行存储。这种存储方式使得它非常适合进行大规模的数据分析和聚合操作。  高性能...",
    "content": "ClickHouse 是一个用于实时分析的开源列式数据库管理系统 (DBMS)，它最初由俄罗斯的 Yandex 公司开发，并且在 2016 年开源。下面是一些关于 ClickHouse 的介绍、优缺点以及一些最大阈值的信息：介绍  列式存储 ：ClickHouse 是一个列式存储的数据库，这意味着它将数据按列而不是按行存储。这种存储方式使得它非常适合进行大规模的数据分析和聚合操作。  高性能 ：ClickHouse 的设计目标之一是提供高性能的数据查询和分析能力。它能够处理大量数据，并且在复杂的查询情况下保持高性能。  分布式架构 ：ClickHouse 支持分布式架构，可以水平扩展以处理大规模数据集。它可以通过添加更多的节点来增加存储容量和查询吞吐量。  SQL 兼容性 ：ClickHouse 支持 SQL 查询语言，这使得用户可以使用熟悉的语法进行数据分析和查询操作。  实时数据分析 ：尽管 ClickHouse 主要用于批处理分析，但它也具有一定的实时查询能力，可以满足一些实时数据分析的需求。优点  高性能 ：ClickHouse 在处理大规模数据集时表现出色，可以快速执行复杂的分析查询。  灵活性 ：它支持 SQL 查询语言，并且可以与常见的 BI 工具和数据处理框架集成，使得用户能够以多种方式进行数据分析。  易于扩展 ：ClickHouse 支持分布式架构，可以通过添加更多的节点来水平扩展以处理更大的数据集。  开源和社区支持 ：作为一个开源项目，ClickHouse 拥有一个活跃的社区，用户可以从社区中获得支持和贡献新的功能和改进。缺点  实时性限制 ：虽然 ClickHouse 具有一定的实时查询能力，但它主要用于批处理分析，对于需要实时数据更新和查询的应用场景可能不够适用。  复杂性 ：配置和管理 ClickHouse 集群可能需要一定的技术知识和经验，特别是在处理大规模数据时。  存储格式转换成本 ：由于 ClickHouse 使用列式存储，因此需要在存储和检索数据之间进行格式转换，这可能会导致一些额外的成本和复杂性。最大阈值ClickHouse 的性能和容量受到多个因素的影响，包括硬件配置、数据模式、查询复杂度等。一般来说，ClickHouse 可以处理非常大的数据集，并且能够在毫秒级的时间内响应查询。然而，具体的最大阈值取决于具体的硬件配置和工作负载。通常情况下，ClickHouse 可以处理数十亿甚至上百亿行的数据，并且能够在大型集群中进行水平扩展以处理更大规模的数据集。"
  },
  
  {
    "title": "Go mod",
    "url": "/posts/go.mod/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils",
    "date": "2021-03-18 18:01:33 +0800",
    





    
    "snippet": "Go mod基础使用 go mod 管理依赖是官方推荐的方式，可以方便地管理代码的版本和依赖。下面是一些常见的 go mod 使用方法：1. 初始化项目在项目的根目录下，执行以下命令初始化 go mod：go mod init &lt;module-name&gt;其中 &lt;module-name&gt; 是项目的模块名，通常是一个域名的反转加上项目名，例如 github.com/exa...",
    "content": "Go mod基础使用 go mod 管理依赖是官方推荐的方式，可以方便地管理代码的版本和依赖。下面是一些常见的 go mod 使用方法：1. 初始化项目在项目的根目录下，执行以下命令初始化 go mod：go mod init &lt;module-name&gt;其中 &lt;module-name&gt; 是项目的模块名，通常是一个域名的反转加上项目名，例如 github.com/example-project。2. 添加依赖假设你要添加一个名为 example-dependency 的依赖，你可以执行以下命令：go get example-dependency这会将 example-dependency 下载到本地，并自动更新 go.mod 文件中的依赖信息。3. 升级依赖你可以使用以下命令来升级项目的依赖：go get -u这会将所有依赖升级到最新版本。4. 构建项目使用 go build 或者 go run 命令来构建或运行项目，go mod 会自动下载依赖并构建项目。5. 清理依赖如果你想要清理掉不再使用的依赖，可以使用以下命令：go mod tidy这会自动删除不再使用的依赖。除了上述基本用法之外，go mod 还支持许多其他的功能，例如指定依赖的版本、使用私有仓库等。熟悉 go mod 的使用可以提高项目的开发效率和代码的可维护性。高级使用1. 指定依赖版本可以使用以下命令指定依赖的版本：go get example-dependency@v1.2.3其中 v1.2.3 是依赖的具体版本。2. 使用代理下载依赖如果因为某些原因无法直接从官方源下载依赖，可以使用代理来下载依赖。例如，使用 goproxy.io 作为代理：go env -w GOPROXY=https://goproxy.io,direct这会将代理地址设置为 https://goproxy.io，如果代理无法使用，会直接从官方源下载。3. 使用私有仓库如果依赖不在公共仓库中，可以使用私有仓库来下载依赖。例如，使用 gitlab.com 作为私有仓库：go env -w GOPRIVATE=gitlab.com这会将 gitlab.com 设置为私有仓库，go mod 会从该仓库下载依赖。4. 使用本地包如果你正在开发一个本地的包或者库，可以使用以下命令将其添加到 go.mod 文件中：go mod edit -replace example-package=../example-package其中 example-package 是本地包的名称，../example-package 是本地包的路径。5. 禁止自动更新依赖如果你想要禁止自动更新依赖，可以在 go.mod 文件中添加以下内容：go 1.16...go 1.17...这会锁定 Golang 的版本，禁止自动更新。go.mod 使用replace (\tsource latest =&gt; target latest)require (\tdependency latest)retract (  v0.1.0  v0.2.0)  requirere：记录了项目依赖的库和版本号  replace：用于指定模块的替换品（通常是本地路径），例如 replace example.com/old =&gt; example.com/new 表示使用本地路径 example.com/new 替换所有引用 example.com/old 的模块  retract：新特性给予了 Go modules 软撤回版本的一个方法，能够把问题更直观的反馈到开发者的手中  exclude：用于排除特定模块版本的依赖项，例如 exclude example.com/old v1.0.0 表示排除版本为 v1.0.0 的 example.com/old 依赖项用于指定模块的替换品（通常是本地路径），例如 replace example.com/old =&gt; example.com/new 表示使用本地路径 example.com/new 替换所有引用 example.com/old 的模块。"
  },
  
  {
    "title": "Pprof",
    "url": "/posts/pprof/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils, GoPprof",
    "date": "2021-03-17 18:01:33 +0800",
    





    
    "snippet": "Go pprof And Prometheus在代码中使用import (  ...\t_ \"net/http/pprof\"  \"github.com/prometheus/client_golang/prometheus/promhttp\"  ...)func main() { \tgo func() {\t\thttp.Handle(\"/metrics\", promhttp.Handler())...",
    "content": "Go pprof And Prometheus在代码中使用import (  ...\t_ \"net/http/pprof\"  \"github.com/prometheus/client_golang/prometheus/promhttp\"  ...)func main() { \tgo func() {\t\thttp.Handle(\"/metrics\", promhttp.Handler())\t\t_ = http.ListenAndServe(\"14111\", nil) // '14111' 建议使用flag\t}()}浏览器查看  http:/172.13.5.17:14111/debug/pprof/ &gt; 使用命令行查看所有go tool pprof http://172.13.5.17:14611/debug/pprof/profile  # 查看profile(pprof) topShowing nodes accounting for 3170ms, 64.69% of 4900ms totalDropped 260 nodes (cum &lt;= 24.50ms)Showing top 10 nodes out of 207      flat  flat%   sum%        cum   cum%    1180ms 24.08% 24.08%     1180ms 24.08%  runtime.futex     560ms 11.43% 35.51%      600ms 12.24%  syscall.Syscall     460ms  9.39% 44.90%      460ms  9.39%  runtime.epollwait     370ms  7.55% 52.45%      370ms  7.55%  runtime.usleep     220ms  4.49% 56.94%      300ms  6.12%  runtime.scanobject      90ms  1.84% 58.78%       90ms  1.84%  runtime.lock      80ms  1.63% 60.41%       80ms  1.63%  runtime.step      70ms  1.43% 61.84%     1590ms 32.45%  runtime.findrunnable      70ms  1.43% 63.27%       90ms  1.84%  runtime.nanotime (inline)      70ms  1.43% 64.69%       70ms  1.43%  runtime.siftdownTimer(pprof)go tool pprof http://172.13.5.17:14611/debug/pprof/heap  # heap 查看那部分代码占比 比较高-------------------------------- top(pprof) topShowing nodes accounting for 28238.94kB, 80.86% of 34922.60kB totalShowing top 10 nodes out of 151      flat  flat%   sum%        cum   cum%10752.80kB 30.79% 30.79% 12752.05kB 36.52%  time.NewTimer 3598.02kB 10.30% 41.09%  3598.02kB 10.30%  bufio.NewReaderSize 3598.02kB 10.30% 51.40%  3598.02kB 10.30%  bufio.NewWriterSize 2200.03kB  6.30% 57.70%  2200.03kB  6.30%  google.golang.org/protobuf/internal/strs.(*Builder).AppendFullName 2054.76kB  5.88% 63.58%  2054.76kB  5.88%  git.huoys.com/indonesia/game/chess/qiuqiu/logic.(*CardList).shuffle 1999.25kB  5.72% 69.30%  1999.25kB  5.72%  time.startTimer 1536.56kB  4.40% 73.70%  1536.56kB  4.40%  runtime.malg 1052.25kB  3.01% 76.72%  1052.25kB  3.01%  sync.(*Map).dirtyLocked  902.59kB  2.58% 79.30%   902.59kB  2.58%  compress/flate.NewWriter  544.67kB  1.56% 80.86%   544.67kB  1.56%  bytes.makeSlice(pprof)-------------------------------- list 查看方法(pprof) list shuffleTotal: 34.10MBROUTINE ======================== git.huoys.com/indonesia/game/chess/qiuqiu/logic.(*CardList).shuffle in /go/src/git.huoys.com/indonesia/game/chess/qiuqiu/logic/card_help.go    2.01MB     2.01MB (flat, cum)  5.88% of Total         .          .      8:         .          .      9:// 洗牌         .          .     10:func (p *CardList) shuffle() {         .          .     11:   p.cardsMap = make(map[xproto.CardID]GoQiuQiu)         .          .     12:   for _, v := range _goQiuQiu {    2.01MB     2.01MB     13:           p.cardsMap[v.CardId] = v         .          .     14:   }         .          .     15:}         .          .     16:         .          .     17:// DispatchHandCardDebug Debug 发牌模式         .          .     18:func (p *CardList) DispatchHandCardDebug(cardIds ...int) *HandCard {(pprof)-------------------------------- web （需要安装graphviz命令才能使用生成一个.svg 浏览器打开即可）-------------------------------- 下面几个都可以使用 top list web ;或者可以直接 help 查看帮助帮助命令go tool pprof http://172.13.5.17:14611/debug/pprof/allocsgo tool pprof http://172.13.5.17:14611/debug/pprof/goroutinego tool pprof http://172.13.5.17:14611/debug/pprof/mutexgo tool pprof http://172.13.5.17:14611/debug/pprof/block使用浏览器直接查看      定位问题          查看服务使用 cpu      内存使用情况磁盘和 io 使用情况            使用工具                                                      ps -aux              grep qiuqiu ——–&gt; 查找服务                                          stop -p pid ——–&gt; CPU 内存      iotop -p pid ——–&gt; 磁盘 io            分析问题                  生成pprof文件                  go tool pprof http://172.13.5.17:14611/debug/pprof/profile （默认放在 cd $HOME/pprof/ ）          可以看到会生成这样的文件 /Users/cc/pprof/pprof.qiuqiu.samples.cpu.002.pb.gz                            go tool pprof -http=0.0.0.0:999 /Users/cc/pprof/pprof.qiuqiu.samples.cpu.002.pb.gz （使用浏览器预览生成的文件查看服务状态）                    查看火焰图方法                            火焰图详情                    "
  },
  
  {
    "title": "Pprof 监听",
    "url": "/posts/pprof-pro/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils, GoPprof",
    "date": "2021-03-17 18:01:33 +0800",
    





    
    "snippet": "获取 60 秒数据go tool pprof http://localhost:9999/debug/pprof/profile\\?seconds=60http://localhost:9999/ui/1.开发一个能够并发且正常游戏的模拟客户端（我这边有一套比较简陋的代码，支持批量创建玩家、登陆玩家、修改玩家道具，只需要实现跟业务相关的逻辑即可）2. 在游戏服务器代码中启用 pprof首先添...",
    "content": "获取 60 秒数据go tool pprof http://localhost:9999/debug/pprof/profile\\?seconds=60http://localhost:9999/ui/1.开发一个能够并发且正常游戏的模拟客户端（我这边有一套比较简陋的代码，支持批量创建玩家、登陆玩家、修改玩家道具，只需要实现跟业务相关的逻辑即可）2. 在游戏服务器代码中启用 pprof首先添加 pprof 库， import _ \"net/http/pprof\"然后启动 http 监听一个端口 http.ListenAndServe(\":9999\", nil)3.启动服务器，并监测服务器的资源使用情况启动服务器后，使用 ps -aux | grep servername 查找服务器对应的 pid使用 htop -p pid 监测服务器进程 cpu 和内存的使用情况使用 iotop -p pid 监测服务器进程磁盘 io 的使用情况4.用模拟客户端进行压测建议使用多个实例分批次进行并发压测。比如要压测 500 个玩家，可以分成 5 批 100 个玩家，先登陆第一批玩家，等第一批玩家开始游戏了，再登陆第二批玩家。这样做的好处，一是可以避免瞬间的高峰把服务器搞挂了。二是能够较为真实的模拟不同玩家在不同时间的操作，可以更好地暴露问题。5.收集数据进入压测状态后，使用 go tool pprof http://localhost:9999/debug/pprof/profile 收集服务器的数据。收集 30s 后在进入命令行模式后输入 quit 退出，会生成名为【pprof.servername.samples.cpu.00x.pb.gz】的文件，默认放到$HOME/pprof/下。此时可以记录相应的峰值 cpu、内存、io 的使用情况也可以通过游戏客户端登陆进行更为直观的体验，可以发现游戏是否存在卡顿，延迟等问题。6.问题分析和优化6.1 CPU 过高使用 go tool pprof -http=ip:9998 [步骤5中生成的文件] 解读 pprof 文件。访问对应的端口，可以在 VIEW/Flame Graph里面看到压测时的火焰图，进而分析耗 CPU 操作。6.2 内存过高首先判断是否存在内存泄漏。如果没有泄漏，则分析代码看是否有优化的空间。如果有泄漏，可以使用 valgrind进行检测。6.3 io 过高通过 iostat -x 1查看 io 是否到达瓶颈。主要看 r/s（每秒完成的读io） w/s（每秒完成的写io） await（平均每次io的等待时间） svctm（平均每次io的服务时间）6.4 死锁通过访问服务器监听的端口（以上面为例，为 9999），通过 full goroutine stack dump 分析整个游戏的协程情况，结合代码分析问题。6.5 链接读写通过 netstat -nap | head 观察 Recv-Q 和 Send-Q 是否为零，如果不为 0，则说明有阻塞存在，导致数据读写延迟。6.6 其他如果上面几个方面都没有问题，但是游戏依然出现卡顿或者延迟的情况，可以考虑分析游戏依赖的服务是否出现问题，比如大厅、redis、中台等。因为 go 协程的特性，当有协程这些请求外部服务阻塞时，会切换到其他协程进行工作，所以无法从火焰图上看到真实的阻塞的耗时情况。比如压测时，其他游戏也出现延迟、无法登陆等，那很有可能是我们并发请求大厅的数量过高，导致大厅响应延迟，影响了其他游戏。开发服的大厅是 2 核，大概能接受 200+qps，测试服是 4 核，大概 500qps 就会出现很明显的延迟。"
  },
  
  {
    "title": "定时任务",
    "url": "/posts/cron/",
    "categories": "Language, Go",
    "tags": "Go",
    "date": "2021-03-17 18:01:33 +0800",
    





    
    "snippet": "测试package mainimport (\t\"fmt\"\t\"github.com/robfig/cron/v3\"\t\"time\")func main() {\t// 开启秒字段支持\tc := cron.New(cron.WithSeconds())\t// 传统表达式写法: 每秒执行一次\t_, _ = c.AddFunc(\"0/1 * * * * *\", func() {\t\tfmt.Println...",
    "content": "测试package mainimport (\t\"fmt\"\t\"github.com/robfig/cron/v3\"\t\"time\")func main() {\t// 开启秒字段支持\tc := cron.New(cron.WithSeconds())\t// 传统表达式写法: 每秒执行一次\t_, _ = c.AddFunc(\"0/1 * * * * *\", func() {\t\tfmt.Println(\"传统表达式: \",time.Now().Format(\"2006-01-02 15:04:05\"))\t})\t// 预定义表达式\t_,_ = c.AddFunc(\"@every 1s\", func() {\t\tfmt.Println(\"预定义表达式: \",time.Now().Format(\"2006-01-02 15:04:05\"))\t})\t// 启动\tc.Start()\t// 防止程序直接退出\ttime.Sleep(time.Second * 3)}/**输出预定义表达式:  2021-07-18 10:44:52传统表达式:   2021-07-18 10:44:52传统表达式:   2021-07-18 10:44:53预定义表达式:  2021-07-18 10:44:53传统表达式:    2021-07-18 10:44:54预定义表达式:  2021-07-18 10:44:54*/@注意：下面表格示例，是在开启秒级级别支持情况下的写法。            表达式      说明                  * * * * * *      每秒执行一次              0 */1 * * * *      每分钟执行一次              0 0 */1 * * *      每小时执行一次              0 0 0 */1 * *      每天00:00执行一次              0 30 23 */1 * *      每天23:30执行一次              0 0 0 1 */1 *      每月的第一天执行              0 30 21 * * 1      每周一21:30执行      5.2 预定义时间1. 预表达式上面通过表达式写，很容易会写错，还好cron提供了预表达式，可以很方便各种场景的示例,具体如下:            表达式      描述      等式                  @yearly (or @annually)      每年 1 月 1 日 00:00:00 执行一次      0 0 0 1 1 *              @monthly      每个月第一天的 00:00:00 执行一次      0 0 0 1 * *              @weekly      每周周六的 00:00:00 执行一次      0 0 0 * * 0              @daily (or @midnight)      每天 00:00:00 执行一次      0 0 0 * * *              @hourly      每小时执行一次      0 0 * * * *              @every duration      指定时间间隔执行一次，如 @every 5s，每隔 5 秒执行一次。      0/5 * * * * *      2. 固定间隔(@every )@every duration`含义为每隔`duration`触发一次。`&lt;duration&gt;`会调用`time.ParseDuration()`函数解析，所以`ParseDuration`支持的格式都可以。单位为`h(小时)、m(分钟)、s(秒)            表达式      说明                  @every 1s      每秒钟执行一次              @every 1m      每分钟执行一次              @every 1h      每小时执行一次              @every 1h1m      每小时一分钟执行一次      "
  },
  
  {
    "title": "Kubernetes UI",
    "url": "/posts/kubernetesUI/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2021-03-17 17:45:54 +0800",
    





    
    "snippet": "kubernetes UIkubectl apply -f kuboard-v3.yaml访问http://172.13.8.15:30080/kuboard/settings/uikuboard-v3.yaml---apiVersion: v1kind: Namespacemetadata:  name: kuboard---apiVersion: v1kind: ConfigMapmet...",
    "content": "kubernetes UIkubectl apply -f kuboard-v3.yaml访问http://172.13.8.15:30080/kuboard/settings/uikuboard-v3.yaml---apiVersion: v1kind: Namespacemetadata:  name: kuboard---apiVersion: v1kind: ConfigMapmetadata:  name: kuboard-v3-config  namespace: kuboarddata:  # 关于如下参数的解释，请参考文档 https://kuboard.cn/install/v3/install-built-in.html  # [common]  KUBOARD_SERVER_NODE_PORT: \"30080\"  KUBOARD_AGENT_SERVER_UDP_PORT: \"30081\"  KUBOARD_AGENT_SERVER_TCP_PORT: \"30081\"  KUBOARD_SERVER_LOGRUS_LEVEL: info # error / debug / trace  # KUBOARD_AGENT_KEY 是 Agent 与 Kuboard 通信时的密钥，请修改为一个任意的包含字母、数字的32位字符串，此密钥变更后，需要删除 Kuboard Agent 重新导入。  KUBOARD_AGENT_KEY: 32b7d6572c6255211b4eec9009e4a816  KUBOARD_AGENT_IMAG: eipwork/kuboard-agent  KUBOARD_QUESTDB_IMAGE: questdb/questdb:6.0.4  # 关于如下参数的解释，请参考文档 https://kuboard.cn/install/v3/install-gitlab.html  # [gitlab login]  # KUBOARD_LOGIN_TYPE: \"gitlab\"  # KUBOARD_ROOT_USER: \"your-user-name-in-gitlab\"  # GITLAB_BASE_URL: \"http://gitlab.mycompany.com\"  # GITLAB_APPLICATION_ID: \"7c10882aa46810a0402d17c66103894ac5e43d6130b81c17f7f2d8ae182040b5\"  # GITLAB_CLIENT_SECRET: \"77c149bd3a4b6870bffa1a1afaf37cba28a1817f4cf518699065f5a8fe958889\"  # 关于如下参数的解释，请参考文档 https://kuboard.cn/install/v3/install-github.html  # [github login]  # KUBOARD_LOGIN_TYPE: \"github\"  # KUBOARD_ROOT_USER: \"your-user-name-in-github\"  # GITHUB_CLIENT_ID: \"17577d45e4de7dad88e0\"  # GITHUB_CLIENT_SECRET: \"ff738553a8c7e9ad39569c8d02c1d85ec19115a7\"  # 关于如下参数的解释，请参考文档 https://kuboard.cn/install/v3/install-ldap.html  # [ldap login]  # KUBOARD_LOGIN_TYPE: \"ldap\"  # KUBOARD_ROOT_USER: \"your-user-name-in-ldap\"  # LDAP_HOST: \"ldap-ip-address:389\"  # LDAP_BIND_DN: \"cn=admin,dc=example,dc=org\"  # LDAP_BIND_PASSWORD: \"admin\"  # LDAP_BASE_DN: \"dc=example,dc=org\"  # LDAP_FILTER: \"(objectClass=posixAccount)\"  # LDAP_ID_ATTRIBUTE: \"uid\"  # LDAP_USER_NAME_ATTRIBUTE: \"uid\"  # LDAP_EMAIL_ATTRIBUTE: \"mail\"  # LDAP_DISPLAY_NAME_ATTRIBUTE: \"cn\"  # LDAP_GROUP_SEARCH_BASE_DN: \"dc=example,dc=org\"  # LDAP_GROUP_SEARCH_FILTER: \"(objectClass=posixGroup)\"  # LDAP_USER_MACHER_USER_ATTRIBUTE: \"gidNumber\"  # LDAP_USER_MACHER_GROUP_ATTRIBUTE: \"gidNumber\"  # LDAP_GROUP_NAME_ATTRIBUTE: \"cn\"---apiVersion: v1kind: ServiceAccountmetadata:  name: kuboard-boostrap  namespace: kuboard---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  name: kuboard-boostrap-crbroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:  - kind: ServiceAccount    name: kuboard-boostrap    namespace: kuboard---apiVersion: apps/v1kind: DaemonSetmetadata:  labels:    k8s.kuboard.cn/name: kuboard-etcd  name: kuboard-etcd  namespace: kuboardspec:  revisionHistoryLimit: 10  selector:    matchLabels:      k8s.kuboard.cn/name: kuboard-etcd  template:    metadata:      labels:        k8s.kuboard.cn/name: kuboard-etcd    spec:      affinity:        nodeAffinity:          requiredDuringSchedulingIgnoredDuringExecution:            nodeSelectorTerms:              - matchExpressions:                  - key: node-role.kubernetes.io/master                    operator: Exists              - matchExpressions:                  - key: node-role.kubernetes.io/control-plane                    operator: Exists              - matchExpressions:                  - key: k8s.kuboard.cn/role                    operator: In                    values:                      - etcd      containers:        - env:            - name: HOSTNAME              valueFrom:                fieldRef:                  apiVersion: v1                  fieldPath: spec.nodeName            - name: HOSTIP              valueFrom:                fieldRef:                  apiVersion: v1                  fieldPath: status.hostIP          image: \"eipwork/etcd-host:3.4.16-1\"          imagePullPolicy: Always          name: etcd          ports:            - containerPort: 2381              hostPort: 2381              name: server              protocol: TCP            - containerPort: 2382              hostPort: 2382              name: peer              protocol: TCP          livenessProbe:            failureThreshold: 3            httpGet:              path: /health              port: 2381              scheme: HTTP            initialDelaySeconds: 30            periodSeconds: 10            successThreshold: 1            timeoutSeconds: 1          volumeMounts:            - mountPath: /data              name: data      dnsPolicy: ClusterFirst      hostNetwork: true      restartPolicy: Always      serviceAccount: kuboard-boostrap      serviceAccountName: kuboard-boostrap      tolerations:        - key: node-role.kubernetes.io/master          operator: Exists        - key: node-role.kubernetes.io/control-plane          operator: Exists      volumes:        - hostPath:            path: /usr/share/kuboard/etcd          name: data  updateStrategy:    rollingUpdate:      maxUnavailable: 1    type: RollingUpdate---apiVersion: apps/v1kind: Deploymentmetadata:  annotations: {}  labels:    k8s.kuboard.cn/name: kuboard-v3  name: kuboard-v3  namespace: kuboardspec:  replicas: 1  revisionHistoryLimit: 10  selector:    matchLabels:      k8s.kuboard.cn/name: kuboard-v3  template:    metadata:      labels:        k8s.kuboard.cn/name: kuboard-v3    spec:      affinity:        nodeAffinity:          preferredDuringSchedulingIgnoredDuringExecution:            - preference:                matchExpressions:                  - key: node-role.kubernetes.io/master                    operator: Exists              weight: 100            - preference:                matchExpressions:                  - key: node-role.kubernetes.io/control-plane                    operator: Exists              weight: 100      containers:        - env:            - name: HOSTIP              valueFrom:                fieldRef:                  apiVersion: v1                  fieldPath: status.hostIP            - name: HOSTNAME              valueFrom:                fieldRef:                  apiVersion: v1                  fieldPath: spec.nodeName          envFrom:            - configMapRef:                name: kuboard-v3-config          image: \"eipwork/kuboard:v3\"          imagePullPolicy: Always          livenessProbe:            failureThreshold: 3            httpGet:              path: /kuboard-resources/version.json              port: 80              scheme: HTTP            initialDelaySeconds: 30            periodSeconds: 10            successThreshold: 1            timeoutSeconds: 1          name: kuboard          ports:            - containerPort: 80              name: web              protocol: TCP            - containerPort: 443              name: https              protocol: TCP            - containerPort: 10081              name: peer              protocol: TCP            - containerPort: 10081              name: peer-u              protocol: UDP          readinessProbe:            failureThreshold: 3            httpGet:              path: /kuboard-resources/version.json              port: 80              scheme: HTTP            initialDelaySeconds: 30            periodSeconds: 10            successThreshold: 1            timeoutSeconds: 1          resources: {}          # startupProbe:          #   failureThreshold: 20          #   httpGet:          #     path: /kuboard-resources/version.json          #     port: 80          #     scheme: HTTP          #   initialDelaySeconds: 5          #   periodSeconds: 10          #   successThreshold: 1          #   timeoutSeconds: 1      dnsPolicy: ClusterFirst      restartPolicy: Always      serviceAccount: kuboard-boostrap      serviceAccountName: kuboard-boostrap      tolerations:        - key: node-role.kubernetes.io/master          operator: Exists---apiVersion: v1kind: Servicemetadata:  annotations: {}  labels:    k8s.kuboard.cn/name: kuboard-v3  name: kuboard-v3  namespace: kuboardspec:  ports:    - name: web      nodePort: 30080      port: 80      protocol: TCP      targetPort: 80    - name: tcp      nodePort: 30081      port: 10081      protocol: TCP      targetPort: 10081    - name: udp      nodePort: 30081      port: 10081      protocol: UDP      targetPort: 10081  selector:    k8s.kuboard.cn/name: kuboard-v3  sessionAffinity: None  type: NodePort"
  },
  
  {
    "title": "Kubernetes 部署",
    "url": "/posts/k8s-base/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2021-03-17 16:43:33 +0800",
    





    
    "snippet": "Kubernetes 搭建准备在搭建 Kubernetes 之前，您需要先准备一些必要的配置和工具，包括：      至少三个节点：用于部署 Kubernetes 集群的主机。一般情况下，建议使用至少三个物理或虚拟机来搭建 Kubernetes 集群，以确保高可用性和容错性。        操作系统：Kubernetes 支持多种操作系统，例如 Ubuntu、CentOS 等。建议使用最新版...",
    "content": "Kubernetes 搭建准备在搭建 Kubernetes 之前，您需要先准备一些必要的配置和工具，包括：      至少三个节点：用于部署 Kubernetes 集群的主机。一般情况下，建议使用至少三个物理或虚拟机来搭建 Kubernetes 集群，以确保高可用性和容错性。        操作系统：Kubernetes 支持多种操作系统，例如 Ubuntu、CentOS 等。建议使用最新版本的操作系统，并按照官方文档进行配置。        容器运行时：Kubernetes 支持多种容器运行时，如 Docker、Containerd、CRI-O 等。建议使用 Docker 作为容器运行时。        Kubernetes 工具集：Kubernetes 提供了一些工具，例如 kubeadm、kubectl 和 kubelet 等，用于搭建、管理和监控 Kubernetes 集群。        网络插件：Kubernetes 需要一个网络插件来处理容器网络通信。常见的网络插件有 Calico、Flannel 和 Weave Net 等。  接下来是 Kubernetes 的搭建步骤：      在每个节点上安装 Docker 和 Kubernetes 工具集。        使用 kubeadm 工具初始化 Kubernetes 控制节点，并创建一个 Kubernetes 集群。        添加更多的节点到 Kubernetes 集群中。        安装和配置网络插件，以实现容器网络通信。        部署应用程序和服务到 Kubernetes 集群中，并通过 kubectl 命令进行管理和监控。  最低配置Kubernetes 的硬件要求主要由 Master 节点和 Node 节点的配置决定。以下是 Kubernetes 推荐的最低硬件配置：      Master 节点：          CPU：至少 2 核心      内存：至少 2 GB RAM      磁盘空间：至少 20 GB            Node 节点：          CPU：至少 2 核心      内存：至少 2 GB RAM      磁盘空间：至少 20 GB      需要注意的是，以上硬件配置只是 Kubernetes 的最低要求，如果您希望集群具有更好的性能和可靠性，可以考虑增加 CPU、内存和磁盘空间等资源。搭建前 master/node在部署 Kubernetes 集群之前，您需要进行一些节点的预配置工作。下面是一些常见的命令，用于关闭防火墙、Swap 分区、SELinux，并修改主机名：      关闭防火墙：    # CentOS 7/8systemctl stop firewalldsystemctl disable firewalld# Ubuntu 16.04/18.04/20.04ufw disable            关闭 Swap 分区（建议在所有节点上执行）：    swapoff -ased -i '/ swap / s/^/#/' /etc/fstab            关闭 SELinux：    setenforce 0sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config            修改主机名（每个节点都要执行）：    hostnamectl set-hostname &lt;NEW_HOSTNAME&gt;            查看查询系统基本信息    uname -a #  查看版本当前操作系统内核信息cat /proc/version # 查看当前系统版本信息cat /etc/issue # 查看版本当前操作系统发行版本信息cat /etc/redhat-release # 查看版本当前操作系统发行版本信息cat /proc/cpuinfo  # OR lscpu 查看CPU相关信息，包括型号、主频、内核信息getconf LONG_BIT # 看版本说明当前CPU运行在32bit模式下， 但不代表CPU不支持64bithostname # 查看服务器名称# 查看网络信息cat /etc/sysconfig/network-scripts/ifcfg-ens*cat /etc/sysconfig/network-scripts/ifcfg-loifconfiglsblk # 查看磁盘信息 - 列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息fdisk -l # 观察硬盘实体使用情况，也可对硬盘分区df -k # df -k # 用于显示磁盘分区上的可使用的磁盘空env # 查看环境变量iptables -L # 查看防火墙设置route -n # 查看路由表swapon -s # 查看所有交换分区w # 查看活动用户last # 查看用户登录信息      搭建前准备 （master/node）      关闭防火墙    systemctl stop firewalldsystemctl disable firewalldsystemctl status firewalld # 查看下状态            警用 Swp    vim /etc/fstab# 注释 swap 行swapoff -a            关闭 selinux    sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config # 永久关闭            修改主机名    hostnamectl set-hostname master # 永久生效 但需要重启hostnamectl set-hostname nodeOne # 永久生效 但需要重启hostnamectl set-hostname nodeTwo # 永久生效 但需要重启reboot # 重启            修改hosts    vim /etc/hosts      安装 docker 20.10.1 （master/node）#!/bin/bashyum remove runc -yyum install container-selinux yum-utils ipvsadm -yrpm -ivh https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.4.3-3.1.el7.x86_64.rpmyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum clean allyum makecacheyum install docker-ce docker-ce-cli -ymkdir -p /data/docker /data/kubelet  /etc/docker /data/kubelet/plugins/nasplugin.csi.alibabacloud.comtouch  /etc/docker/daemon.jsoncat &gt; /etc/docker/daemon.json &lt;&lt;EOF{    \"data-root\": \"/data/docker\",    \"registry-mirrors\": [        \"https://6mrynkvw.mirror.aliyuncs.com\"    ],    \"exec-opts\": [\"native.cgroupdriver=systemd\"],    \"log-driver\": \"json-file\",    \"log-opts\": {        \"max-size\": \"100m\"    },    \"storage-driver\": \"overlay2\",    \"storage-opts\": [        \"overlay2.override_kernel_check=true\"            ]    }EOFsystemctl enable docker &amp;&amp; systemctl start docker设置阿里云 yum 软件源 （master/node）cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[k8s]name=k8senabled=1gpgcheck=0baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/EOF安装 kubeadm、kubelet、kubectl （master/node） yum install -y kubelet-1.19.2 kubectl-1.19.2 kubeadm-1.19.2 systemctl enable kubeletkubernetes init （master） echo \"1\" &gt;/proc/sys/net/bridge/bridge-nf-call-iptables kubeadm init \\  --apiserver-advertise-address=172.13.8.15 \\  --image-repository registry.aliyuncs.com/google_containers \\  --kubernetes-version v1.19.2 \\  --service-cidr=10.1.0.0/16 \\  --pod-network-cidr=10.244.0.0/16成功信息[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] Creating the \"cluster-info\" ConfigMap in the \"kube-public\" namespace[kubelet-finalize] Updating \"/etc/kubernetes/kubelet.conf\" to point to a rotatable kubelet client certificate and key[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 172.13.8.15:6443 --token etvpqx.urx0nmbm4w4wwmt9 \\    --discovery-token-ca-cert-hash sha256:744f6cd77ba585411ddde4a8ed181859c17643df0c90ba4ec7eb859b69875bcd输入创建测试是否 OK（master/node）  scp admin.conf root@172.13.8.17:/etc/kubernetes  scp admin.conf root@172.13.8.16:/etc/kubernetes  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/config  kubectl get nodes  # 测试安装网络插件kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml # 会提示报错，修改hosts# 追加hosts# 199.232.28.133 raw.githubusercontent.comnode 加入 master 集群中# 在成功init 成功之后输出的内容kubeadm join 172.13.8.15:6443 --token etvpqx.urx0nmbm4w4wwmt9 \\    --discovery-token-ca-cert-hash sha256:744f6cd77ba585411ddde4a8ed181859c17643df0c90ba4ec7eb859b69875bcd后记      kubeadm init 之后没有来得及记录 join 信息    #再生成一个token即可kubeadm token create --print-join-command#下在的命令可以查看历史的tokenkubeadm token list            node join 失败后 重新 join    #先执行kubeadm -y reset#再执行kubeadm join  xx.....            重启 kubelet    systemctl daemon-reloadsystemctl restart kubelet      维护      ROLES 为 none    kubectl label node nodeone node-role.kubernetes.io/worker=workerkubectl label node nodetwo node-role.kubernetes.io/worker=worker      Error      /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1    echo \"1\" &gt;/proc/sys/net/bridge/bridge-nf-call-iptables # 解决方法      插件yml      kube-flannel.yml    ---apiVersion: policy/v1beta1kind: PodSecurityPolicymetadata:  name: psp.flannel.unprivileged  annotations:    seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default    seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default    apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default    apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/defaultspec:  privileged: false  volumes:  - configMap  - secret  - emptyDir  - hostPath  allowedHostPaths:  - pathPrefix: \"/etc/cni/net.d\"  - pathPrefix: \"/etc/kube-flannel\"  - pathPrefix: \"/run/flannel\"  readOnlyRootFilesystem: false  # Users and groups  runAsUser:    rule: RunAsAny  supplementalGroups:    rule: RunAsAny  fsGroup:    rule: RunAsAny  # Privilege Escalation  allowPrivilegeEscalation: false  defaultAllowPrivilegeEscalation: false  # Capabilities  allowedCapabilities: ['NET_ADMIN', 'NET_RAW']  defaultAddCapabilities: []  requiredDropCapabilities: []  # Host namespaces  hostPID: false  hostIPC: false  hostNetwork: true  hostPorts:  - min: 0    max: 65535  # SELinux  seLinux:    # SELinux is unused in CaaSP    rule: 'RunAsAny'---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata:  name: flannelrules:- apiGroups: ['extensions']  resources: ['podsecuritypolicies']  verbs: ['use']  resourceNames: ['psp.flannel.unprivileged']- apiGroups:  - \"\"  resources:  - pods  verbs:  - get- apiGroups:  - \"\"  resources:  - nodes  verbs:  - list  - watch- apiGroups:  - \"\"  resources:  - nodes/status  verbs:  - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: flannelroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: flannelsubjects:- kind: ServiceAccount  name: flannel  namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata:  name: flannel  namespace: kube-system---kind: ConfigMapapiVersion: v1metadata:  name: kube-flannel-cfg  namespace: kube-system  labels:    tier: node    app: flanneldata:  cni-conf.json: |    {      \"name\": \"cbr0\",      \"cniVersion\": \"0.3.1\",      \"plugins\": [        {          \"type\": \"flannel\",          \"delegate\": {            \"hairpinMode\": true,            \"isDefaultGateway\": true          }        },        {          \"type\": \"portmap\",          \"capabilities\": {            \"portMappings\": true          }        }      ]    }  net-conf.json: |    {      \"Network\": \"10.244.0.0/16\",      \"Backend\": {        \"Type\": \"vxlan\"      }    }---apiVersion: apps/v1kind: DaemonSetmetadata:  name: kube-flannel-ds  namespace: kube-system  labels:    tier: node    app: flannelspec:  selector:    matchLabels:      app: flannel  template:    metadata:      labels:        tier: node        app: flannel    spec:      affinity:        nodeAffinity:          requiredDuringSchedulingIgnoredDuringExecution:            nodeSelectorTerms:            - matchExpressions:              - key: kubernetes.io/os                operator: In                values:                - linux      hostNetwork: true      priorityClassName: system-node-critical      tolerations:      - operator: Exists        effect: NoSchedule      serviceAccountName: flannel      initContainers:      - name: install-cni-plugin        image: rancher/mirrored-flannelcni-flannel-cni-plugin:v1.0.0        command:        - cp        args:        - -f        - /flannel        - /opt/cni/bin/flannel        volumeMounts:        - name: cni-plugin          mountPath: /opt/cni/bin      - name: install-cni        image: quay.io/coreos/flannel:v0.15.1        command:        - cp        args:        - -f        - /etc/kube-flannel/cni-conf.json        - /etc/cni/net.d/10-flannel.conflist        volumeMounts:        - name: cni          mountPath: /etc/cni/net.d        - name: flannel-cfg          mountPath: /etc/kube-flannel/      containers:      - name: kube-flannel        image: quay.io/coreos/flannel:v0.15.1        command:        - /opt/bin/flanneld        args:        - --ip-masq        - --kube-subnet-mgr        resources:          requests:            cpu: \"100m\"            memory: \"50Mi\"          limits:            cpu: \"100m\"            memory: \"50Mi\"        securityContext:          privileged: false          capabilities:            add: [\"NET_ADMIN\", \"NET_RAW\"]        env:        - name: POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name        - name: POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        volumeMounts:        - name: run          mountPath: /run/flannel        - name: flannel-cfg          mountPath: /etc/kube-flannel/      volumes:      - name: run        hostPath:          path: /run/flannel      - name: cni-plugin        hostPath:          path: /opt/cni/bin      - name: cni        hostPath:          path: /etc/cni/net.d      - name: flannel-cfg        configMap:          name: kube-flannel-cfg      "
  },
  
  {
    "title": "Dart Readme",
    "url": "/posts/dart-readme/",
    "categories": "Language, Dart",
    "tags": "Client, Dart",
    "date": "2021-02-12 22:58:36 +0800",
    





    
    "snippet": "Dart环境安装  下载DartSDK  添加环境变量    export DART_HOME=/usr/local/dart/dart-sdk/binexport PATH=\"${DART_HOME}:${PATH}\"      ",
    "content": "Dart环境安装  下载DartSDK  添加环境变量    export DART_HOME=/usr/local/dart/dart-sdk/binexport PATH=\"${DART_HOME}:${PATH}\"      "
  },
  
  {
    "title": "Go 1.13 版本更新 摘要",
    "url": "/posts/go-1.13/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoVersion",
    "date": "2020-12-25 17:11:22 +0800",
    





    
    "snippet": "Go 1.13  工具链、运行时、标准库工具链  环境变量 Go111MODOULE 默认值 auto  增加了环境变量 GOPIVATE 私有变量",
    "content": "Go 1.13  工具链、运行时、标准库工具链  环境变量 Go111MODOULE 默认值 auto  增加了环境变量 GOPIVATE 私有变量"
  },
  
  {
    "title": "Micro hello Index",
    "url": "/posts/Go-Microother/",
    "categories": "Language, Go",
    "tags": "GoWeb",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "go-micro 中文网  https://microhq.cn/index-cn",
    "content": "go-micro 中文网  https://microhq.cn/index-cn"
  },
  
  {
    "title": "Micro hello world",
    "url": "/posts/Go-Micro1.1-hello-world/",
    "categories": "Language, Go",
    "tags": "GoWeb",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "go-Micro  参考资料1 环境搭建            work      version                  System      windows 8.1              golang      go version go1.13.4 windows/amd64              micro      micro version 1.18.0   ...",
    "content": "go-Micro  参考资料1 环境搭建            work      version                  System      windows 8.1              golang      go version go1.13.4 windows/amd64              micro      micro version 1.18.0              Consul      Consul v1.6.2              protoc      libprotoc 3.10.1      安装依赖      micro      #linux 下  export GO111MODULE=on  export GOPROXY=https://goproxy.io  # windows下设置如下环境变量  setx GO111MODULE on  setx GOPROXY https://goproxy.io  # 使用如下指令安装  go get -u -v github.com/micro/micro  go get -u -v github.com/micro/go-micro  $ micro --help;  NAME:     micro - A microservice runtime  USAGE:     micro.exe [global options] command [command options] [arguments...]  VERSION:     1.18.0            protocprotoc download        下载依赖    go get -u github.com/golang/protobuf/{proto,protoc-gen-go}    go get -u github.com/micro/protoc-gen-micro    $ protoc  // 查看是否安装成功！    Usage: D:\\file\\gopath\\bin\\bin\\protoc.exe [OPTION] PROTO_FILES    Parse PROTO_FILES and generate output based on the options given:      -IPATH, --proto_path=PATH   Specify the directory in which to search for            consulconsul download        $ consul --help;    Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]    Available commands are:      hello      micro new lichaocheng.top/microapp/hello     $ micro new lichaocheng.top/microapp/hello Creating service go.micro.srv.hello in D:\\file\\gopath\\src\\lichaocheng.top\\microapp\\hello . ├── main.go ├── generate.go ├── plugin.go ├── handler │   └── hello.go ├── subscriber │   └── hello.go ├── proto\\hello │   └── hello.proto ├── Dockerfile ├── Makefile ├── README.md └── go.mod download protobuf for micro: brew install protobuf go get -u github.com/golang/protobuf/{proto,protoc-gen-go} go get -u github.com/micro/protoc-gen-micro compile the proto file hello.proto: cd D:\\file\\gopath\\src\\lichaocheng.top\\microapp\\hello protoc --proto_path=.:$GOPATH/src --go_out=. --micro_out=. proto/hello/hello.proto            生成 protoc golang 和 micro golang 代码    $ pwd/d/file/gopath/src/lichaocheng.top/microapp/helloCc@ChaoChengLi MINGW64 /d/file/gopath/src/lichaocheng.top/microapp/hello$ protoc –proto_path=. –go_out=. –micro_out=. proto/hello/hello.proto        go run 运行    $ go run main.go2020-01-08 15:47:06.698568 I | Transport [http] Listening on [::]:78302020-01-08 15:47:06.698568 I | Broker [http] Connected to [::]:78312020-01-08 15:47:06.718288 I | Registry [mdns] Registering node: go.micro.srv.hello-114e6b46-c746-4ac4-a68c-ed1493afd1ea2020-01-08 15:47:06.825266 I | Subscribing go.micro.srv.hello-114e6b46-c746-4ac4-a68c-ed1493afd1ea to topic: go.micro.srv.hello2020-01-08 15:47:06.841276 I | Subscribing go.micro.srv.hello-114e6b46-c746-4ac4-a68c-ed1493afd1ea to topic: go.micro.srv.hello        micro api          注意其中的–namespace 参数,我们每一个微服务都属于一个命名空间,通过 api 暴露出来该命名空间后,满足 go.micro.srv.*格式的微服务都可以访问。如 go.micro.srv.hello 可以通过如下格式访问        $ micro api --namespace=go.micro.srv2020-01-08 16:02:18 [api] Registering API Default Handler at /2020-01-08 16:02:18 [api] HTTP API Listening on [::]:80802020-01-08 16:02:18 [api] Starting [service] go.micro.api2020-01-08 16:02:18 [api] Server [grpc] Listening on [::]:80262020-01-08 16:02:18 [api] Broker [http] Connected to [::]:80272020-01-08 16:02:18 [api] Registry [mdns] Registering node: go.micro.api-3ccde675-c78b-4b20-a0d8-9b2674e2f1b2            测试(测试未通过)          测试报错，待处理      "
  },
  
  {
    "title": "Micro API",
    "url": "/posts/Go-Micro-1.2-api/",
    "categories": "Language, Go",
    "tags": "GoWeb",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "micro APIGo API 是基于服务发现驱动开发的可插拔 API 框架，旨在帮助构建强大的 API 网关。指令  micro api 参数$ micro api -hNAME:   micro.exe api - Run the api gatewayUSAGE:   micro.exe api [command options] [arguments...]OPTIONS:   --...",
    "content": "micro APIGo API 是基于服务发现驱动开发的可插拔 API 框架，旨在帮助构建强大的 API 网关。指令  micro api 参数$ micro api -hNAME:   micro.exe api - Run the api gatewayUSAGE:   micro.exe api [command options] [arguments...]OPTIONS:   --address value    Set the api address e.g 0.0.0.0:8080 [%MICRO_API_ADDRESS%]   设置网关访问的ip和端口,如设置成0.0.0.0:8080,则可以通过http://127.0.0.1:8080/进行访问,默认为0.0.0.0:8080   --handler value    Specify the request handler to be used for mapping HTTP requests to services; {api, event, http, rpc} [%MICRO_API_HANDLER%]   指定映射具体哪种类型的处理程序,可选择{api, event, http, rpc} ,默认是rpc   --namespace value  Set the namespace used by the API e.g. com.example.api [%MICRO_API_NAMESPACE%]   指定暴露哪些微服务,通过命名空间匹配,如指定value为`go.micro.srv`，则该空间下所有微服务都能被访问   --resolver value   Set the hostname resolver used by the API {host, path, grpc} [%MICRO_API_RESOLVER%]   路径和微服务的对应关系,默认是micro,可选项为{host, path, grpc}   --enable_rpc       Enable call the backend directly via /rpc [%MICRO_API_ENABLE_RPC%]   是否支持直接通过rcp接口进行访问,默认false"
  },
  
  {
    "title": "kratos utils",
    "url": "/posts/kratos-kratos-utils/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "安装所有 kraots 工具集  通过 kratos 安装执行命令:kratos tool install all$ kratos tool install allgo get -u github.com/go-kratos/kratos/tool/kratos@v0.5.0...kratos: 安装成功!...protoc: 安装成功!...genbts: 安装成功!...genmc: 安...",
    "content": "安装所有 kraots 工具集  通过 kratos 安装执行命令:kratos tool install all$ kratos tool install allgo get -u github.com/go-kratos/kratos/tool/kratos@v0.5.0...kratos: 安装成功!...protoc: 安装成功!...genbts: 安装成功!...genmc: 安装成功!...genproject: 安装成功!...testgen: 安装成功!...testcli: 安装成功!...wire: 安装成功!...swagger: 安装成功!kraots 使用NAME:   kratos - kratos工具集USAGE:   kratos [global options] command [command options] [arguments...]VERSION:   v0.5.0COMMANDS:   new, n        创建新项目   build, b      kratos build   run, r        kratos run   tool, t       kratos tool   version, v    kratos version   self-upgrade  kratos self-upgrade   help, h       Shows a list of commands or help for one commandGLOBAL OPTIONS:   --help, -h     show help (default: false)   --version, -v  print the version (default: false)  kratos new          创建项目kratos new kratos_7        kratos build and run          kratos build 和 kratos run 是 go build 和 go run 的封装，可以在当前项目任意目录进行快速运行进行调试，并无特别用途。        kratos tool          kratos tool 是基于 proto 生成 http&amp;grpc 代码，生成缓存回源代码，生成 memcache 执行代码，生成 swagger 文档等工具集，先看下的执行效果：      $ kratos toolprotoc(已安装): 快速方便生成pb.go的protoc封装，windows、Linux请先安装protoc工具 Author(kratos) [2020/03/31]genbts(已安装): 缓存回源逻辑代码生成器 Author(kratos) [2020/03/31]genmc(已安装): mc缓存代码生成 Author(kratos) [2020/03/31]testgen(已安装): 测试代码生成 Author(kratos) [2020/03/31]testcli(已安装): 测试代码运行 Author(kratos) [2020/03/31]swagger(已安装): swagger api文档 Author(goswagger.io) [2020/03/31]安装工具: kratos tool install demo执行工具: kratos tool demo安装全部工具: kratos tool install all全部升级: kratos tool upgrade all详细文档： https://github.com/go-kratos/kratos/blob/master/doc/wiki-cn/kratos-tool.md  kratos version$ kratos version Version:      v0.5.0 Go version:   go1.14.2 Built:        2020/4/30 OS/Arch:      darwin/amd64  kratos self-upgrade          升级 kraots 工具      protoc 使用  安装：go get -u github.com/golang/protobuf/{proto,protoc-gen-go}  使用kratos tool protoc api.proto# 结果一~/gomod/demo/kratos_7 ⌚ 11:18:52$ cd api~/gomod/demo/kratos_7/api ⌚ 11:38:06$ kratos tool protoc api.proto2020/07/06 11:38:08 protoc --proto_path=/Users/hys/go/src...2020/07/06 11:38:11 generate api.proto success.# 结果二$ kratos tool protoc api.proto2020/07/06 11:39:06 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos_7/api --bm_out=:. api.proto2020/07/06 11:39:06 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos_7/api --gofast_out=plugins=grpc:. api.proto2020/07/06 11:39:06 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos_7/api --bswagger_out=:. api.proto2020/07/06 11:39:06 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos_7/api --ecode_out=:. api.proto2020/07/06 11:39:06 generate api.proto success.swagger  api 文档  kratos tool protoc api.proto  kratos tool swagger serve -p 5566 api.swagger.jsongrpc ui  生成文档          –proto_path=? 的路径需要写 kratos 下的 third_party      protoc --proto_path=. --proto_path=.. --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --descriptor_set_out=api.protoset --include_imports api.proto  启动$ grpcui -bind 0.0.0.0 -port 8506 -plaintext -protoset api.protoset 127.0.0.1:9888gRPC Web UI available at http://0.0.0.0:8506/  测试 logINFO 07/06-11:51:10.319 grpc-access-log user=no_user ip=127.0.0.1:64781 path=/demo.service.v1.Demo/Ping ts=0.000155499 ret=0 traceid= timeout_quota=0.999989715 argsecode  生成命令kratos tool protoc --ecode ecode.proto  服务注册 ecodemain.gofunc main(){    flag.Parse()\tlog.Init(&amp;log.Config{Stdout: true}) // 初始化kratos打印输出为true\tdefer log.Close()\tlog.Info(\"im_session start\")\tecode.Register(ec.CMS) // 注册ecode\tpaladin.Init()\t.....}-在返回 return 时  时间 proto 接口的内返回ecode.Error(ecode.New(400), \"test error\")"
  },
  
  {
    "title": "kratos 依赖注入",
    "url": "/posts/kratos-kratos-other/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "依赖注入Kratos 是一款基于 Go 语言的微服务开发框架，它内置了依赖注入功能。在 Kratos 中，我们可以使用构造函数注入或者字段注入的方式来实现依赖注入。构造函数注入是指将依赖通过构造函数参数的方式传递给要注入的对象。例如：type FooService struct {    barService *BarService}func NewFooService(barService...",
    "content": "依赖注入Kratos 是一款基于 Go 语言的微服务开发框架，它内置了依赖注入功能。在 Kratos 中，我们可以使用构造函数注入或者字段注入的方式来实现依赖注入。构造函数注入是指将依赖通过构造函数参数的方式传递给要注入的对象。例如：type FooService struct {    barService *BarService}func NewFooService(barService *BarService) *FooService {    return &amp;FooService{        barService: barService,    }}在上面的示例中，FooService 依赖于 BarService，并且通过 NewFooService 方法将 BarService 作为参数传递进去。字段注入则是将依赖通过结构体字段的方式注入。例如：type FooService struct {    barService *BarService `inject:\"\"`}func (f *FooService) Init() error {    // 对 f.barService 进行初始化操作}// 在 main 函数中使用依赖注入初始化 FooServicefunc main() {    var fooService FooService    container := dig.New()    container.Provide(NewBarService)    err := container.Invoke(func(f *FooService) error {        return f.Init()    })    if err != nil {        panic(err)    }}  在上面的示例中，我们使用 dig 包来实现依赖注入。通过在结构体字段中添加 inject:\"\" 标签，我们告诉 dig包需要注入这个字段的依赖。然后在 main 函数中，我们使用 dig 包提供的 Provide 方法来注册 BarService，然后使用 Invoke 方法初始化 FooService，最后调用 Init 方法对 FooService 进行初始化操作。总之，在 Kratos 中，我们可以方便地实现依赖注入，从而更加轻松地构建高质量的微服务应用程序。"
  },
  
  {
    "title": "kratos interface",
    "url": "/posts/kratos-kratos-interface/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "kratos 微服务常见的 url  查看所有 discovery 表：http://172.12.15.81:7171/discovery/fetch/all  查看服务的所有 http 对外接口：http://127.0.0.1:36001/metadata",
    "content": "kratos 微服务常见的 url  查看所有 discovery 表：http://172.12.15.81:7171/discovery/fetch/all  查看服务的所有 http 对外接口：http://127.0.0.1:36001/metadata"
  },
  
  {
    "title": "kratos base",
    "url": "/posts/kratos-kratos-base/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "kratos 环境搭建  安装 kratosgo get -u github.com/go-kratos/kratos/tool/kratos使用 kratos 脚手架创建项目$ kratos new kratos_7go get -u github.com/go-kratos/kratos/tool/kratos-gen-project@v0.5.0go: found github.com...",
    "content": "kratos 环境搭建  安装 kratosgo get -u github.com/go-kratos/kratos/tool/kratos使用 kratos 脚手架创建项目$ kratos new kratos_7go get -u github.com/go-kratos/kratos/tool/kratos-gen-project@v0.5.0go: found github.com/go-kratos/kratos/tool/kratos-gen-project in github.com/go-kratos/kratos v0.5.0go: github.com/gobuffalo/logger upgrade =&gt; v1.0.3go: github.com/rogpeppe/go-internal upgrade =&gt; v1.6.0go: golang.org/x/sys upgrade =&gt; v0.0.0-20200625212154-ddb9806d33aego: github.com/gobuffalo/envy upgrade =&gt; v1.9.0go: github.com/urfave/cli/v2 upgrade =&gt; v2.2.0go: github.com/gobuffalo/packr/v2 upgrade =&gt; v2.8.0go: github.com/gobuffalo/packd upgrade =&gt; v1.0.0go: golang.org/x/crypto upgrade =&gt; v0.0.0-20200622213623-75b288015ac9go: github.com/sirupsen/logrus upgrade =&gt; v1.6.0go: github.com/cpuguy83/go-md2man/v2 upgrade =&gt; v2.0.0go: github.com/konsorten/go-windows-terminal-sequences upgrade =&gt; v1.0.3go: downloading github.com/gobuffalo/packr/v2 v2.8.0go: downloading github.com/gobuffalo/packd v1.0.0go: downloading github.com/gobuffalo/logger v1.0.3go: downloading github.com/karrick/godirwalk v1.15.3go: downloading github.com/markbates/safe v1.0.1go: downloading github.com/markbates/oncer v1.0.0go: downloading github.com/markbates/errx v1.1.0go: downloading golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9go: github.com/karrick/godirwalk upgrade =&gt; v1.15.6go: downloading github.com/karrick/godirwalk v1.15.6genproject: 安装成功!go: finding module for package github.com/google/wire# get https://goproxy.io/github.com/@v/list# get https://goproxy.io/github.com/google/wire/@v/list# get https://goproxy.io/github.com/google/@v/list# get https://goproxy.io/github.com/google/wire/@v/list: 200 OK (0.192s)# get https://goproxy.io/github.com/@v/list: 404 Not Found (0.199s)# get https://goproxy.io/github.com/google/@v/list: 404 Not Found (0.192s)# get https://goproxy.io/sumdb/sum.golang.org/supported# get https://goproxy.io/sumdb/sum.golang.org/supported: 200 OK (0.013s)# get https://goproxy.io/sumdb/sum.golang.org/lookup/github.com/google/wire@v0.4.0# get https://goproxy.io/sumdb/sum.golang.org/lookup/github.com/google/wire@v0.4.0: 200 OK (0.016s)# get https://goproxy.io/sumdb/sum.golang.org/tile/8/0/x002/080# get https://goproxy.io/sumdb/sum.golang.org/tile/8/0/x002/080: 200 OK (0.017s)go: found github.com/google/wire in github.com/google/wire v0.4.0# get https://goproxy.io/sumdb/sum.golang.org/lookup/golang.org/x/tools@v0.0.0-20190422233926-fe54fb35175b# get https://goproxy.io/sumdb/sum.golang.org/lookup/github.com/google/subcommands@v1.0.1# get https://goproxy.io/sumdb/sum.golang.org/lookup/golang.org/x/tools@v0.0.0-20190422233926-fe54fb35175b: 200 OK (0.017s)# get https://goproxy.io/sumdb/sum.golang.org/lookup/github.com/google/subcommands@v1.0.1: 200 OK (0.016s)kratos tool protoc --grpc --bm api.protogo get -u github.com/go-kratos/kratos/tool/kratos-protoc@v0.5.0go: found github.com/go-kratos/kratos/tool/kratos-protoc in github.com/go-kratos/kratos v0.5.0go: github.com/urfave/cli/v2 upgrade =&gt; v2.2.0go: github.com/cpuguy83/go-md2man/v2 upgrade =&gt; v2.0.0protoc: 安装成功!2020/07/06 10:46:58 go get -u github.com/go-kratos/kratos/tool/protobuf/protoc-gen-bmgo: github.com/pkg/errors upgrade =&gt; v0.9.1go: github.com/golang/protobuf upgrade =&gt; v1.4.2go: google.golang.org/genproto upgrade =&gt; v0.0.0-20200702021140-07506425bd67go: downloading google.golang.org/genproto v0.0.0-20200702021140-07506425bd67go: google.golang.org/protobuf upgrade =&gt; v1.25.02020/07/06 10:47:03 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos/kratos_7/api --bm_out=:. api.proto2020/07/06 10:47:03 go get -u github.com/gogo/protobuf/protoc-gen-gofastgo: found github.com/gogo/protobuf/protoc-gen-gofast in github.com/gogo/protobuf v1.3.12020/07/06 10:47:06 protoc --proto_path=/Users/hys/go/src --proto_path=/Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/third_party --proto_path=/Users/hys/gomod/demo/kratos/kratos_7/api --gofast_out=plugins=grpc:. api.proto2020/07/06 10:47:06 generate api.proto success.kratos tool genbtsgo get -u github.com/go-kratos/kratos/tool/kratos-gen-bts@v0.5.0go: found github.com/go-kratos/kratos/tool/kratos-gen-bts in github.com/go-kratos/kratos v0.5.0genbts: 安装成功!Close: 无声明 忽略此方法Ping: 无声明 忽略此方法dao.bts.go: 生成成功kratos tool genmcgo get -u github.com/go-kratos/kratos/tool/kratos-gen-mc@v0.5.0go: found github.com/go-kratos/kratos/tool/kratos-gen-mc in github.com/go-kratos/kratos v0.5.0genmc: 安装成功!mc.cache.go: 生成成功kratos tool wirewire: github.com/go-kratos/kratos/kratos_7/internal/di: wrote /Users/hys/gomod/demo/kratos/kratos_7/internal/di/wire_gen.gokratos tool wirewire: github.com/go-kratos/kratos/kratos_7/internal/dao: wrote /Users/hys/gomod/demo/kratos/kratos_7/internal/dao/wire_gen.goProject: kratos_7OnlyGRPC: falseOnlyHTTP: falseDirectory: /Users/hys/gomod/demo/kratos/kratos_7项目创建成功.启动项目  第一次启动先要运行 go mod tidy  方法一~/gomod/demo/kratos_7 ⌚ 10:54:22$ pwd/Users/hys/gomod/demo/kratos_7~/gomod/demo/kratos_7 ⌚ 10:54:25$ go run ./cmd -conf ./configsINFO 07/06-10:54:28.621 /Users/hys/gomod/demo/kratos_7/cmd/main.go:19 kratos_7 start2020/07/06 10:54:28 start watch filepath: ./configsINFO 07/06-10:54:28.622 /Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/pkg/net/http/blademaster/server.go:97 blademaster: start http listen addr: [::]:8888[warden] config is Deprecated, argument will be ignored. please use -grpc flag or GRPC env to configure warden server.INFO 07/06-10:54:28.622 /Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/pkg/net/rpc/warden/server.go:329 warden: start grpc listen addr: [::]:9888  方法二~/gomod/demo/kratos_7 ⌚ 10:55:28$ pwd/Users/hys/gomod/demo/kratos_7~/gomod/demo/kratos_7 ⌚ 10:55:31$ kratos runINFO 07/06-10:55:37.128 /Users/hys/gomod/demo/kratos_7/cmd/main.go:19 kratos_7 start2020/07/06 10:55:37 start watch filepath: /Users/hys/gomod/demo/kratos_7/configsINFO 07/06-10:55:37.130 /Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/pkg/net/http/blademaster/server.go:97 blademaster: start http listen addr: [::]:8888[warden] config is Deprecated, argument will be ignored. please use -grpc flag or GRPC env to configure warden server.INFO 07/06-10:55:37.130 /Users/hys/go/pkg/mod/github.com/go-kratos/kratos@v0.5.1-0.20200526160825-521d240568d0/pkg/net/rpc/warden/server.go:329 warden: start grpc listen addr: [::]:9888测试访问  方法一          在浏览器输入 http://127.0.0.1:8888/kratos_7/start        方法二~/gomod/demo/kratos_7 ⌚ 10:58:58$ curl http://127.0.0.1:8888/kratos_7/start{\"code\":0,\"message\":\"0\",\"ttl\":1,\"data\":{\"Hello\":\"Golang 大法好 !!!\"}}%如果看见 Golang 大法好 则 创建 OK"
  },
  
  {
    "title": "kratos discovery",
    "url": "/posts/kratos-discovery/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "常见的微服务注册中心  consul  etcd  zookeeper  Eureka  kratos(discovery)discovery安装源码安装  github  下载生成可执行文件git clone https://github.com/bilibili/discovery.gitcd discovery/cmd/discoverygo build  启动./discovery ...",
    "content": "常见的微服务注册中心  consul  etcd  zookeeper  Eureka  kratos(discovery)discovery安装源码安装  github  下载生成可执行文件git clone https://github.com/bilibili/discovery.gitcd discovery/cmd/discoverygo build  启动./discovery -conf discovery-example.toml -alsologtostderr生成 docker imagesdocker build -t cc360428/discovery:latest .docker 安装docker run -itd --name disvoery -p 7171:7171 lichaocheng/discovery注册  使用 kraots 之前 set DISCOVERY_NODES=127.0.0.1:7171package mainimport (\t\"context\"\t\"flag\"\t\"github.com/go-kratos/kratos/pkg/conf/env\"\t\"github.com/go-kratos/kratos/pkg/conf/paladin\"\t\"github.com/go-kratos/kratos/pkg/naming\"\t\"github.com/go-kratos/kratos/pkg/naming/discovery\"\t\"github.com/go-kratos/kratos/pkg/net/rpc/warden/resolver\"\t\"im_square/internal/dao\"\t\"im_square/internal/di\"\t\"os\"\t\"os/signal\"\t\"syscall\"\t\"time\"\t\"github.com/go-kratos/kratos/pkg/log\")func main() {\tflag.Parse()\tlog.Init(&amp;log.Config{Stdout: true}) // debug flag: log.dir={path}\tdefer log.Close()\tlog.Info(\"im_square start\")\t_ = paladin.Init()\tresolver.Register(discovery.Builder())\t_, closeFunc, err := di.InitApp()\tif err != nil {\t\tpanic(err)\t}\t//consul 注册发现\tvar RegCancel context.CancelFunc\tif _gRPCAddr != \"\" {\t\thn, _ := os.Hostname()\t\tdis := discovery.New(nil)\t\tins := &amp;naming.Instance{\t\t\tZone:     env.Zone,\t\t\tEnv:      env.DeployEnv,\t\t\tAppID:    env.AppID,\t\t\tHostname: hn,\t\t\tAddrs: []string{\t\t\t\t\"grpc://\" + _gRPCAddr,\t\t\t},\t\t}\t\tif cancel, err := dis.Register(context.Background(), ins); err != nil {\t\t\tpanic(err)\t\t} else {\t\t\tRegCancel = cancel\t\t}\t}\tc := make(chan os.Signal, 1)\tsignal.Notify(c, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT)\tfor {\t\ts := &lt;-c\t\tlog.Info(\"get a signal %s\", s.String())\t\tswitch s {\t\tcase syscall.SIGQUIT, syscall.SIGTERM, syscall.SIGINT:\t\t\tcloseFunc()\t\t\tRegCancel()\t\t\tlog.Info(\"main exit\")\t\t\ttime.Sleep(time.Second)\t\t\treturn\t\tcase syscall.SIGHUP:\t\tdefault:\t\t\treturn\t\t}\t}}var _gRPCAddr stringfunc init() {\taddFlag(flag.CommandLine)\tdao.SynchronizationRedisAll()}func addFlag(fs *flag.FlagSet) {\tv := os.Getenv(\"DISCOVERY_GRPC_ADDR\")\tfs.StringVar(&amp;_gRPCAddr, \"grpc.addr\", v, \"app listen grpc port, default: nil\")}发现  发现方式两种：1、直接连接输入 服务端 IP 地址；2、通过 discovery 注册中心（或其他的注册中心）  获取要发现的服务的 proto 文件生成对应的 pd 文件  设置 discovery 节点地址  client 代码  通过 discovery 注册中心连接const AppID = \"square_recom_ai_v1\"//  new grpc clientfunc NewAiRecomClient(cfg *warden.ClientConfig, opts ...grpc.DialOption) (SquareRecomAiClient, error) {\tclient := warden.NewClient(cfg, opts...)\tcc, err := client.Dial(context.Background(), fmt.Sprintf(\"discovery://default/%s\", AppID))\tif err != nil {\t\tlog.Error(\"square_recom_ai_error\", err.Error())\t\treturn nil, err\t\t//return nil, nil\t}\tlog.Info(\"square_recom_ai like ok\")\treturn NewSquareRecomAiClient(cc), nil}  已知服务 IP 地址// NewImSquareClient new grpc clientfunc NewAiRecomClient(cfg *warden.ClientConfig, opts ...grpc.DialOption) (SquareRecomAiClient, error) {\tclient := warden.NewClient(cfg, opts...)\tcc, err := client.Dial(context.Background(), fmt.Sprintf(\"direct://default/127.0.0.1:9003\"))\tif err != nil {\t\tlog.Error(\"square_recom_ai_error\", err.Error())\t\treturn nil, err\t\t//return nil, nil\t}\tlog.Info(\"square_recom_ai like ok\")\treturn NewSquareRecomAiClient(cc), nil}"
  },
  
  {
    "title": "kratos Error",
    "url": "/posts/kratos-Error/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb, kratos",
    "date": "2020-06-26 14:22:12 +0800",
    





    
    "snippet": "ERRORversion 0.3.3  错误演示go: finding module for package github.com/bilibili/kratos/pkg/timego: found github.com/bilibili/kratos/pkg/log in github.com/bilibili/kratos v0.5.0go: found github.com/Burnt...",
    "content": "ERRORversion 0.3.3  错误演示go: finding module for package github.com/bilibili/kratos/pkg/timego: found github.com/bilibili/kratos/pkg/log in github.com/bilibili/kratos v0.5.0go: found github.com/BurntSushi/toml in github.com/BurntSushi/toml v0.3.1go: found google.golang.org/grpc/resolver in google.golang.org/grpc v1.31.0go: found golang.org/x/sync/errgroup in golang.org/x/sync v0.0.0-20200625203802-6e8e738ad208go: found github.com/smartystreets/goconvey/convey in github.com/smartystreets/goconvey v1.6.4go: found gopkg.in/h2non/gock.v1 in gopkg.in/h2non/gock.v1 v1.0.15go: github.com/bilibili/discovery/cmd/discovery imports\tgithub.com/bilibili/kratos/pkg/log: github.com/bilibili/kratos@v0.5.0: parsing go.mod:\tmodule declares its path as: github.com/go-kratos/kratos\t        but was required as: github.com/bilibili/kratos  原因          kratos 历史遗留原因 从 bilibili 一直 go-kratos 仓库        解决方法-go.mod 文件中制定版本github.com/bilibili/kratos v0.3.3运行不报错，也不成功  原因          discovery 配置不成功      discovery 使用字段（env、node…）        解决方法          检查 discovery 注册时候      访问其他节点超时  原因          从本地机器代理、开发工具代理设置      discovery 的地址 与其他节点不再同一个 discovery      访问节点没有启动      AppId 错误      访问节点 grpc 地址错误        解决方法          查看访问节点是否在 discovery 中      本地机器 ping 访问节点 grpc 地址      检查开发工具代理设置      查看访问 AppId 是否和 discovery 一致      运行成功没有打印监听端口  错误演示    log.Init(nil) // debug flag: log.dir={path}    defer log.Close()    log.Info(\"user-location start\")  原因          历史遗留问题      kratos 初始化 log 问题        解决方法          初始化 log 时只需要给log.Init()不为 nil        log.Init(&amp;log.Config{Stdout: true}) // debug flag: log.dir={path}defer log.Close()log.Info(\"user-location start\")                    启动环境变量错误LOG_V=1;LOG_STDOUT=true;APP_ID=userlocation;DISCOVERY_NODES=172.12.14.82:7171;ZONE=sz001;DEPLOY_ENV=dev;0.7.0 *types.Empty  types.Empty 导致依赖注入生成文件失败  解决方法          把原有的引入包改成以下即可          types \"github.com/gogo/protobuf/types\"Goland Protocl搜索：Protocol Buffers 、加上自己的项目目录即可  参考链接proto 设置引导路径file:///opt/gopath/pkg/mod/github.com/gogo/googleapis@v1.4.0file:///opt/gopath/pkg/mod/github.com/gogo/protobuf@v1.3.1protoc 版本# git.huoys.com/middle-end/kratos/pkg/net/rpc/warden/balancer/p2c/opt/gopath/pkg/mod/git.huoys.com/middle-end/kratos@v0.7.0/pkg/net/rpc/warden/balancer/p2c/p2c.go:34:5: cannot use &amp;p2cPickerBuilder literal (type *p2cPickerBuilder) as type base.PickerBuilder in assignment:  *p2cPickerBuilder does not implement base.PickerBuilder (wrong type for Build method)    have Build(map[resolver.Address]balancer.SubConn) balancer.Picker    want Build(base.PickerBuildInfo) balancer.Picker/opt/gopath/pkg/mod/git.huoys.com/middle-end/kratos@v0.7.0/pkg/net/rpc/warden/balancer/p2c/p2c.go:35:5: cannot use &amp;p2cPicker literal (type *p2cPicker) as type balancer.Picker in assignment:  *p2cPicker does not implement balancer.Picker (wrong type for Pick method)    have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error)    want Pick(balancer.PickInfo) (balancer.PickResult, error)/opt/gopath/pkg/mod/git.huoys.com/middle-end/kratos@v0.7.0/pkg/net/rpc/warden/balancer/p2c/p2c.go:42:32: not enough arguments in call to base.NewBalancerBuilder  have (string, *p2cPickerBuilder)  want (string, base.PickerBuilder, base.Config)/opt/gopath/pkg/mod/git.huoys.com/middle-end/kratos@v0.7.0/pkg/net/rpc/warden/balancer/p2c/p2c.go:144:2: cannot use p (type *p2cPicker) as type balancer.Picker in return argument:  *p2cPicker does not implement balancer.Picker (wrong type for Pick method)    have Pick(context.Context, balancer.PickInfo) (balancer.SubConn, func(balancer.DoneInfo), error)    want Pick(balancer.PickInfo) (balancer.PickResult, error)  解决方法          设置引入包版本，kratos 0.7.0 版本内部版本      go 1.14require (\tgit.huoys.com/middle-end/kratos v0.7.0\tgithub.com/BurntSushi/toml v0.3.1\tgithub.com/gogo/googleapis v1.4.0\tgithub.com/gogo/protobuf v1.3.1\tgithub.com/google/wire v0.4.0\tgoogle.golang.org/grpc v1.29.1)"
  },
  
  {
    "title": "English 语态",
    "url": "/posts/7-voice/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:13:01 +0800",
    





    
    "snippet": "语态语态分类      主动语态（Active Voice）：在主动语态中，句子的主语是动作的执行者。这种语态通常用于强调动作的主体或者要点。因此，在大多数情况下，主动语态的句子更直接、更简洁、更具有说服力。例如，“Thedog chased the cat”（狗追逐着猫），其中主语“the dog”执行了动作“chased”。        被动语态（Passive Voice）：被动语态...",
    "content": "语态语态分类      主动语态（Active Voice）：在主动语态中，句子的主语是动作的执行者。这种语态通常用于强调动作的主体或者要点。因此，在大多数情况下，主动语态的句子更直接、更简洁、更具有说服力。例如，“Thedog chased the cat”（狗追逐着猫），其中主语“the dog”执行了动作“chased”。        被动语态（Passive Voice）：被动语态指的是句子的主语是动作的承受者。在被动语态中，动词由“be”+过去分词构成，表示被动或者无意识的状态。被动语态通常用于重点突出动作的结果或者强调动作的承受者。例如，“Thecat was chased by the dog”（猫被狗追逐着），其中“the cat”是主语，而“was chased”是动词短语。        进行时语态（Progressive/Continuous Voice）：进行时语态指的是动作正在进行的状态。在进行时语态中，动词由“be”+现在分词构成。这种语态通常用于描述当前正在发生的动作，或者表示动作的持续过程。例如，“Sheis writing a letter”（她正在写一封信），其中主语“she”正在进行动作“write”。  例子Active Voice: The chef prepared the meal for the guests. (主动语态)In this sentence, the subject (chef) is performing the action of preparing the meal.Passive Voice: The meal was prepared by the chef for the guests. (被动语态)Here, the focus is on the receiver of the action (the meal), rather than the person who performed the action.Progressive Voice: The chef was preparing the meal when the guests arrived. (进行语态)This sentence describes an ongoing action that was happening at a specific time in the past – the moment the guestsarrived.By using different voices and tenses, we can convey different meanings and emphasize different aspects of a sentence.Understanding and mastering the use of various voices and tenses is essential for effective communication in English.翻译：主动语态：厨师为客人准备了餐点。在这个句子中，主语（厨师）正在执行准备餐点的行动。被动语态：餐点是由厨师为客人准备的。这里，焦点在于行动的接受者（餐点），而不是执行行动的人。进行语态：当客人到达时，厨师正在准备餐点。这个句子描述一个正在进行的动作，发生在过去的特定时间——客人到达的那一刻。通过使用不同的语态和时态，我们可以传达不同的意义，强调句子的不同方面。理解和掌握各种语态和时态对于有效的英语交流至关重要。"
  },
  
  {
    "title": "English 时态",
    "url": "/posts/6-tense/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:59 +0800",
    





    
    "snippet": "时态      一般现在时（Present Simple）          用于表示当前正在进行或经常性发生的动作或状态通常使用动词的原形（即第一人称单数形式）构成例如：              I write an email to my boss every day.（我每天给我的老板写邮件）      She always drinks coffee in the morning....",
    "content": "时态      一般现在时（Present Simple）          用于表示当前正在进行或经常性发生的动作或状态通常使用动词的原形（即第一人称单数形式）构成例如：              I write an email to my boss every day.（我每天给我的老板写邮件）      She always drinks coffee in the morning.（她每天早上喝咖啡）      The sun rises in the east and sets in the west.（太阳从东方升起，从西方落下）            一般过去时（Past Simple）          用于表示已经完成的过去发生的动作或状态通常使用动词的过去式（即第二人称单数形式）构成例如：              We went to the beach last weekend.（我们上周末去了海滩）      He studied English for three hours yesterday.（他昨天学习英语三个小时）      They played soccer every afternoon when they were kids.（他们小时候每天下午都踢足球）            将来时（Future Simple）          用于表示将要发生的动作或状态通常使用助动词“will”加上动词的原形构成例如：              He will meet his friend at the airport tomorrow.（他明天会在机场见他的朋友）      I will cook dinner for my family tonight.（今晚我会为我的家人做饭）      They will take a vacation next month.（他们下个月会去度假）            现在进行时（Present Continuous）          用于表示当前正在进行的动作或状态通常使用助动词“be”加上动词的现在分词构成例如：              She is reading a book right now.（她现在正在看书）      They are having a meeting in the conference room.（他们正在会议室开会）      I am learning to play guitar.（我正在学习弹吉他）            过去进行时（Past Continuous）          用于表示过去某个时间正在发生的动作通常使用助动词“was/were”加上动词的现在分词构成例如：              He was watching TV when she arrived.（她到达时他正在看电视）      I was walking in the park when it started raining.（下雨时我正在公园里散步）      They were studying for their exams all night.（他们整晚都在备考）            将来进行时（Future Continuous）          用于表示将来某个时间正在进行的动作通常使用助动词“will be”加上动词的现在分词构成例如：              I will be traveling to Europe this summer.（今年夏天我会去欧洲旅行）      They will be working on the project all day tomorrow.（明天一整天他们都会在工作这个项目）      We will be waiting for you at the airport.（我们会在机场等你）            完成时（Present Perfect）          用于表示过去某个时间到现在仍然持续的动作或状态通常使用助动词“have/has”加上动词的过去分词构成例如：              They have lived in this city for ten years.（他们已经在这个城市居住了十年）      She has watched that movie three times.（她已经看了那部电影三遍）      I have studied English since I was a child.（我从小学习英语至今）            过去完成进行时（Past Perfect Continuous）          用于表示过去某个时间之前一直在进行的动作通常使用助动词“had been”加上动词的现在分词构成例如：              He had been working on the project for two weeks before herealized he had made a mistake.（他在意识到自己犯了一个错误之前已经连续工作了两周）      We had been waiting for the bus for an hour when it finally arrived.（公交车终于到站时，我们已经等了一个小时了）      They had been studying English every day for a year before they took the TOEFL exam.（在参加托福考试之前，他们已经连续一年每天都在学习英语）      "
  },
  
  {
    "title": "English 句型和句子结构",
    "url": "/posts/5-sentence_structure/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:58 +0800",
    





    
    "snippet": "句子结构句子结构组成部分  主语：在句子中执行动作或被描述的人或物。例子：”She is reading a book.”，其中主语是”She”。  谓语：描述主语动作或状态的部分。例子：”He is running in the park.”，其中谓语是”is running”。  宾语：接受动作的人或物。例子：”I bought a new car.”，其中宾语是”a new car”。...",
    "content": "句子结构句子结构组成部分  主语：在句子中执行动作或被描述的人或物。例子：”She is reading a book.”，其中主语是”She”。  谓语：描述主语动作或状态的部分。例子：”He is running in the park.”，其中谓语是”is running”。  宾语：接受动作的人或物。例子：”I bought a new car.”，其中宾语是”a new car”。  定语：修饰或描述名词或代词。例子：”The tall man is my father.”，其中定语是”tall”。  状语：描述动作的环境、方式、时间等信息的成分。例子：”She sings beautifully in the shower.”，其中状语有两个，分别是”beautifully”和”in the shower”。  补语：对主语或宾语进行补充的成分。例子：”He felt happy after winning the game.”，其中补语是”happy”。      理解          主语、谓语、宾语是英语句子中最基本的成分，通常用来描述一个事件或行动。主语表示执行动作或被描述的人或物，谓语描述主语的动作或状态，宾语表示动作的承受者或对象。      定语、状语、补语则是在句子中修饰其他成分、进一步说明事件或行动所处情境的语法结构。定语用来修饰或描述名词或代词，状语描述动作的环境、方式、时间等信息，补语对主语或宾语进行补充说明，表达其状态或感受。      可以简单地把主语、谓语、宾语看做是构成一个句子的“核心部分”，而定语、状语、补语则是对这个核心部分进行更详细的描述和补充，帮助读者更好地理解句子含义。            例子                  John, a talented musician, played his guitar passionately on stage last night. The audience applauded him loudly andhe felt proud of himself.                    解释                  主语：John          谓语：played          宾语：his guitar          定语：a talented musician          状语：passionately, on stage, last night          补语：proud of himself                            这个句子中，主语是“John”，他是一个才华横溢的音乐家；谓语是“played”，表达了他在舞台上弹吉他这一动作；宾语是“hisguitar”，也就是他所弹奏的对象；定语是”a talented musician”，用来描述主语；状语有三个，分别表示方式、地点和时间；补语是”proud of himself”，用来描述主语的情感状态。                    翻译：昨晚，才华横溢的音乐家约翰在舞台上热情地弹奏着他的吉他。观众们为他热烈鼓掌，他为自己感到自豪。            句子结构分类      简单句：由一个主语和一个谓语组成，例如：“She sings.”        并列句：由两个或多个简单句通过连接词连接而成，例如：“I like tea, but she prefers coffee.”        复合句：由一个主句和一个或多个从句构成，例如：“He said that he was tired.”        独立主格结构：由一个名词性词语和一个动词形式构成的结构，可以独立作为句子，例如：“The sun having set, we returned home.”        倒装句：将谓语动词置于主语之前的句子，常用于强调语气，例如：“Never have I seen such a beautiful view!”        定语从句：一种特殊的从句，用于修饰一个名词或代词，例如：“The man who is standing there is my friend.”        状语从句：一种特殊的从句，用于描述某个动作或状态的情况，例如：“While I was studying, my roommate was watching TV.”  例子  包含不同句子结构的作文：I woke up early this morning and decided to go for a hike. The sun was shining brightly, and a cool breeze blew throughthe trees. I was feeling happy and free as I walked along the path.Suddenly, I heard a rustling in the bushes. Startled, I stopped and looked around. To my surprise, I saw a small rabbithopping out of the bushes. It looked at me with big, curious eyes, then dashed away into the underbrush.Feeling energized, I continued on my hike. As I climbed higher, I felt the wind become stronger and colder. Despite thechill, I pushed onward, driven by my curiosity and desire for adventure.At last, I reached the summit of the mountain. Overwhelmed with joy and amazement, I looked out at the stunning viewbefore me. The world seemed endless and full of possibility, and I couldn’t help but feel grateful for the experience.      解释                  I woke up early this morning and decided to go for a hike. （简单句）：一个主语和一个谓语组成的句子                    The sun was shining brightly, and a cool breeze blew through the trees.（并列句）：由两个简单句通过连接词 and 连接而成                    Feeling energized, I continued on my hike.（独立主格结构）：以现在分词或过去分词形式作为修饰成分，来描述主句中的情况                    Suddenly, I heard a rustling in the bushes.（倒装句）：将谓语动词提前，以表达强烈的语气                    To my surprise, I saw a small rabbit hopping out of the bushes.（复合句）：由一个主句和一个不完整的 from 句构成，其中的from 句缺少谓语部分                    It looked at me with big, curious eyes, then dashed away into the underbrush.（并列句）：由两个简单句通过连接词 then连接而成                    Overwhelmed with joy and amazement, I looked out at the stunning view beforeme.（独立主格结构）：以现在分词或过去分词形式作为修饰成分，来描述主句中的情况                    The world seemed endless and full of possibility, and I couldn’t help but feel grateful for theexperience.（复合句）：由两个简单句通过连接词 and 连接而成，并包含了一个定语从句，用于修饰 world                  翻译  我早上起得很早，决定去远足。阳光明媚，微凉的风吹过树林。当我走在小路上时，感觉很快乐，自由自在。突然间，我听到了灌木丛里传来的一声沙沙声。我吃了一惊，停下来四处张望。令我惊奇的是，我看到一个小兔子从灌木丛中蹦了出来。它用好奇的大眼睛看着我，然后跑进了草丛。感觉身体充满了能量，我继续我的远足。当我向上爬时，感到风越来越强，也更加寒冷。尽管感觉有些冷，但我还是继续向前走，被好奇和对冒险的渴望驱动着。最终，我到达了山顶。我被眼前的美景所震撼，感到无比的欢喜和惊奇。这个世界似乎无限广阔，充满着可能性，我禁不住为这次经历而感激不尽。句型      陈述句          She loves playing the piano.（她喜欢弹钢琴）这是一个简单的陈述句，表达了主语“她”喜欢做的事情      The sky is blue.（天空是蓝色的）这也是一个简单的陈述句，表达了天空的颜色            疑问句          What time is it?（现在几点了？）这是一个一般疑问句，用于询问时间      Did you have a good weekend?（你周末过得愉快吗？）这也是一个一般疑问句，用于询问对方周末的情况            否定句          They don’t have any children.（他们没有孩子）这是一个否定句，表示主语没有某个物品或属性      I am not going to the party tonight.（今晚我不去参加聚会）这也是一个否定句，表示说话者不会出席聚会            条件句          If I have enough money, I will buy a new car.（如果我有足够的钱，我会买一辆新车）这是一个条件句，表示在满足某个条件的情况下，会发生某个结果      Unless you work harder, you won’t pass the exam.（除非你更加努力，否则你无法通过考试）这也是一个条件句，表示除非满足某个条件，否则不会发生某个结果            比较句          This restaurant is better than the one we went to last week.（这家餐厅比我们上周去的那家更好）这是一个比较句，用于比较两个或多个事物的相似之处或差异之处      My hometown is smaller than New York City.（我的家乡比纽约市小）这也是一个比较句，用于比较两个地点的大小或其他特征            祈使句          Don’t forget to call me later.（别忘了晚些时候给我打电话）这是一个祈使句，用于表达命令、请求等      Open the window, please.（请打开窗户）这也是一个祈使句，要求对方按照指示做某事            感叹句          How beautiful the flowers are!（多美的花儿啊！）这是一个感叹句，用于表达强烈的情感，如惊奇、喜悦等      Wow, you look amazing in that dress!（哇，你穿那条裙子太棒了！）这也是一个感叹句，用于表达赞美、兴奋等感情      "
  },
  
  {
    "title": "English 词性",
    "url": "/posts/4-part_of_speech/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:57 +0800",
    





    
    "snippet": "词性      名词（Noun）：表示人、事物、地点、想法等事物的名称它可以作为主语、宾语、表语或其他成分例句：The dog is barking loudly.（狗在大声叫喊）解释：dog 是一个名词，表示动物的一种        动词（Verb）：表示行动、状态、事件发生或存在的词汇它可以用来描述一个人或物体正在做什么，已经完成了什么或将会做什么例句：I am studying Eng...",
    "content": "词性      名词（Noun）：表示人、事物、地点、想法等事物的名称它可以作为主语、宾语、表语或其他成分例句：The dog is barking loudly.（狗在大声叫喊）解释：dog 是一个名词，表示动物的一种        动词（Verb）：表示行动、状态、事件发生或存在的词汇它可以用来描述一个人或物体正在做什么，已经完成了什么或将会做什么例句：I am studying English.（我正在学习英语）解释：studying 是一个动词，表示正在进行的行动        形容词（Adjective）：描述名词或代词的属性或特征，可以放在名词前面或后面它可以修饰一个单独的名词，也可以构成比较级和最高级例句：The red apple looks delicious.（这个红苹果看起来很好吃）解释：red 是一个形容词，表示颜色的特征        副词（Adverb）：描述动词、形容词、其他副词或整个句子的程度、频率、地点等，用于修饰、强调或限定一个词或短语有些副词可以构成比较级和最高级例句：He speaks English fluently.（他英语说得很流利）解释：fluently 是一个副词，表示口语表达的流利程度        代词（Pronoun）：用于代替名词，避免重复使用同一个名词代词可以分为人称代词、物主代词、反身代词和指示代词等例句：She gave me her phone number.（她给了我她的电话号码）解释：her 是一个代词，代指前面提到的女性的某个事物        介词（Preposition）：连接名词、代词或动词和其他词汇与相邻的单词结合起来，表示其在时间、空间、关系等方面的位置或状态，通常用于描述动作发生的地点、时间、原因等例句：The book is on the table.（书在桌子上）解释：on 是一个介词，表示书的位置        冠词（Article）：是一种限定词，用于指定名词的范围英语中有两种冠词：不定冠词“a/an”和定冠词“the”例句：I want a cup of tea.（我想要一杯茶）解释：a 是一个不定冠词，表示茶的数量        连词（Conjunction）：用于连接两个或多个单词、短语或从句，可以连接并列结构或从属结构等例句：She likes to read books and watch movies.（她喜欢读书和看电影）解释：and 是一个连词，连接了两个并列的动作        感叹词（Interjection）：表示强烈感情或惊奇等情绪的单词或短语，通常出现在句子的开头或结尾例句：Wow! That’s amazing!（哇！太神奇了！）解释：Wow 是一个感叹词，表示惊讶和兴奋的情绪  例子 1  The old man, who had been a sailor for many years, sat quietly on the dock, smoking his pipe and watching the seagulls soar overhead.这个例句是由名词、代词、形容词、动词、副词、介词、连词和感叹词组成的，包含了英语中的所有词性      解释          “The” 是一个冠词，用来特指老人      “old” 是一个形容词，描述老人的年龄      “man” 是一个名词，是句子的主语      ”,” 是一个逗号，用来分隔不同的部分      “who” 是一个关系代词，引导从句      “had been” 是一个动词的过去完成时态，表示在过去某个时间已经发生过的动作或状态      “a” 是一个冠词，用来表示船员这一职业的通称      “sailor” 是一个名词，表示船员      “for” 是一个介词，用来表达持续时间      “many” 是一个形容词，表示数量的多少      “years” 是一个名词，表示单位时间      “sat” 是一个动词，表示坐着      “quietly” 是一个副词，表示平静地      “on” 是一个介词，用来表示位置      “the” 是一个冠词，用来特指码头      “dock” 是一个名词，表示码头      ”,” 是一个逗号，分隔不同的部分      “smoking” 是一个现在分词，表示正在进行的动作      “his” 是一个代词，用来表示老人拥有的东西      “pipe” 是一个名词，表示烟斗      “and” 是一个连词，连接两个并列的动作      “watching” 是一个现在分词，表示正在进行的动作      “the” 是一个冠词，用来特指海鸥      “seagulls” 是一个名词，表示海鸥      “soar” 是一个动词，表示飞翔      “overhead” 是一个副词，表示在头顶上            翻译：这位老人是一名船员，已经退休很久了。他静静地坐在码头边吸着烟斗，看着海鸥在头顶上翱翔  例子 2  As the sun began to set, the tired hikers trudged up the steep mountain trail, their aching legs protesting with every step, while the colorful leaves rustled in the cool autumn breeze and the distant sound of a babbling brook filled the air.这个句子包含了名词、代词、形容词、动词、副词、介词、连词和感叹词等英语中所有的词性      解释          “As” 是一个从属连词，引导时间状语从句      “the” 是一个冠词，用来特指阳光      “sun” 是一个名词，表示太阳      “began” 是一个动词，表示开始      “to” 是一个不定式标记，表示后面将跟随不定式结构      “set” 是一个动词，表示落山      ”,” 是一个逗号，分隔不同的部分      “the” 是一个冠词，用来特指疲惫的徒步旅行者      “tired” 是一个形容词，描述旅行者的状态      “hikers” 是一个名词，表示徒步旅行者      “trudged” 是一个动词，表示费力地走      “up” 是一个介词，用来表达方向      “the” 是一个冠词，用来特指陡峭的山路      “steep” 是一个形容词，表示山路的倾斜度      “mountain” 是一个名词，表示山      “trail” 是一个名词，表示小路      ”,” 是一个逗号，分隔不同的部分      “their” 是一个代词，用来表示旅行者拥有的东西      “aching” 是一个现在分词，表示旅行者正在经历的感受      “legs” 是一个名词，表示腿      “protesting” 是一个现在分词，表示旅行者腿部的不适情况      “with” 是一个介词，用来表示伴随着某种状态或情感      “every” 是一个形容词，表示每一次      “step” 是一个名词，表示脚步      ”,” 是一个逗号，分隔不同的部分      “while” 是一个从属连词，引导时间状语从句      “the” 是一个冠词，用来特指树叶      “colorful” 是一个形容词，描述树叶的颜色      “leaves” 是一个名词，表示树叶      “rustled” 是一个动词，表示树叶沙沙作响的声音      “in” 是一个介词，表示方位      “the” 是一个冠词，用来特指秋天的凉爽微风      “cool” 是一个形容词，描述凉爽的感觉      “autumn” 是一个名词，表示秋天      “breeze” 是一个名词，表示微风      “and” 是一个连词，连接两个并列的动作      “the” 是一个冠词，用来特指远处的流水声      “distant” 是一个形容词，描述流水声的距离      “sound” 是一个名词，表示声音      “of” 是一个介词，用来表示所产生的声音      “a” 是一个冠词，表示泛指      “babbling” 是一个现在分词，表示发出潺潺声的水流      “brook” 是一个名词，表示小溪      “filled” 是一个动词，表示填满或充满      “the” 是一个冠词，用来特指空气      “air” 是一个名词，表示空气            翻译：当太阳开始落山时，疲惫的徒步旅行者费力地沿着陡峭的山路向上爬，他们每走一步腿部就感到剧痛。与此同时，彩色的树叶在秋风中沙沙作响，远处潺潺的小溪声充斥着空气中  词性转换好的，让我为您提供所需的信息。在英语中，一个单词可以根据其上下文和用法的不同而表现出不同的词性。以下是一些常见的词性转换及其示例：      名词（Noun）→ 动词（Verb）例如：water（名词）→ to water（动词）；gift（名词）→ to gift（动词）        形容词（Adjective）→ 副词（Adverb）例如：quick（形容词）→ quickly（副词）；happy（形容词）→ happily（副词）        动词（Verb）→ 名词（Noun）例如：run（动词）→ run（名词）；play（动词）→ play（名词）        形容词（Adjective）→ 名词（Noun）例如：good（形容词）→ good（名词）；old（形容词）→ old（名词）        动词（Verb）→ 形容词（Adjective）例如：tire（动词）→ tired（形容词）；bore（动词）→ boring（形容词）        名词（Noun）→ 形容词（Adjective）例如：sun（名词）→ sunny（形容词）；child（名词）→ childlike（形容词）  以下是一个短文，我会解释一些词性转换并翻译这篇短文：“The quick brown fox jumps over the lazy dog.”这是一个英语练笔用的经典句子。其中，“quick”是形容词，表示“快的”，而“quickly”则是其副词形式，表示“快地”；“brown”是形容词，表示“棕色的”，而“brownness”则是其名词形式，表示“棕色”的状态或质量；“fox”是名词，表示“狐狸”，而“tofox”则是其动词形式，表示“欺骗”或“狡猾地行事”等意思。这个短句的意思是：“敏捷的棕色狐狸跳过那只懒散的狗。” 这是一个简单的句子，描述了一个狐狸跳过了一只懒惰的狗的情景。"
  },
  
  {
    "title": "English 音标",
    "url": "/posts/3-phonetic_transcription/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:56 +0800",
    





    
    "snippet": "音标简介  国际音标（IPA）：是用于表示任何语言的符号集合，包括 107 个符号，每个符号都代表一个特定的语音或发音。国际音标通常用于语言学和音韵学领域，并被广泛应用于英语教学中。  英式音标：也称为 RP 音标（Received Pronunciation），是一种英国标准英语的发音方式。英式音标通常使用字母和其他符号来表示单词的发音。这些符号简单易懂，更适合初学者。  美式音标：也称为...",
    "content": "音标简介  国际音标（IPA）：是用于表示任何语言的符号集合，包括 107 个符号，每个符号都代表一个特定的语音或发音。国际音标通常用于语言学和音韵学领域，并被广泛应用于英语教学中。  英式音标：也称为 RP 音标（Received Pronunciation），是一种英国标准英语的发音方式。英式音标通常使用字母和其他符号来表示单词的发音。这些符号简单易懂，更适合初学者。  美式音标：也称为 GA 音标（General American），是一种美国标准英语的发音方式。美式音标通常使用不同的符号和字母来表示单词的发音，与英式音标有一些差异。美式音标在美国英语教育中较为流行。音标选择在国内英语教学中，一般使用的是英式音标（RP 音标）。这是因为英式英语在中国的教育系统中比较普遍，并且许多英语教材和教学资源都采用了英式音标。当然，在一些高端英语培训机构或大学中，也会有教授美式音标（GA 音标）或国际音标（IPA）的课程。音标基础      元音和辅音：音标包含两种基本类型的音，即元音和辅音。元音是由嘴唇、舌头和口腔中的空气构成的声音。辅音是由口腔和喉部花费不同气流或气体产生的声音。        发音位置：为了正确地发出一个音，我们需要掌握正确的发音位置。发声器官的位置决定了声音的性质和特征，例如舌头靠近齿龈会产生清音，舌头后移会产生浊音等。        音标符号：音标用符号来表示不同类型的音。对于国际音标，每个音都有一个特定的符号来表示其发音方式。而在英语音标中，每个音也有一个对应的符号。        音标分类：音标可以根据不同的属性进行分类。例如，元音可以分为前、中和后三类，辅音可以根据发音部位和发音方法进行分类。        语音规则：学习音标还需要了解相关的语音规则。例如，元音的长度、强调和连读等都会影响单词和句子的发音。  字母分类(26)  ABCDEFGHIJKLMNOPQRSTUVWXYZ  元音(5)：A、E、I、O、U  辅音(21)：BCDFGHJKLMNPQRSTVWXYZ音标分类(48)元音参考地址  指发音时不受到发音器官的阻碍发出的声音元音发音  元音音标中单元音按发音时舌头位置的不同分为前元音、中元音和后元音，辅助音按发音时口型的变化分为合口双元音和集中双元音            元音（20 个）                                                            单元音      前元音      /iː/      /ɪ/      /e/      /æ/                     中元音             /ɜː/      /ə/      /ʌ/                            后元音      /uː/      /ʊ/      /ɔː/      /ɒ/      /ɑː/                     双元音      开合 双元音      /eɪ/      /aɪ/      /ɔɪ/      /aʊ/      /əʊ/              集中 双元音      /ɪə/      /eə/      /ʊə/                           长短区分  元音音标中单元音按发音时音音长短的不同分为长元音、短元音，长元音音标符号包括“:”号            元音（20 个）                                                                   单元音      长元音      /iː/      /uː/      /ɑː/      /ɔː/      /ɜː/                     短元音      /ɪ/      /ʊ/      /ʌ/      /ɒ/      /ə/      /e/      /æ/              双元音      合口双元音      /aɪ/      /eɪ/      /ɔɪ/      /aʊ/      /əʊ/                     集中双元音      /ɪə/      /eə/      /ʊə/                                  辅音参考地址      气流在口腔或咽头受到阻碍而形成的音叫做辅音，又叫子音，辅音发音时气流受到发音器官的各种阻碍，声带不一定振动，不够清晰响亮    标记辅音的符号叫辅音音标，英式国际英语音标中共有 28 个辅音音标  辅音说明  辅音音标根据发音时声带是否振动分为清辅音和浊辅音；  根据发音方式分为爆破音、摩擦音、破擦音、鼻音、舌侧音和半元音；  根据使用的发音部位分为双唇音、唇齿音、上腭音、舌齿音、软腭音和声门音  辅助发音的特点是气流受到发音器官的阻碍。  辅音音标不能单独成音，通常和元音结合构成音节说明            辅音                                                            爆破音      清辅音      /p/      /t/      /k/                            浊辅音      /b/      /d/      /ɡ/                                   摩擦音      清辅音      /f/      /s/      /ʃ/      /θ/      /h/              浊辅音      /v/      /z/      /ʒ/      /ð/      /r/                     破擦音      清辅音      /tʃ/      /tr/      /ts/                            浊辅音      /dʒ/      /dr/      /dz/                                   鼻音      浊辅音      /m/      /n/      /ŋ/                            舌则音      浊辅音      /l/                                          半元音      浊辅音      /j/      /w/                           元音和辅音区别  元音和辅音都都属于音素，台湾地区 元音也称之为母音，辅音也称之在子音。那么元音和辅音的区别什么时么呢？首先我们来看一下元音和辅音的定义  元音：发音时声带振动，呼出的气流通过口腔时不受阻碍，这样形成的语音称作元音。元音发音响亮，口腔中气流不受阻碍，是构成音节的主要音  辅音：不论声带振动与否，发声时呼出的气流通过口腔或鼻腔时受到一定阻碍，这样的语音称为辅音。辅音发音不响亮，口腔中气流受到阻碍，不是构成音节的主要音  根据元音的定义以及发音特点我们总结了元音和辅音的区别有以下几点          发元音的时候,气流在发声过程中不受阻碍；发辅音的时候,声道的某一部位封闭起来而形成阻碍,气流必须克服这种阻碍才能通过      发元音的时候声带震动；发辅音的时候，浊辅音声带震动，轻辅音声带不震动      发元音的时候,呼出的气流畅通无阻,因而气流较弱；发辅音的时候,呼出的气流必须冲破阻碍才能通过,因而气流较强      发元音的时候,发音器官各个部分的紧张程度是均衡的；发辅音的时候,形成阻碍的部位就会特别紧张      元音能独立或者与辅音一起构成音节.而在辅音中,除【m】【n】【l】 能与其它辅音构成音节外,其它辅音相互不能构成音节.      音标全部            元音                                                            单元音      前元音      /iː/      /ɪ/      /e/      /æ/                     中元音             /ɜː/      /ə/      /ʌ/                            后元音      /uː/      /ʊ/      /ɔː/      /ɒ/      /ɑː/                     双元音      开合双元音      /eɪ/      /aɪ/      /ɔɪ/      /aʊ/      /əʊ/              集中双元音      /ɪə/      /eə/      /ʊə/                                   辅音                                                        爆破音      清辅音      /p/      /t/      /k/                            浊辅音      /b/      /d/      /ɡ/                                   摩擦音      清辅音      /f/      /s/      /ʃ/      /θ/      /h/              浊辅音      /v/      /z/      /ʒ/      /ð/      /r/                     破擦音      清辅音      /tʃ/      /tr/      /ts/                            浊辅音      /dʒ/      /dr/      /dz/                                   鼻音      浊辅音      /m/      /n/      /ŋ/                            舌则音      浊辅音      /l/                                          半元音      浊辅音      /j/      /w/                           "
  },
  
  {
    "title": "English Base",
    "url": "/posts/2-basic/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:55 +0800",
    





    
    "snippet": "英语知识点音标词性句型和句子结构时态语态",
    "content": "英语知识点音标词性句型和句子结构时态语态"
  },
  
  {
    "title": "English 简介",
    "url": "/posts/1-english/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 12:12:54 +0800",
    





    
    "snippet": "简介      英语是由古代日耳曼人所说的一系列语言发展而来的。最初的英语语言可以追溯到中世纪时期的英格兰和苏格兰，当时的英语被称为“古英语”或“盎格鲁-撒克逊语”。这种古老的英语语言与现代英语相比有很大的差异，包括发音、语法和词汇等方面。        在接下来的几个世纪中，英语经历了许多变迁和演变。随着时间推移和政治经济背景的变化，英语逐渐从古老的形式发展成为现代英语。在英国的文艺复兴时...",
    "content": "简介      英语是由古代日耳曼人所说的一系列语言发展而来的。最初的英语语言可以追溯到中世纪时期的英格兰和苏格兰，当时的英语被称为“古英语”或“盎格鲁-撒克逊语”。这种古老的英语语言与现代英语相比有很大的差异，包括发音、语法和词汇等方面。        在接下来的几个世纪中，英语经历了许多变迁和演变。随着时间推移和政治经济背景的变化，英语逐渐从古老的形式发展成为现代英语。在英国的文艺复兴时期（16世纪），英语经历了重要的变革，开始借用大量拉丁语和希腊语的词汇并创造新词，这也导致了英语的词汇量不断扩大、变得更加丰富。        英语的地位在 20 世纪之后得到了进一步的提升，成为了世界上最流行的语言之一。这主要是因为英国在 19 世纪和 20世纪大规模地进行了殖民扩张，将英语带到了全球范围内。此外，美国在 20 世纪也成为了全球经济和文化的中心，进一步推动了英语的国际化。        现在，英语是全球最重要的商务、政治、科技和文化交流语言之一。许多国际组织、学术期刊、网站和社交媒体平台都使用英语作为官方语言，而且大量的商业、法律、科技和医学文件也都是由英语编写的。  怎么学习英语,怎么去学      制定计划：在开始学习英语之前，先制定一个合理的学习计划，包括每天或每周要学习多少时间、学习哪些方面的内容、达到什么样的目标等。这可以帮助您有条不紊地进行英语学习，并保持动力。        学习基础知识：在学习英语之前，需要掌握一些基础知识，如字母、基本语法规则、常见单词等。可以通过网络上的学习资源、教科书、学习应用程序等途径学习这些基础知识。        多听多说：听说是语言学习中最重要的部分。所以，在学习英语时，尽量多听真实的英语口音，可以通过听英语广播、看英语电视节目、观看英语电影等方式来提高自己的听力和口语表达能力。同时，也可以找到机会与讲英语的人交流，练习口语表达。        阅读和写作：阅读和写作对于提高英语能力同样重要。可以读英文杂志、报纸和小说，提高词汇量、语法知识和阅读理解能力；在写作方面，可以通过写日记、练习写作文等方式来加强自己的写作能力。  5.重视语言环境：语言环境是学习英语的一个重要因素。如果您身处英语为母语的国家或地区，那么可以主动融入当地社会、参加当地活动、结交本土朋友等方式来增强语言环境。如果没有条件去英语为母语的国家，也可以尽量让自己身处英语氛围之中，如观看英语电视节目、听英语歌曲、使用英语应用程序等。  制定合理的学习计划和目标：制定适合自己的学习计划和目标非常重要。这样可以帮助您保持动力、持之以恒地进行学习，并且协助您监督自己的进展。规划和计划第一阶段（时间：1 个月）      学习发音和基本语音规则：学习 26 个英文字母和它们的发音，了解英语基本语音规则。        词汇学习：学习 200-300 个常用单词，并记住它们的拼写和意思。可以使用英语学习应用程序或基础英语教材进行学习。        学习基本句型：学习基本的英语语法知识，如主谓宾结构、时态等，并练习几个基本句型的构造。        英语听力和口语练习：尝试与英语为母语的人交流，通过参加英语角或找到一位英语口语伙伴来提高自己的口语水平。  第二阶段 (时间：3 个月)      扩充词汇量：在前期基础上，扩充词汇量，学习 1000-1500 个常用单词，并掌握它们的用法和搭配。        学习语法和句型：深入学习英语基本语法知识，例如被动语态、条件句、疑问句等，并练习不同类型的句子构造。        阅读和写作练习：通过阅读英语文章来提高阅读理解能力，同时也可以通过写日记、对话或短文来训练自己的写作能力。        英语听力和口语练习：继续与母语人士交流，注意模仿他们的发音和表达方式，并积极参加英语活动。  第三阶段 (时间：6 个月)      高级语法和词汇：学习更高级的英语语法规则，如复合结构、间接引语等，并增加词汇量。        提高听力和口语：尝试听英语广播、看英语电影或电视剧，并积极参加英语会话，以提高听力和口语水平。        学习专业英语：根据自己的兴趣和需求，学习专业英语，掌握相关领域的术语和表达方式。        应用实践：将所学的英语知识应用到实际生活中，例如与外国朋友交流、参加英语面试等。  英音和美音选择      英音和美音的区别主要在于发音、语调、语速和用词等方面。        在发音方面，英音通常比美音更加清晰和准确。例如，在英音中“water”这个单词的发音为/wɔːtə/，而在美音中则是/ˈwɑːt̬ɚ/此外，英音重点强调元音，而美音则更注重辅音。        在语调和语速方面，英音通常比美音更为缓慢和平稳。例如，在英音中句子结尾通常会有一个升调，而在美音中则可能会出现降调或上扬式语调。        在用词方面，英音和美音也存在差异，例如在一些日常用语、习惯用语和俚语等方面。        选择学习哪种发音取决于您的学习目标和实际需求。如果您的主要交流对象是来自英国或其他英联邦国家的人，则学习英音会更为适合；如果您的主要交流对象是美国或加拿大人，则学习美音会更为适合。        在国内教学中，通常使用的是英音，但也有一些机构提供美音的课程。不管选择哪种发音，都应该注重基本的发音规则，并通过听力练习和实践来提高自己的口语水平。  影视推荐      《老友记》（Friends）这是一部经典的美国情景喜剧，以六个好友之间的生活和工作为主线，讲述了各种幽默的故事情节。它的语速适中，用词简单，非常适合英语初学者观看。        《行尸走肉》（The Walking Dead）这是一部非常流行的美国恐怖剧，描述了一个末日世界中幸存者们的生存故事。它的语言内容相对复杂，但它能提供更多的词汇和语法知识。        《发现之旅》（Discovery）这是一部非常有趣的纪录片系列，探索了地球上的各种自然奇观和文化现象。它使用的语言相对简单，能够帮助提高听力和阅读能力。        《神探夏洛克》（Sherlock）这是一部改编自英国作家阿瑟·柯南·道尔创作的名侦探小说的电视剧，讲述了一位神探和他的助手解决各种案件的故事。它的英语内容具有一定的难度，但是语言运用精准，对提高听力和阅读能力很有帮助。        《时空恋旅人》（Doctor Who）这是一部英国科幻电视剧，讲述了一位时间领主和他的同伴旅行穿越时间和空间的故事。它的语言难度较高，但是对于提高听力和阅读能力和理解英国文化背景都有很大帮助。        《野性的呼唤》（Call of the Wild）这是一部基于杰克·伦敦的同名小说改编的电影，描述了一只狗在阿拉斯加野外生存的故事。它的语言内容相对简单，适合英语初学者观看。    选取适合自己英语水平的影视剧或纪录片，可以在娱乐中提升英语能力。同时，配合字幕观看，有助于提高听力和阅读能力。"
  },
  
  {
    "title": "English 背单词技巧",
    "url": "/posts/vocabulary/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 11:12:55 +0800",
    





    
    "snippet": "背单词技巧  利用记忆法：将单词与形象的图像、故事或关联起来，可以更容易地记忆单词。例如，把“banana”（香蕉）和一个画着笑脸的香蕉联系起来。这种记忆方法被称为视觉记忆法，它能够帮助您将单词转化成可视的形象，使其更容易记忆。另外还有听觉记忆法和动作记忆法等  分类记忆：将单词按主题分类，如食品、动物、家庭等。这样可以帮助您将单词组织在一起，方便记忆。此外，如果您正在学习某个特定领域的英语...",
    "content": "背单词技巧  利用记忆法：将单词与形象的图像、故事或关联起来，可以更容易地记忆单词。例如，把“banana”（香蕉）和一个画着笑脸的香蕉联系起来。这种记忆方法被称为视觉记忆法，它能够帮助您将单词转化成可视的形象，使其更容易记忆。另外还有听觉记忆法和动作记忆法等  分类记忆：将单词按主题分类，如食品、动物、家庭等。这样可以帮助您将单词组织在一起，方便记忆。此外，如果您正在学习某个特定领域的英语词汇，例如商务、医疗或科技，可以将单词按该领域进行分类，以便更好地理解和使用这些单词  多次重复：多次重复单词是记忆的关键。反复阅读单词列表、写下单词、朗读单词，都可以帮助您记忆单词。您可以将单词写在卡片上，每天花几分钟时间进行复习，或者在学习过程中使用闪卡，不断重复单词，直到您能够熟练掌握这些单词  制作卡片：写下单词和定义，以及相关的图片或例句，制成卡片，随时随地进行复习。在每张卡片上，您可以写下该单词的释义、近义词、反义词、用法等信息，以便更好地记忆这些单词。此外，您还可以在卡片上添加关联的图像或例句，以帮助您更好地理解单词的意思  应用到实际生活中：将新学习的单词应用到日常生活中，如在对话中使用、写邮件或文章时使用，可以加深记忆。通过使用这些单词来表达自己的思想和意见，您可以更好地理解它们的含义和用法，并在实践中更熟练地应用它们  使用在线资源：许多网站和应用程序可以提供背单词的帮助，包括 Quizlet、Anki 和 Memrise 等。这些资源可以根据您的学习需求和兴趣为您提供各种类型的单词列表和记忆方法。此外，这些资源还可以跟踪您的进度和提供反馈，以帮助您更好地记忆和掌握单词网站和书籍  Quizlet：Quizlet 是一个在线学习平台，可以让用户创建和分享各种类型的学习资料，包括单词列表、闪卡、测试等。  Anki：Anki 是一款基于间隔重复记忆算法的开源软件，可以帮助用户更有效地记忆单词、概念、公式等内容。  Memrise：Memrise 是一个多语言学习平台，可以提供各种类型的学习课程和游戏，包括语言、科学、文化等领域。  Duolingo：Duolingo 是一款免费的语言学习应用程序，可以帮助用户学习多种语言，包括英语、西班牙语、法语等。  Cambridge English Vocabulary in Use 系列（https://www.cambridge.org/us/cambridgeenglish/catalog/vocabulary-and-grammar/vocabulary-use）：Cambridge English Vocabulary in Use 系列是由剑桥大学出版社出版的一套词汇教材，覆盖从初级到高级的各个层次，可以帮助学习者系统地掌握英语词汇。  Oxford Word Skills 系列（https://elt.oup.com/catalogue/items/global/skills/vocabulary/oxford_word_skills/?cc=cn&amp;selLanguage=en）：Oxford Word Skills 系列是由牛津大学出版社出版的一套词汇教材，包括基础、中级和高级三个层次，针对不同水平的学习者提供了丰富的单词练习和解释。App  扇贝单词：扇贝单词是一款功能齐全的背单词 App，提供海量单词库和各种学习模式，包括闪卡、听力、口语等。  有道词典：有道词典是一款广受欢迎的翻译和词典 App，除了提供单词释义和例句外，还可以通过朗读、发音练习等方式帮助用户记忆单词。  单词背诵机：单词背诵机是一款专门针对英语四级和六级考试设计的背单词 App，提供大量真实考试题目以及各种背单词功能。  知米背单词：知米背单词是一款注重用户体验的背单词 App，提供精美的 UI 界面和多种学习模式，包括闪卡、填空、选择等。  喜马拉雅背单词：喜马拉雅背单词是一款通过听力练习帮助用户记忆单词的 App，提供大量英语原版音频材料和智能化的练习模式。"
  },
  
  {
    "title": "English 国内教育",
    "url": "/posts/education/",
    "categories": "Cc, English",
    "tags": "English",
    "date": "2020-05-16 11:12:54 +0800",
    





    
    "snippet": "学校教学内容小学一年级：  英文字母表和发音  常用单词及其拼写、发音和意义  常见问候语  数字 1-100 的拼写  简单的日常生活用语二年级：  时间、星期和月份  季节和天气  家庭成员和身体部位  城市和交通工具  食物和饮料  常见动物和植物  简单的日常对话三年级：  介绍自己和他人  询问和回答有关个人信息的问题  动作动词和描述人物的形容词  天文和地理知识  每日生活中的...",
    "content": "学校教学内容小学一年级：  英文字母表和发音  常用单词及其拼写、发音和意义  常见问候语  数字 1-100 的拼写  简单的日常生活用语二年级：  时间、星期和月份  季节和天气  家庭成员和身体部位  城市和交通工具  食物和饮料  常见动物和植物  简单的日常对话三年级：  介绍自己和他人  询问和回答有关个人信息的问题  动作动词和描述人物的形容词  天文和地理知识  每日生活中的活动和习惯四年级：  时间和日期  家庭、朋友和社会生活  纪念日和传统节日  学校生活和教育制度  活动和爱好五年级：  运动和比赛  旅游和文化  计算器和货币  自然和环境  国家和语言六年级：  人类身体内部器官和系统  基础数学和几何  健康和营养  社会和环保  电影、音乐和艺术中学七年级：  英语基础语法知识  简单的交际用语和日常对话  数字、日期、时间和天气  基本的词汇和语法结构  介绍自己和他人  描述家庭成员和朋友  购物和点餐八年级：  更深入的语法知识  简单的听力和口语训练  学校和课程  爱好和兴趣  家庭生活和日常活动  旅游和文化  时间表达和日程安排九年级：  英语高级语法知识  阅读和写作技能的提高  听力和口语技能的加强  社交媒体和网络安全  学校和大学生活  工作和职业规划  环境和社会问题高中高一      秋季学期：          英语基础知识：名词、动词、形容词、副词、冠词、代词和介词等。      阅读和写作能力：短文阅读理解和简单的写作技巧。      口语和听力能力：日常用语和简单的对话。            春季学期：          语法和词汇：时态、语态、复合句、从句、名词性从句、形容词性从句、副词性从句、虚拟语气、情态动词等。      阅读和写作：更高层次的阅读和写作能力提高，如文章的分析和写作技巧。      口语和听力能力：连贯的对话和演讲技巧的练习。      高二      秋季学期：          英语词汇量扩充：学习专业术语和常用短语。      阅读和写作技巧加强：包括写作规范、段落组织和表达清晰等更高级别的技巧。      口语和听力能力：更长的对话和演讲技巧提高。            春季学期：          学术写作能力：如论文写作和研究报告等。      阅读和写作加强：进一步提高阅读理解和写作能力。      口语和听力能力：更长篇幅的演讲或对话，并且要有较强的思考和表达能力。      高三      秋季学期：          学术英语和应试英语：备战大学英语四级、六级等各种英语考试，以及准备 SAT、ACT 和 GRE 等留学考试。      写作能力：写作技巧和写作规范的进一步加强，包括议论文、说明文和叙述文等各种类型的写作形式      阅读能力：多样化的阅读材料，包括小说、报纸、期刊等。            春季学期：          应试英语能力：备战高考英语，涵盖听力、阅读、写作和翻译等各个方面的考试内容。      文学知识：学习英美文学经典作品以及当代文学作品的故事情节、主题和语言特点。      口语和听力能力：包括发表演讲、辩论等各方面的口语表达能力和听力理解能力。      "
  },
  
  {
    "title": "linux Shell Base",
    "url": "/posts/system-shell-base/",
    "categories": "DevOps, Shell",
    "tags": "LinuxTool, Shell",
    "date": "2020-04-20 22:05:01 +0800",
    





    
    "snippet": "ShellGithubhelloworld      创建与写    touch helloworld.shvim helloworld.sh#!/bin/bashecho \"Hello World !\"// #! 是个约定标记// echo 向窗口输出文本            执行    chmod +x ./helloworld.sh./helloworld.sh就可以看到控制台输出H...",
    "content": "ShellGithubhelloworld      创建与写    touch helloworld.shvim helloworld.sh#!/bin/bashecho \"Hello World !\"// #! 是个约定标记// echo 向窗口输出文本            执行    chmod +x ./helloworld.sh./helloworld.sh就可以看到控制台输出Hello World !      Shell 变量命名规则  命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。  中间不能有空格，可以使用下划线（_）。  不能使用标点符号。  不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。操作  创建使用    #!/bin/bashuser_name=\"lcc\"age=23sex=\"男\"echo $user_nameecho $age# 建议使用${变量名}# 为了帮助解释器识别变量的边界:&lt;&lt;EOFecho \"I am good at ${skill}Script\"EOFecho ${sex}        只读#!/bin/bashuser_name=\"lcc\"readonly user_nameuser_name=\"Cc\"echo ${user_name}结果会提示：lccscript.sh: line 4: user_name: readonly variable  删除#!/bin/bashuser_name=\"lcc\"unset user_nameecho ${user_name}运行结果什么都不会输出，建议提示变量不存在  变量类型运行 shell 时，会同时存在三种变量：  局部变量 局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。  环境变量 所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。  shell 变量 shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行字符串单引号与双引号  单引号#!/bin/bashname='C\\sadf@$@#!$@#@#!c\\'echo ${name}url='\"lichaoche's'ng.top\"'echo ${url}运行结果C\\sadf@$@#!$@#@#!c\\\"lichaochesng.top\"  双引号#!/bin/bashname='Cc'str=\"Hello, I know you are \\\"${name}\\\"! \\n\"echo  -e ${str}运行结果Hello, I know you are \"Cc\"!  区别          单引号                  单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的          单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用                    双引号                  双引号里可以有变量          双引号里可以出现转义字符                    字符串操作  拼接    #!/bin/bash    your_name=\"Cc\"    # 使用双引号拼接    greeting=\"hello, \"$your_name\" !\"    greeting_1=\"hello, ${your_name} !\"    echo $greeting  $greeting_1    # 使用单引号拼接    greeting_2='hello, '$your_name' !'    greeting_3='hello, ${your_name} !'    echo $greeting_2  $greeting_3运行结果hello, Cc ! hello, Cc !hello, Cc ! hello, ${your_name} !  获取长度    #!/bin/bashname=\"CcAndHyperAndLccAndChaoChengLi\"echo ${#name} #输出 30sex=\"Male\"echo ${#sex}#输出4        提取字符串    #!/bin/bashname=\"lcc\"# 0 开始计算echo ${name:0:2} #输出 lcecho ${name:1:2} #输出ccecho ${name::2} #输出 lc        查找字符串shell #!/bin/bash name=\"lcc shell\" # 哪个字母先出现就计算哪个 echo `expr index \"${name}\" l` #输出 1 ps:为什么查找从1开始计算 echo `expr index \"${name}\" e` #输出 7           ps:是 ` 不是 ‘      数组  创建、查看、获取、修改、[二维数组….]    #!/bin/bash    # 数组没有逗号分隔    arrayName=(\"lcc\" \"Cc\" \"Hyper\" 10)    arrayAge=(    23    18    6    )    # 下面查看数组    echo ${arrayName[1]}\t #输出 Cc    echo ${arrayAge[1]}\t\t#输出 18    # 获取所有元素    echo ${arrayName[@]}\t#输出 lcc Cc Hyper 10    # 数组长度    length=${#arrayName[@]}    echo ${length}\t#输出 4    echo ${#arrayAge[*]}\t#输出 3    # 通过下标修改元素    arrayName[0]=\"yes\"    echo ${arrayName[@]}\t#yes Cc Hyper 10    #--------    # 二维数组    # https://www.jianshu.com/p/543fa9df3469    # https://www.cnblogs.com/wyf-349/p/11236939.html    #--------传递参数[root@iz2zeb00z6vr5gix5utl11z parameter]# cat demo1.sh#!/bin/bashecho \"运行时参数传递\";echo \"执行的文件名：$0\";echo \"第一个参数为：$1\";echo \"第二个参数为：$2\";echo \"第三个参数为：$3\";echo \"参数个数：$#\"echo \"传递的参数作为一个字符串显示：$*\"echo \"-- \\$* 演示 ---\"for i in \"$*\"; doecho $idoneecho \"-- \\$@ 演示 ---\"for i in \"$@\"; doecho $idone[root@iz2zeb00z6vr5gix5utl11z parameter]# ./demo1.sh lcc 23 M运行时参数传递执行的文件名：./demo1.sh第一个参数为：lcc第二个参数为：23第三个参数为：M参数个数：3传递的参数作为一个字符串显示：lcc 23 M-- $* 演示 ---lcc 23 M-- $@ 演示 ---lcc23M区别  #$* 与 $@ 区别：          相同点：都是引用所有参数。      不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。      运算符operator算术运算符  代码 operator/t2.sh注意：  乘号(*)前边必须加反斜杠()才能实现乘法运算；  if…then…fi 是条件语句，后续将会讲解。  在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\" 。关系运算符  代码 operator/t3.sh布尔运算符  代码 operator/t4.sh逻辑运算符  代码 operator/t5.sh字符串运算符  代码 operator/t6.sh文件检测运算符  代码 operator/t7.sh"
  },
  
  {
    "title": "零散的脚本",
    "url": "/posts/bash_shell/",
    "categories": "DevOps, Shell",
    "tags": "LinuxTool, Shell",
    "date": "2020-04-20 22:05:01 +0800",
    





    
    "snippet": "开发 sh 脚本杀死进程kill.sh#!/bin/sh#根据进程名杀死进程if [ $# -lt 1 ]then  echo \"缺少参数：procedure_name\"  exit 1fiPROCESS=`ps -ef|grep $1|grep -v grep|grep -v PPID|awk '{ print $2}'`for i in $PROCESSdo  echo \"Kill th...",
    "content": "开发 sh 脚本杀死进程kill.sh#!/bin/sh#根据进程名杀死进程if [ $# -lt 1 ]then  echo \"缺少参数：procedure_name\"  exit 1fiPROCESS=`ps -ef|grep $1|grep -v grep|grep -v PPID|awk '{ print $2}'`for i in $PROCESSdo  echo \"Kill the $1 process [ $i ]\"  kill -9 $idone定时执行脚本编写脚本编写一个脚本文件，使脚本可以执行备份命令。例如，将文件目录 /home/backups/balalala 备份到/home目录下，并压缩。      创建脚本命令格式: touch 路径/文件名.sh例如：输入命令：touch /home/backup.sh        写入命令首先进入脚本：vi 命令vi /home/backup.sh在脚本内写入：  #！/bin/shmkdir /home/beifen#创建一个临时文件（要保存备份的路径）cp -r /home/backups/balalala  /home/beifen#数据存在backups目录下，备份到beifen目录下，所以先将数据拷过来tar -zcPvf /home/backup$(date +%Y%m%d).tar.gz /home/beifen #将数据所在文件夹beifen打包rm -rf /home/beifen/ #删除临时文件内容find ./ -mtime +30 -name \"*.tar.gz\" -exec rm -rf {} \\;#删除改文件夹下超过30天的文件 3. 执行脚本文件直接手动执行脚本文件。命令格式：sh 路径/文件名.sh例如：sh /home/backup.sh设置定时执行本脚本例如：设置脚本每 7 天执行一次。      安装 crond如果没有安装 crond 服务就先装上服务。检查服务状态：service crond status        修改 crontab 内容输入命令：crontab –e进入后继续输入命令：0 0 /7 * /home/backup.sh设置为每 7 天执行一次脚本文件然后，保存退出:wq  sh 脚本前面五个字段分别表示分钟（0-59）、小时（0-23）、日（1-31）、月（0-12）、星期几（0-6）后面的为脚本所在目录"
  },
  
  {
    "title": "System Linux Error",
    "url": "/posts/shellother/",
    "categories": "DevOps, Shell",
    "tags": "Tools",
    "date": "2020-04-20 22:05:01 +0800",
    





    
    "snippet": "ssh 工具  MobaXterm  Xshell记录开启 root 用户登录https://blog.csdn.net/wy_97/article/details/78294562yum install htopNo package htop available.Error: Nothing to do解决办法解决办法，安装epel-release之后，再安装htop:sudo yum u...",
    "content": "ssh 工具  MobaXterm  Xshell记录开启 root 用户登录https://blog.csdn.net/wy_97/article/details/78294562yum install htopNo package htop available.Error: Nothing to do解决办法解决办法，安装epel-release之后，再安装htop:sudo yum updatesudo yum install -y epel-releasesudo yum install -y htop什么是EPEL？EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。参考：Available Repositories for CentOS"
  },
  
  {
    "title": "系统设计（自动化权限）",
    "url": "/posts/Jurisdiction/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils, GoWeb",
    "date": "2020-04-19 22:58:36 +0800",
    





    
    "snippet": "权限自动化权限  准备知识：swagger、递归、注解、过滤器设计  权限是每一个管理系统必备的一个功能，多租用户设计必备，虽然有很多集成框架工具包比如：“Casbin、GRABC”，但是其怎么判断其实原理都是一样的表结构说明  用户表和用户与角色中间表：无论是超级管理员添加的还是注册用户都会有一个角色初始权限。如果是超级管理员添加添加是可以指定那些角色，角色中有哪些权限，如果是App用户注...",
    "content": "权限自动化权限  准备知识：swagger、递归、注解、过滤器设计  权限是每一个管理系统必备的一个功能，多租用户设计必备，虽然有很多集成框架工具包比如：“Casbin、GRABC”，但是其怎么判断其实原理都是一样的表结构说明  用户表和用户与角色中间表：无论是超级管理员添加的还是注册用户都会有一个角色初始权限。如果是超级管理员添加添加是可以指定那些角色，角色中有哪些权限，如果是App用户注册的有哪些权限注册时会初始化一个最初权限，可以通过开通会员，或者做任务升级拥有想应得角色。在此可能会产生一个用户多个角色，所以会有用户表与角色中间表来记录  资源表：可以使用 swagger 工具与注解，在启动是扫描所有接口并且通过递归解析swagger.json文件，初始化所有接口名称与接口url，插入表中  角色表：在程序初始化时需要，在表中初始默认角色，或者管理员用户添加角色时选择相应资源执行步骤  http 请求过滤器校验  获取token 其中用户唯一标识，以及用户http请求的url  通过用户唯一标识查询用户角色 ，获取用户角色唯一标识  通过角色唯一标识和url查询资源表是否有对应的资源(url)  如果有忽略，没有则返回，没有对应权限注解  在控制器接口以及路由文件中添加// Login 用户登录// @Tags 登录管理// @Summary 用户登录// @Param body body schema.LoginParam true \"请求参数\"// @Success 200 {object} schema.LoginTokenInfo// @Failure 400 {object} schema.HTTPError \"{error:{code:0,message:无效的请求参数}}\"// @Failure 500 {object} schema.HTTPError \"{error:{code:0,message:服务器错误}}\"// @Router /api/v1/pub/login [post]func (a *Login) Login(c *gin.Context) {}swagger      下载swagger 工具添加，Go 环境的bin 目录下        进入项目根目录 swag init 生成或者使用以下方式    go get -u github.com/swaggo/swag/cmd/swagswag init -g ./internal/app/routers/swagger.go -o ./docs/swaggerswag init -g ./internal/app/routers/swagger.go -o ./docs/swagger/            会生成docs目录 里面有    |-- docs.go|-- swagger.json|-- swagger.yaml      递归解析  需要在main 方法调用函数启动解析  递归解析代码如下 demopackage mainimport (\t\"encoding/json\"\t\"io/ioutil\"\t\"strings\"\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"\t\"github.com/Cc360428/HelpPackage/result\")func main() {    // 所在 swagger.json 路径\tGetFile(\"swagger.json\")}type Resource struct {\tName string `json:\"name\"` //名称\tUrl  string `json:\"url\"`  //路径}func SwaggerJson(swagger string) (a map[string]interface{}) {\txxx := make(map[string]interface{})\tbytes, err := ioutil.ReadFile(swagger)\tif err != nil {\t\tlogs.Error(err.Error())\t}\terr = json.Unmarshal(bytes, &amp;xxx)\tif err != nil {\t\tlogs.Error(\"error\", err.Error())\t}\tbirds := xxx[\"paths\"].(map[string]interface{})\t// logs.Info(\"返回 映射\", birds)\treturn birds}func GetOpId(vv interface{}) (ret interface{}) {\tdd := make(map[string]interface{})\t_ = result.HelperConvetInterface(vv, &amp;dd)\tfor kk, value := range dd {\t\tif kk == \"summary\" {\t\t\tret = value\t\t\treturn value\t\t} else {\t\t\tret = GetOpId(value)\t\t\tif ret != nil {\t\t\t\treturn ret\t\t\t}\t\t}\t}\treturn nil}func GetFile(path string) {\tbirds := SwaggerJson(path)\tvar pps []*Resource\tfor url, value := range birds {\t\tname := GetOpId(value)\t\tvar pp Resource\t\tpp.Url = url\t\t_ = result.HelperConvetInterface(name, &amp;pp.Name)\t\tpps = append(pps, &amp;pp)\t\tn := InterfaceTurnString(name)\t\t// 这里会根据自定义 符号分割\t\t// t := SplitUtil(n, \".\")\t\t_, _ = PowerAddOne(n, url)\t}}func PowerAddOne(name, url string) (id int64, err error) {\tlogs.Info(name, url)\treturn\t//保存到数据库}//字符串分割//第一个参数为要分割的字符串，第二个参数为分割的条件//返回分割后的数组func SplitUtil(parameter string, condition string) []string {\tstr := strings.Split(parameter, condition)\treturn str}//interface 转 stringfunc InterfaceTurnString(pr interface{}) string {\ts := pr.(string)\treturn s}"
  },
  
  {
    "title": "openWrt uci",
    "url": "/posts/uci/",
    "categories": "DevOps, OpenWrt",
    "tags": "Tools",
    "date": "2020-04-18 14:33:04 +0800",
    





    
    "snippet": "  uci setroot@Accesshub:/etc/config# uci set qos.cc=interfaceroot@Accesshub:/etc/config# uci set qos.cc.classgroup=defaultroot@Accesshub:/etc/config# uci set qos.cc.enabled=1root@Accesshub:/etc/con...",
    "content": "  uci setroot@Accesshub:/etc/config# uci set qos.cc=interfaceroot@Accesshub:/etc/config# uci set qos.cc.classgroup=defaultroot@Accesshub:/etc/config# uci set qos.cc.enabled=1root@Accesshub:/etc/config# uci set qos.cc.upload=134root@Accesshub:/etc/config# uci set qos.cc.download=1000root@Accesshub:/etc/config# uci commit qosroot@Accesshub:/etc/config# grep -A 6 cc qosconfig interface 'cc'        option classgroup 'default'        option enabled '1'        option upload '134'        option download '1000'  uci addroot@Accesshub:/etc/config# uci add qos classifycfg118143root@Accesshub:/etc/config# uci set qos.@classify[3].target=\"Priority\"root@Accesshub:/etc/config# uci set qos.@classify[3].ports=\"22,23,80,333\"root@Accesshub:/etc/config# uci set qos.@classify[3].comment=\"ssh,frp,ftp,http,http(s),imap\"root@Accesshub:/etc/config# uci commit qosroot@Accesshub:/etc/config# grep -A 20 cc qosconfig interface 'cc'        option classgroup 'default'        option enabled '1'        option upload '134'        option download '1000'config classify        option target 'Priority'        option ports '22,23,80,333'        option comment 'ssh,frp,ftp,http,http(s),imap'uci show qosuci set qos.@default[2].proto=\"tcp\"uci set qos.@default[2].portrange=\"1024-65535\"uci commit qosconfig interface 'cc'        option classgroup 'default'        option enabled '1'        option upload '134'        option download '1000'config classify        option target 'Priority'        option ports '22,23,80,333'        option comment 'ssh,frp,ftp,http,http(s),imap'config default        option proto 'tcp'        option portrange '1024-65535'设置 classgrouproot@Accesshub:/etc/config# uci set qos.CcClassGroup=classgrouproot@Accesshub:/etc/config# uci set qos.CcClassGroup.classes=\"Cc Priority Express Mormal Bulk\"root@Accesshub:/etc/config# uci set qos.CcClassGroup.default=\"Cc\"root@Accesshub:/etc/config# uci commit qosroot@Accesshub:/etc/config# grep -A 30 cc qosconfig interface 'cc'        option classgroup 'default'        option enabled '1'        option upload '134'        option download '1000'config classify        option target 'Priority'        option ports '22,23,80,333'        option comment 'ssh,frp,ftp,http,http(s),imap'config default        option proto 'tcp'        option portrange '1024-65535'config classgroup 'CcClassGroup'        option classes 'Cc Priority Express Mormal Bulk'        option default 'Cc'配置 classroot@Accesshub:/etc/config# uci set qos.Cc=classroot@Accesshub:/etc/config# uci set qos.Cc.packetsize=\"1600\"root@Accesshub:/etc/config# uci set qos.Cc.packetdelay=\"160\"root@Accesshub:/etc/config# uci set qos.Cc.avgrate=\"16\"root@Accesshub:/etc/config# uci set qos.Cc.priority=\"6\"root@Accesshub:/etc/config# uci commit qosroot@Accesshub:/etc/config# grep -A 50 cc qosconfig interface 'cc'        option classgroup 'default'        option enabled '1'        option upload '134'        option download '1000'config classify        option target 'Priority'        option ports '22,23,80,333'        option comment 'ssh,frp,ftp,http,http(s),imap'config default        option proto 'tcp'        option portrange '1024-65535'config classgroup 'CcClassGroup'        option classes 'Cc Priority Express Mormal Bulk'        option default 'Cc'config class 'Cc'        option packetsize '1600'        option packetdelay '160'        option avgrate '16'        option priority '6'"
  },
  
  {
    "title": "Git Base",
    "url": "/posts/git-base/",
    "categories": "Dev, Utils",
    "tags": "Dev, DevTools, Git",
    "date": "2020-04-18 14:33:04 +0800",
    





    
    "snippet": "Git defaultGit 全局设置:  git config –global user.name “Cc”  git config –global user.email “li_chao_cheng@163.com”创建 git 仓库:  mkdir client_user_server  cd client_user_server  git init  touch README.md ...",
    "content": "Git defaultGit 全局设置:  git config –global user.name “Cc”  git config –global user.email “li_chao_cheng@163.com”创建 git 仓库:  mkdir client_user_server  cd client_user_server  git init  touch README.md  git add README.md  git commit -m “first commit”  git remote add origin https://gitee.com/Cc/Cc.git  git push -u origin master已有仓库?  cd existing_git_repo  git remote add origin https://gitee.com/Cc/Cc.git  git push -u origin masterSSH 管理本地Code  通过命令 ssh-keygen 生成 SSH Key          t key 类型      C 注释      $ ssh-keygen -t rsa -C \"li_chao_cheng@163.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/admin/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/admin/.ssh/id_rsa.Your public key has been saved in /c/Users/admin/.ssh/id_rsa.pub.The key fingerprint is:SHA256:qbiJsDmN4w1ZiJuH1nWNkMeXdaYrsFnYJ91dFAjDr0k li_chao_cheng@163.comThe key's randomart image is:+---[RSA 2048]----+|          .+.o.o+||      o o +.*.. .||     o = * +.. . ||. .   o O.oE..   ||.. . . =So..o    || ++ ....  .o     ||=*... .          ||==+. o           ||++..o            |+----[SHA256]-----+Cc@DESKTOP-3Q5O26A MINGW64 /d/go/gopath/src/lichaocheng/yun_mao (master)  查看生成的 SSH 公钥和私钥：          私钥文件 id_rsa公钥文件 id_rsa.pub      ls ~/.ssh/  查看cat ~/.ssh/id_rsa.pub      复制到Git控制台        测试  ssh -T git@github.com拉取仓库代码clone  clone default branch          git clone https://github.com/golang/go.git      git clone git@github.com:golang/go.git        指定分支          branch_name ：是你要克隆的分支的名称      remote_repository_url ：是远程仓库的 URL      git clone -b my-branch https://github.com/your-username/your-repo.git      pull  git pull origin master提交代码添加文件到暂存区  指定文件：git add file_name  当前目录所有：git add .  模糊：git add *.go  指定目录：git add src/  交互模式：git add -icommit  git commit -m “commit info”  git commit -m “标题” -m “正文”push  git push  git push origin master  git push git@github.com:golang/go.git master状态查询  git status  更详细：git status -v  其他分支差异：git status -b  查看未跟踪的文件：git status -u  查看更改预览：git status -s  查看分支状态：git status -sb日志  git log  以简洁的方式显示每个提交的一行摘要信息：git log –oneline  在输出中显示提交历史的图形化表示，用于展示分支和合并情况：git log –graph  按作者筛选提交：git log –author=”Cc”  按日期范围筛选提交：git log –since=”2023-01-01” –until=”2023-04-30”  特定文件的提交历史：git log – file_name  查看某个分支或标签的提交历史          git log branch_name      git log tag_name        查看合并提交的历史：git log –merges  查看非合并提交的历史：git log –no-merges  显示某个提交的详细信息：git log commit_hash对比  git diff [commit1] [commit2] – [file]  比较暂存区与最新提交之间的差异：git diff –staged  比较两个不同提交之间的差异：git diff commit1 commit2  比较特定文件的修改：git diff file_name  比较两个提交之间某个文件的修改：git diff commit1 commit2 – file_name  比较某个分支或标签与当前分支之间的差异：git diff branch_or_tag  查看以缓存的改的：git diff –cached [file]  查看缓存状态摘要,默认全部 file 可以指定文件：git diff –stat [file]撤回  git status  git log  git reset –hard [hash]  强制删除丢弃保存修改：git reset –hard  撤销最近一次提交，但保留更改：git reset –soft HEAD^  取消最近一次提交并取消暂存的内容：git reset –mixed HEAD^  彻底删除最近一次提交及其更改（慎用）：git reset –hard HEAD^  将分支引用移动到特定的提交：git reset commit_hash  取消暂存，但保留工作目录的修改：git reset分支  列出远程所有分支：git branch -r  列出所有分支：git branch -a  创建新分支：git branch new_feature  切换到新分支：git checkout new_feature  创建并切换到新分支：git checkout -b hotfix_bug  删除已合并的分支：git branch -d branch_name  强制删除未合并的分支：git branch -D feature_in_progress  重命名分支：git branch -m old_name new_name  删除远程分支          git push origin –delete [branch-name]      git branch -dr [remote/branch]        tag            "
  },
  
  {
    "title": "Git Open Other",
    "url": "/posts/Git-Ope-Other/",
    "categories": "Dev, Utils",
    "tags": "Dev, DevTools, Git",
    "date": "2020-04-18 14:33:04 +0800",
    





    
    "snippet": "冷门操作查看 commit 总数git log --oneline | wc -l查看所有提交人和提交次数git shortlog --numbered --summary指定用户提交代码情况git log --author=\"Cc\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } EN...",
    "content": "冷门操作查看 commit 总数git log --oneline | wc -l查看所有提交人和提交次数git shortlog --numbered --summary指定用户提交代码情况git log --author=\"Cc\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"增加的行: %s,删除线: %s, 总行: %s\\n\", add, subs, loc }' -added lines: 13688, removed lines: 685, total lines: 13003统计每个人提交次数git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"增加的行: %s,删除线: %s, 总行: %s\\n\", add, subs, loc }' -; doneCc      added lines: 13688, removed lines: 685, total lines: 13003Hyper-Li        added lines: 1, removed lines: 1, total lines: 0统计某人提交代码次数git log --author=\"Cc\" --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加的行数:%s 删除的行数:%s 总行数: %s\\n\",add,subs,loc }'统计某人提交代码次数加晒元条件git log --author=\"Cc\" --since='2020-07-01' --until='2020-08-01' --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加的行数:%s 删除的行数:%s 总行数: %s\\n\",add,subs,loc }'统计每个人增删行数git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \"增加的行数:%s 删除的行数:%s 总行数: %s\\n\",add,subs,loc }' -; done版本控制Alpha：是内部测试版,一般不向外部发布,会有很多 Bug.一般只有测试人员使用。Beta：也是测试版，这个阶段的版本会一直加入新的功能。在 Alpha 版之后推出。RC：(Release 　 Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC 版不会再加入新的功能了，主要着重于除错。GA :General Availability,正式发布的版本，在国外都是用 GA 来说明 release 版本的。RTM：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过 RTM 版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。OEM：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面 CD 和说明书(授权书)。RVL：号称是正式版，其实 RVL 根本不是版本的名称。它是中文版/英文版文档破解出来的。EVAL：而流通在网络上的 EVAL 版，与“评估版”类似，功能上和零售版没有区别。RTL：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的 i386 文件夹里有一个 eula.txt，最后有一行 EULAID，就是你的版本。比如简体中文正式版是 EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是 WX.4_PRO_RTL_TW。其中：如果是 WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。"
  },
  
  {
    "title": "Git Base Other",
    "url": "/posts/Git-Op/",
    "categories": "Dev, Utils",
    "tags": "Dev, DevTools, Git",
    "date": "2020-04-18 14:33:04 +0800",
    





    
    "snippet": "Git 常用命令仓库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]配置# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的...",
    "content": "Git 常用命令仓库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]配置# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name \"[name]\"$ git config [--global] user.email \"[email address]\"增加/删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat \"@{0 day ago}\"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all# 撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop其他# 生成一个可供发布的压缩包$ git archive"
  },
  
  {
    "title": "Git Error ",
    "url": "/posts/Git-Error/",
    "categories": "Dev, Utils",
    "tags": "Dev, DevTools, Git",
    "date": "2020-04-18 14:33:04 +0800",
    





    
    "snippet": "Failed to connect to 127.0.0.1 port 1080: Connection refused- 尝试了各种办法都没有解决，一直报这个端口代理的问题，看到网上有一个解决办法- 我个人是方法一解决了方法一  第一步 (查询是否使用了代理) git config –global http.proxy  第二步(取消代理) git config –global –unse...",
    "content": "Failed to connect to 127.0.0.1 port 1080: Connection refused- 尝试了各种办法都没有解决，一直报这个端口代理的问题，看到网上有一个解决办法- 我个人是方法一解决了方法一  第一步 (查询是否使用了代理) git config –global http.proxy  第二步(取消代理) git config –global –unset http.proxy方法二  第一步在终端输入 defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 这行命令可以显示电脑的隐形文件  第二步 在 Finder 里面个人账号的文件夹里找到 gitconfig 这个隐藏文件，右击打开，然后把里面的代理 proxy 整行删掉  第三步 回到终端，再次执行 pod setup，这个时候你就会神奇的发现，问题解决了，希望对同样有这种问题的人有所帮助出现目录一直是跳过  git config –global –get core.excludesFile  修改即可 /Users/cc/.gitignore_global推送失败（为重新拉去）To http://192.168.1.18:3001/smtface/distinguish_server.git! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'http://192.168.1.18:3001/smtface/distinguish_server.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.访问http://192.168.1.18:3001/smtface/distinguish_server.git啊！[拒绝]主-&gt;主（首先获取）错误：无法将某些引用推送到“http://192.168.1.18:3001/smtface/distinguish_server.git”提示：更新被拒绝，因为远程包含您所做的工作注意：本地没有。这通常是由另一个存储库推送引起的提示：到同一个 ref。您可能希望首先集成远程更改提示：（例如，git pull…’）然后再推。提示：有关详细信息，请参阅“git push--help”中的“关于快速转发的说明”。  推送失败是代码没有拉去最新的 更远程仓库不一致 最保险的是把你写的代码备份一份          方法 1                  先拉去远程仓库最新代码          把备份的代码覆盖再执行提交的所有操作                    方法 2 (觉得没有修改什么代码，建议使用)                  强制推送到某个分支          pit push -u origin master -f                    方法 3 (不建议)                  创建一个分支          推送到型创建的分支          仓库管理员解决代码冲突问题          你再次拉取代码                    推送失败（去历史提交记录）1. 创建全新的孤立分支 latest_branchgit checkout –orphan latest_branch2. 暂存所有文件git add -A3. 提交所有文件的修改到 latest_branchgit commit -am “del all history”4. 删除原来的 master 分支git branch -D master5. 修改 latest_branch 分支名为 mastergit branch -m master6. 强制更新远程服务器的 master 分支, 至此清空 git 所有历史git push -f origin master遇到的问题如下remote: Gogs: Branch 'master' is protected from force pushTo http://192.168.1.18:3001/smtface/api_server.git ! [remote rejected] master -&gt; master (pre-receive hook declined)error: failed to push some refs to 'http://192.168.1.18:3001/smtface/api_server.git'遥控器：护目镜：分支“主”受力推送保护发送至http://192.168.1.18:3001/smtface/api_server.git啊！[远程拒绝]主-&gt;主（预接收挂钩被拒绝）错误：无法将某些引用推送到“http://192.168.1.18:3001/smtface/api_server.git”直接复制git checkout --orphan latest_branchgit add -Agit commit -am \"del all history\"git branch -D mastergit branch -m mastergit push -f origin masterGit 储存损坏git 提交出现故障  git commit  git fsck –full                              git log –oneline –decorate –all          head -n 8                      rm -f .git/objects/43/46883490a0990e68db0187241abc1642765a73Error 添加git submodule add root@git.lichaocheng.top:Cc360428/kratos_demo_api.git api'api' already exists in the indexgit rm -r –cached apigit submodule add –force https://git.huoys.com/im/im_square_api.git apigit submodule syncgit restore -s HEAD .gitmodulesgit submodoule update"
  },
  
  {
    "title": "MySQL forgot password",
    "url": "/posts/mysql-passwrod/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2020-04-18 12:21:48 +0800",
    





    
    "snippet": "MySQL 忘记密码  注：vim 修改文件 i 保存退出 :wq ， 不修改退出 :q!关闭服务[root@Cc ~]# ps -ef |grep mysqlroot      3658  8508  0 12:47 pts/1    00:00:00 grep --color=auto mysqlmysql    20039     1  0 12:39 ?        00:00:0...",
    "content": "MySQL 忘记密码  注：vim 修改文件 i 保存退出 :wq ， 不修改退出 :q!关闭服务[root@Cc ~]# ps -ef |grep mysqlroot      3658  8508  0 12:47 pts/1    00:00:00 grep --color=auto mysqlmysql    20039     1  0 12:39 ?        00:00:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid[root@Cc ~]# service mysqld stopRedirecting to /bin/systemctl stop mysqld.service[root@Cc ~]#修改配置文件  在配置文件中添加 skip-grant-tables[root@Cc ~]# vim /etc/my.cnf.....# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockskip-grant-tables[client]default-character-set=utf8...:wq重启服务[root@Cc ~]# service mysqld startRedirecting to /bin/systemctl start mysqld.service[root@Cc ~]#进入 mysql  输入 mysql -u root -p 直接 Enter、Enter[root@Cc ~]# mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.29 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update mysql.user set authentication_string=password('password') where user='root';Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 1mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye进入数据库 修改表update mysql.user set authentication_string=password('这里是填写mysql密码') where user='root';删除修改的配置文件  skip-grant-tables[root@Cc ~]# vim /etc/my.cnf...# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock#skip-grant-tables[client]default-character-set=utf8...:wq重启 mysqld 服务[root@Cc ~]# service mysqld restart出现错误确认问题  重启服务还是没有用  确认过 update 语句也执行过了（检查 执行 sql语句看下执行结果，影响行数）  确认输入的 mysql -u root -p 之后输入的密码是否是自己 update的密码查看 user表  下面默认值是 N 使用 update 语句设置为 Y ，个人使用 navicat 工具改的，是把密码去掉然后再用给你工具改mysql&gt; select * from user where user =\"root\"\\G;*************************** 1. row ***************************                  Host: localhost                  User: root           Select_priv: Y           Insert_priv: Y           Update_priv: Y           Delete_priv: Y           Create_priv: Y             Drop_priv: Y           Reload_priv: Y         Shutdown_priv: Y          Process_priv: Y             File_priv: Y            Grant_priv: Y       References_priv: Y            Index_priv: Y            Alter_priv: Y          Show_db_priv: Y            Super_priv: Y Create_tmp_table_priv: Y      Lock_tables_priv: Y          Execute_priv: Y       Repl_slave_priv: Y      Repl_client_priv: Y      Create_view_priv: Y        Show_view_priv: Y   Create_routine_priv: Y    Alter_routine_priv: Y      Create_user_priv: Y            Event_priv: Y          Trigger_priv: YCreate_tablespace_priv: Y              ssl_type:            ssl_cipher:           x509_issuer:          x509_subject:         max_questions: 0           max_updates: 0       max_connections: 0  max_user_connections: 0                plugin: mysql_native_password authentication_string: *A021A79F3EE5D774BF4197B804D3FDAAE6511167      password_expired: N password_last_changed: 2020-04-18 13:15:34     password_lifetime: NULL        account_locked: N1 row in set (0.00 sec)ERROR:No query specifiedmysql&gt;修改成功[root@Cc filebrowser]# mysql -u root -pEnter password:Welcome to the MySQL monitor.  Commands end with ; or \\g.Your MySQL connection id is 105Server version: 5.7.29 MySQL Community Server (GPL)Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt;登陆成功  也可以使用其他方式更改密码"
  },
  
  {
    "title": "MySqlErrorAll",
    "url": "/posts/mysql-error-all/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2020-04-18 12:21:48 +0800",
    





    
    "snippet": "连接失败  2059 - Authentication plugin 'caching_sha2_password' cannot be loaded: dlopen(../Frameworks/caching_sha2_password.so, 2): image not found      mysql -uroot -ppassword #登录        use mysql; #选...",
    "content": "连接失败  2059 - Authentication plugin 'caching_sha2_password' cannot be loaded: dlopen(../Frameworks/caching_sha2_password.so, 2): image not found      mysql -uroot -ppassword #登录        use mysql; #选择数据库        远程连接请将'localhost'换成'%'      sqlALTER USER 'root'@'localhost' IDENTIFIED BY 'lichaocheng' PASSWORD EXPIRE NEVER; #更改加密方式  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'lichaocheng'; #更新用户密码  FLUSH PRIVILEGES; #刷新权限            ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';  "
  },
  
  {
    "title": "MySQL Version diff",
    "url": "/posts/Mysql-Version-info/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2020-04-18 12:21:48 +0800",
    





    
    "snippet": "5.6  InnoDb 开始支持全文索引  InnoDb 支持设置页面大小  通过 innodb_page_size 指定，默认是 16KB，对于工作负载和存储设备（尤其是具有小块大小的 SSD 设备）的某些组合，较小的页面大小可以帮助避免冗余或低效的 I / O  InnoDB redolog 总大小的限制从之前的 4G 扩展至 512G  InnoDB 现在可以限制大量表打开的时候内存占...",
    "content": "5.6  InnoDb 开始支持全文索引  InnoDb 支持设置页面大小  通过 innodb_page_size 指定，默认是 16KB，对于工作负载和存储设备（尤其是具有小块大小的 SSD 设备）的某些组合，较小的页面大小可以帮助避免冗余或低效的 I / O  InnoDB redolog 总大小的限制从之前的 4G 扩展至 512G  InnoDB 现在可以限制大量表打开的时候内存占用过多的问题(比如这里提到的)(第三方已有补丁)  InnoDB 性能加强。如分拆 kernel mutex;flush 操作从主线程分离;多个 perge 线程;大内存优化等  InnoDB 死锁信息可以记录到 error 日志，方便分析  优化器性能提升，引入了 ICP，MRR，BKA 等特性，针对子查询进行了优化  Undo Log 可保存在独立表空间中，因其是随机 IO，更适合放到 SSD 中。但仍然不支持空间的自动回收  支持 Online DDL。ALTER 操作不再阻塞 DML  MySQL 现在支持延迟复制，以便从属服务器故意落后于主服务器至少指定的时间量。默认延迟为 0 秒  之前，TIMESTAMP 每个表最多可以自动将一列初始化或更新为当前日期和时间，目前已没有该限制5.7  支持组复制和 InnoDB Cluster  支持多源复制  支持在线修改 Buffer pool 的大小  支持 UNDO 表空间的自动回收  查询优化器的增强与重构，提升性能  可查看当前 session 正在执行的 SQL 的执行计划(EXPLAIN FOR CONNECTION)  优化了 Performance Schema，其内存使用减少  原生支持 JSON 类型，并引入了众多 JSON 函数  可设置 SELECT 操作的超时时长（max_execution_time）  引入了 innodb_deadlock_detect 选项，在高并发场景下，可使用该选项来关闭死锁检测  GIS 的增强，包括使用 Boost.Geometry 替代之前的 GIS 算法，InnoDB 开始支持空间索引8.0  提高性能：官宣比 5.7 快 2 倍  PERFORMANCE_SCHEMA 查询性能提升，其已内置多个索引  支持不可见索引(Invisible index)  支持降序索引  引入了 innodbdedicated_server 选项，可基于服务器的内存来动态设置 innodb_buffer_pool_size，innodb_log_file- size 和 innodb_flush_method  支持秒加字段(Instant add column)功能  JSON 字段的部分更新（JSON Partial Updates）  支持自增主键的持久化  默认字符集由 latin1 修改为 utf8mb4  默认开启 UNDO 表空间，且支持在线调整数量（innodb_undo_tablespaces）。在 MySQL - 5.7 中，默认不开启，若要开启，只能初始化时设置  Redo Log 的优化，包括允许多个用户线程并发写入 log buffer，可动态修改 innodb_log_buffer_size 的大小  默认的内存临时表由 MEMORY 引擎更改为 TempTable 引擎，相比于前者，后者支持以变长方式存储 VARCHAR，VARBINARY 等- 变长字段。从 MySQL 8.0.13 开始，TempTable 引擎支持 BLOB 字段  SELECT … FOR SHARE 和 SELECT … FOR UPDATE 语句中引入 NOWAIT 和 SKIP LOCKED 选项，解决电商场景热点行问题  正则表达式的增强，新增了 4 个相关函数，REGEXP_INSTR()，REGEXP_LIKE()，REGEXP_REPLACE()，REGEXP_SUBSTR()  查询优化器在制定执行计划时，会考虑数据是否在 Buffer Pool 中。而在此之前，是假设数据都在磁盘中  GROUP BY 语句不再隐式排序  增加了对于客户端报错信息的统计（performance_schema.events_errors_summary_xxx）  BLOB, TEXT, GEOMETRY 和 JSON 字段允许设置默认值"
  },
  
  {
    "title": "linux(CentOS7) 网络管理",
    "url": "/posts/9-RedHad-system-ps/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-29 00:49:12 +0800",
    





    
    "snippet": "系统启动控制、进程管理系统启动控制  0—-停机  1—单用户模式  2—多用户模式（没有网络文件系统）  3—完全多用户模式  4—忽略  5—X11 一般图形界面  6— 重新启动（不推荐这操作，请谨慎操作）  如果你远程黑进了系统 可以试试这个 6 操作 应该会一直重启设置操作  runleve 查看当前系统启动状态，N 代表代表上次运行级别  init 设置启动状态[root@Cc ...",
    "content": "系统启动控制、进程管理系统启动控制  0—-停机  1—单用户模式  2—多用户模式（没有网络文件系统）  3—完全多用户模式  4—忽略  5—X11 一般图形界面  6— 重新启动（不推荐这操作，请谨慎操作）  如果你远程黑进了系统 可以试试这个 6 操作 应该会一直重启设置操作  runleve 查看当前系统启动状态，N 代表代表上次运行级别  init 设置启动状态[root@Cc RedHad]# runlevelN 3[root@Cc RedHad]# init 5Linux 初始化脚本 /etc/inittab 的解析Linux 启动服务控制  start 开启  ` stop` 停止[root@Cc RedHad]# /etc/init.d/network startStarting network (via systemctl):                          [  确定  ][root@Cc RedHad]# /etc/init.d/network stop使用chkconfig 查看各个服务运行级别情况  查看[root@Cc RedHad]# chkconfig --list注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。      要列出 systemd 服务，请执行 'systemctl list-unit-files'。      查看在具体 target 启用的服务请执行      'systemctl list-dependencies [target]'。aegis           0:关    1:关    2:开    3:开    4:开    5:开    6:关cloudmonitor    0:关    1:关    2:开    3:开    4:开    5:开    6:关netconsole      0:关    1:关    2:关    3:关    4:关    5:关    6:关network         0:关    1:关    2:开    3:开    4:开    5:开    6:关[root@Cc RedHad]#  设置[root@Cc ~]# chkconfig --list networknetwork        \t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:off[root@Cc ~]# chkconfig --level 6 network on[root@Cc ~]# chkconfig --list networknetwork        \t0:off\t1:off\t2:on\t3:on\t4:on\t5:on\t6:on[root@Cc ~]#  添加  chkconfig ---add [服务名]  service [服务名] start 开始  service [服务名] stop 停止  service [服务名] restart 重启进程管理概述      分类          交互进程      批处理进程      守护进程            父进程和子进程          两者管理关系和被管理关系，父进程终止时子进程也随之终止。但是子进程终止父进程不会因子进程终止而终止。      进程管理工具、常用命令进程监视ps    ps -u\t\t按用户名启动时间顺序监视    ps -a\t\t显示所用用户进程    ps -x\t\t显示无控制终端进程    ps -l\t\t长格式输出    ps -j\t\t任务格式显示    ps -r\t\t显示运行中进程    ps -f\t\t列出全部进程相关信息系统状态监视top    top -n 1\t\t\t显示一次退出    top -n 1 -p  1\t\t显示某一进程状态且显示一次退出    top -u testUser\t\t显示指定用户进程信息终止进程下载web程序  windows 体验  Linux 运行：示例  kill [进程 ID]  进程号终止进程[root@Cc ~]# ps -ef  |grep HelloWorldroot     18233 10980  0 21:38 pts/1    00:00:00 ./HelloWorldroot     21817 17944  0 21:40 pts/4    00:00:00 grep --color=auto HelloWorld[root@Cc ~]# kill -9 18233[root@Cc ~]# ps -ef  |grep HelloWorldroot     23420 17944  0 21:41 pts/4    00:00:00 grep --color=auto HelloWorld[root@Cc ~]#  killall [进程 ID]  终止一批进程[root@Cc ~]# killall -9 HelloWorld系统管理员常见操作更改sshd 默认端口[root@Cc src]# vim /etc/ssh/sshd_config# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER#Port 22Port 23456#ListenAddress 0.0.0.0#ListenAddress ::# 建议保留 22# 防火墙需要放行 设置端口[root@Cc RedHad]# semanage port -l|grep sshssh_port_t                     tcp      22[root@Cc RedHad]# semanage port -a -t ssh_port_t -p tcp 23456[root@Cc RedHad]# semanage port -l|grep sshssh_port_t                     tcp      23456, 22[root@Cc RedHad]# netstat -ntlp |grep sshdtcp        0      0 0.0.0.0:23456           0.0.0.0:*    LISTEN      18631/sshdtcp        0      0 0.0.0.0:22              0.0.0.0:*    LISTEN      18631/sshd[root@Cc RedHad]#  通过另个服务器远程修改过端口的服务器[root@Lgr init.d]# ssh -p 23456 root@lichaocheng.toproot@lichaocheng.top's password:Last login: Sat Mar 28 21:38:24 2020 from 113.118.200.16Welcome to Alibaba Cloud Elastic Compute Service ![root@Cc ~]#查看某个用户所有进程[root@Cc RedHad]# ps -ef |grep userTestroot     32651 10980  0 23:07 pts/1    00:00:00 grep --color=auto userTest[root@Cc RedHad]#终止某个用户所有进程testUser:x:1004:10002::/home/testUser:/bin/bash[root@Cc ~]# killall -u testUser[root@Cc ~]#根据端口查对应的进程[root@Cc ~]# yum install -y lsof# 在联网的情况下可以直接使用以上命令# 如果没有联网使用 rpm 或者源码安装[root@Cc ~]# lsof -i:8180COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEserver  2155 root    6u  IPv6  40398      0t0  TCP *:8180 (LISTEN)[root@Cc ~]#通过以上知识可以做进程监控（shell）  可能会用到 rsync 命令 安装即可#!/bin/bash## 进程监控"
  },
  
  {
    "title": "linux(CentOS7) 网络管理",
    "url": "/posts/10-RedHad-network/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-29 00:49:12 +0800",
    





    
    "snippet": "网络基础知识以及网络管理内容网络管理协议  好多概念知识，会拿出时间来讲解这张预留的空白TCP/IP 协议概述  好多概念知识，会拿出时间来讲解这张预留的空白OSI 参考模型  好多概念知识，会拿出时间来讲解这张预留的空白包（packet）  好多概念知识，会拿出时间来讲解这张预留的空白网络字节顺序  好多概念知识，会拿出时间来讲解这张预留的空白地址解析协议（ARP）  好多概念知识，会拿出...",
    "content": "网络基础知识以及网络管理内容网络管理协议  好多概念知识，会拿出时间来讲解这张预留的空白TCP/IP 协议概述  好多概念知识，会拿出时间来讲解这张预留的空白OSI 参考模型  好多概念知识，会拿出时间来讲解这张预留的空白包（packet）  好多概念知识，会拿出时间来讲解这张预留的空白网络字节顺序  好多概念知识，会拿出时间来讲解这张预留的空白地址解析协议（ARP）  好多概念知识，会拿出时间来讲解这张预留的空白UTP 与 ICMP 协议简介  好多概念知识，会拿出时间来讲解这张预留的空白网络管理命令ping  测试是否通[root@Cc ~]# ping lichaocheng.topPING lichaocheng.top (60.205.176.110) 56(84) bytes of data.64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=1 ttl=64 time=0.621 ms64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=2 ttl=64 time=0.671 ms64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=3 ttl=64 time=0.659 ms--- lichaocheng.top ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2001msrtt min/avg/max/mdev = 0.621/0.650/0.671/0.029 ms[root@Cc ~]#  ping 指定次数[root@Cc ~]# ping -c 2 lichaocheng.topPING lichaocheng.top (60.205.176.110) 56(84) bytes of data.64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=1 ttl=64 time=0.636 ms64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=2 ttl=64 time=0.659 ms--- lichaocheng.top ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1000msrtt min/avg/max/mdev = 0.636/0.647/0.659/0.027 ms[root@Cc ~]#  指定时间间隔次数限制[root@Cc ~]# ping -c 2 -i 0.01 lichaocheng.topPING lichaocheng.top (60.205.176.110) 56(84) bytes of data.64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=1 ttl=64 time=0.771 ms64 bytes from 60.205.176.110 (60.205.176.110): icmp_seq=2 ttl=64 time=0.647 ms--- lichaocheng.top ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 10msrtt min/avg/max/mdev = 0.647/0.709/0.771/0.062 ms[root@Cc ~]#配置网络显示网络状态【ifconfig】  查看          第二行依次                  网卡 IP（云服务应该是内网 IP）          子网掩码          广播地址                    [root@Cc ~]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.24.40.83  netmask 255.255.192.0  broadcast 172.24.63.255        ether 00:16:3e:0c:d1:d9  txqueuelen 1000  (Ethernet)        RX packets 4270799  bytes 923464936 (880.6 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 4640135  bytes 1228322385 (1.1 GiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Cc ~]#  模拟添加一个网卡[root@Cc network-scripts]# cd /etc/sysconfig/network-scripts/[root@Cc network-scripts]# cp ifcfg-eth0 ifcfg-eth1[root@Cc network-scripts]# vim ifcfg-eth1[root@Cc network-scripts]# vim ifcfg-eth1[root@Cc network-scripts]# cat ifcfg-eth1# 网卡名字DEVICE=eth1LccTest# ip地址IPADDR=192.168.1.199# 子网掩码NETMASK=255.255.255.0# 开机自启ONBOOT=yes# 网关地址GATEWAY=172.24.63.253[root@Cc network-scripts]#  最后systemctl restart network 和service network restart 失败 ，报了文件错误，那直接修改主网卡 eth0  修改（需谨慎，高能操作修改前请先系统快照）  执行完成后直接退出 sshd 远程 ，最后 up 是开启的意思[root@Cc network-scripts]# ifconfig eth0 172.24.40.88 netmask 255.255.192.0 up连接断开  翻车 阿里云连接也失败找不到 ,只能快照或者联系阿里云技术服务,ping 服务器 超时，重启服务器  最后还是没有修改成功，反而立马远程不了          失败原因可能是我模拟添加网卡造成失败      可能改了网卡地址，在阿里云我公网ip对应不到修改阿里云内网ip      重启服务器之后，需要密钥才能登录，可能触发阿里云安全防控机制，阿里做了系统配置，我实例id 与 hostname，充值了网卡 其余的没有找到      然之 需要密钥，我的做法是修改了密码，重启，之后远程登陆      谨慎操作修改网卡地址      可能修改成功了，也有可能是模拟网卡配置导致错误      [root@iz2zeb00z6vr5gix5utl11z lichaocheng.top.server]# ifconfig  eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.24.40.83  netmask 255.255.192.0  broadcast 172.24.63.255        ether 00:16:3e:0c:d1:d9  txqueuelen 1000  (Ethernet)        RX packets 5310  bytes 575889 (562.3 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 6178  bytes 1043414 (1018.9 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@iz2zeb00z6vr5gix5utl11z lichaocheng.top.server]#  我修改另一个网卡[root@Cc ~]# ifconfig dockerdocker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0        ether 02:42:5f:3a:85:e0  txqueuelen 0  (Ethernet)        RX packets 34  bytes 2663 (2.6 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 15  bytes 7621 (7.4 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Cc ~]# ifconfig docker0 172.24.40.88 netmask 255.255.192.0 up[root@Cc ~]# ifconfig dockerdocker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.24.40.88  netmask 255.255.192.0  broadcast 172.24.63.255        ether 02:42:5f:3a:85:e0  txqueuelen 0  (Ethernet)        RX packets 34  bytes 2663 (2.6 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 15  bytes 7621 (7.4 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Cc ~]# ifconfig docker0 hw ether 02:30:30:3f:5f:3a[root@Cc ~]# ifconfig dockerdocker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.24.40.88  netmask 255.255.192.0  broadcast 172.24.63.255        ether 02:30:30:3f:5f:3a  txqueuelen 0  (Ethernet)        RX packets 34  bytes 2663 (2.6 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 15  bytes 7621 (7.4 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Cc ~]#  禁用与启用[root@Cc ~]# ifconfig docker0 down[root@Cc ~]# ifconfig docker0 up路由表显示与修改【route】  route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway][metric Metric]] [if Interface]]参数说明  Command 指定您想运行的命令 (Add/Change/Delete/Print)  Destination 指定该路由的网络目标  mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）  Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址  metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用  if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进-c 显示更多信息-n 不解析名字-v 显示详细的处理信息-F 显示发送信息-C 显示路由缓存-f 清除所有网关入口的路由表。-p 与add 命令一起使用时使路由具有永久性。add：添加一条新路由。del：删除一条路由。-net：目标地址是一个网络。-host：目标地址是一个主机。netmask：当添加一个网络路由时，需要使用网络掩码。gw：路由数据包通过网关。注意，你指定的网关必须能够达到。metric：设置路由跳数。显示示例[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0[root@Cc ~]#添加路由  注：如果服务器添加时 添加路由可以看到但是ping不通  主机号 155.28.138.45[root@Lgr ~]# curl ip.sb115.28.138.45[root@Lgr ~]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.31.220.39  netmask 255.255.240.0  broadcast 172.31.223.255        ether 00:16:3e:08:80:34  txqueuelen 1000  (Ethernet)        RX packets 4840062  bytes 2017732415 (1.8 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 4449497  bytes 952525473 (908.3 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Lgr ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.31.223.253  0.0.0.0         UG    0      0        0 eth010.200.192.0    0.0.0.0         255.255.240.0   U     0      0        0 mpgre0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.31.208.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0[root@Lgr ~]# route add -net 172.24.0.0 netmask 255.255.192.0 gw 172.31.223.225[root@Lgr ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.31.223.253  0.0.0.0         UG    0      0        0 eth010.200.192.0    0.0.0.0         255.255.240.0   U     0      0        0 mpgre0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.24.0.0      172.31.223.225  255.255.192.0   UG    0      0        0 eth0172.31.208.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0[root@Lgr ~]# route add -net 172.24.0.0 netmask 255.255.192.0 dev eth0[root@Lgr ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.31.223.253  0.0.0.0         UG    0      0        0 eth010.200.192.0    0.0.0.0         255.255.240.0   U     0      0        0 mpgre0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.31.208.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0[root@Lgr ~]# ping 172.24.40.83PING 172.24.40.83 (172.24.40.83) 56(84) bytes of data.From 172.31.220.39 icmp_seq=1 Destination Host UnreachableFrom 172.31.220.39 icmp_seq=2 Destination Host UnreachableFrom 172.31.220.39 icmp_seq=3 Destination Host UnreachableFrom 172.31.220.39 icmp_seq=4 Destination Host Unreachable^C--- 172.24.40.83 ping statistics ---5 packets transmitted, 0 received, +4 errors, 100% packet loss, time 4000mspipe 4[root@Lgr ~]## 可能是哪里配错了  主机号 60.205.176.110[root@Cc ~]# curl ip.sb60.205.176.110[root@Cc ~]# ifconfig eth0eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.24.40.83  netmask 255.255.192.0  broadcast 172.24.63.255        ether 00:16:3e:0c:d1:d9  txqueuelen 1000  (Ethernet)        RX packets 158625  bytes 26310297 (25.0 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 161713  bytes 44000608 (41.9 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0[root@Cc ~]# route add -net 172.31.208.0  netmask 255.255.240.0 gw 172.24.63.225[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.31.208.0    172.24.63.225   255.255.240.0   UG    0      0        0 docker0[root@Cc ~]# route add -net 172.31.208.0  netmask 255.255.240.0 dev eth0[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.31.208.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0[root@Cc ~]# ping 172.31.220.39PING 172.31.220.39 (172.31.220.39) 56(84) bytes of data.From 172.24.40.83 icmp_seq=1 Destination Host UnreachableFrom 172.24.40.83 icmp_seq=2 Destination Host UnreachableFrom 172.24.40.83 icmp_seq=3 Destination Host UnreachableFrom 172.24.40.83 icmp_seq=4 Destination Host Unreachable^C--- 172.31.220.39 ping statistics ---5 packets transmitted, 0 received, +4 errors, 100% packet loss, time 4000mspipe 4[root@Cc ~]## 可能是哪里配错了  两台服务器内网互通  两台服务器还是没有互通，可能要去响应云厂商，控制台添加，重启网卡服务service network restarty 还是没有删除路由  注： 删除时不需要网关[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0172.31.208.0    172.24.40.83    255.255.240.0   UG    0      0        0 eth0[root@Cc ~]# route del -net 172.31.208.0 netmask 255.255.240.0[root@Cc ~]# route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         172.24.63.253   0.0.0.0         UG    0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U     0      0        0 docker0[root@Cc ~]#[root@Lgr ~]# route del -net 172.24.0.0 netmask 255.255.192.0屏蔽路由[root@Lgr ~]# route add -net 10.10.10.128 netmask 255.255.255.128 reject添加默认网关[root@Cc ~]# route del default gw 192.168.40.2添加某个 ip 路由[root@Cc ~]# route add -host 192.168.40.1dev eth0复制文件至其他系统【scp】[root@Cc ~]# scpusage: scp [-12346BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]           [-l limit] [-o ssh_option] [-P port] [-S program]           [[user@]host1:]file1 ... [[user@]host2:]file2[root@Cc ~]#示例  Cc 主机[root@Cc 10]# curl ip.sb;pwd60.205.176.110/root/RedHad/10[root@Cc 10]#  Lgr 主机[root@Lgr 10]# curl ip.sb;pwd115.28.138.45/root/RedHad/10[root@Lgr 10]#  在 Cc 主机创建和文件夹和查看 Lgr 主机状态[root@Cc 10]# curl ip.sb;pwd;tree60.205.176.110/root/RedHad/10.├── scp│   └── scpInTst.txt└── scp.txt1 directory, 2 files[root@Cc 10]#[root@Lgr 10]# curl ip.sb;pwd;tree115.28.138.45/root/RedHad/10-bash: tree: command not found[root@Lgr 10]#  Cc 复制到 Lgr【文件】[root@Cc 10]# rm -r /root/.ssh/known_hostsrm: remove regular file ‘/root/.ssh/known_hosts’? y[root@Cc 10]# scp scp.txt root@115.28.138.45:/root/RedHad/10The authenticity of host '115.28.138.45 (115.28.138.45)' can't be established.ECDSA key fingerprint is SHA256:3yMka431yjt0thBqIeSCWPCfsy46wknMMJrO8QQe4cw.ECDSA key fingerprint is MD5:30:23:91:24:0a:ca:b3:3c:d8:ec:a0:fe:cd:b5:43:0d.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '115.28.138.45' (ECDSA) to the list of known hosts.root@115.28.138.45's password:scp.txt                                                    100%    0     0.0KB/s   00:00[root@Cc 10]#[root@Lgr 10]# lltotal 0-rw-r--r-- 1 root root 0 Mar 29 13:46 scp.txt[root@Lgr 10]#  其他的就不操作了，看下面叫要说明scp root@107.172.27.254:/home/test.txt .   //下载文件scp test.txt root@107.172.27.254:/home  //上传文件scp -r root@107.172.27.254:/home/test .  //下载目录scp -r test root@107.172.27.254:/home   //上传目录scp -P 9922 -r root@47.244.225.92:/home // 指定端口复制文件至其他系统【rsync】  rsync 是Linux 系统下常用的数据镜像备份工具，不同主机之间同步文件，除了文件意外，还可以镜像保存整个目录树和文件系统，可以增量同步，并保持文件原来属性（权限、时间戳……）,而且传输过程中是加密，保证了数据安全性  helpUsage: rsync [OPTION]... SRC [SRC]... DEST  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST  or   rsync [OPTION]... [USER@]HOST:SRC [DEST]  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]  rsync 后续添加显示网络连接、路由表或接口 【netstart】  显示 tpc  显示 udp  显示核心路由  显示网络接口列表  常用显示[root@Cc ~]# netstat -atActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         Statetcp        0      0 0.0.0.0:https           0.0.0.0:*               LISTENtcp        0      0 0.0.0.0:aequus          0.0.0.0:*               LISTENtcp        0      0 localhost:32000         0.0.0.0:*               LISTENtcp        0      0 0.0.0.0:8836            0.0.0.0:*               LISTENtcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTENtcp        0      0 0.0.0.0:http            0.0.0.0:*               LISTENtcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTENtcp        0      0 Cc:53354                100.100.30.26:http      ESTABLISHEDtcp        0      0 Cc:ssh                  113.118.200.16:7069     ESTABLISHEDtcp        0      0 localhost:31000         localhost:32000         ESTABLISHEDtcp        0      0 localhost:32000         localhost:31000         ESTABLISHEDtcp6       0      0 [::]:filenet-tms        [::]:*                  LISTENtcp6       0      0 [::]:cslistener         [::]:*                  LISTENtcp6       0      0 [::]:mysql              [::]:*                  LISTENtcp6       0      0 [::]:8180               [::]:*                  LISTEN[root@Cc ~]# netstat -auActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         Stateudp        0      0 0.0.0.0:bootpc          0.0.0.0:*udp        0      0 Cc:ntp                  0.0.0.0:*udp        0      0 Cc:ntp                  0.0.0.0:*udp        0      0 localhost:ntp           0.0.0.0:*udp        0      0 0.0.0.0:ntp             0.0.0.0:*udp6       0      0 [::]:ntp                [::]:*[root@Cc ~]# netstat -rKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window  irtt Ifacedefault         gateway         0.0.0.0         UG        0 0          0 eth010.0.0.0        0.0.0.0         255.255.255.0   U         0 0          0 eth0link-local      0.0.0.0         255.255.0.0     U         0 0          0 eth0172.24.0.0      0.0.0.0         255.255.192.0   U         0 0          0 docker0172.24.0.0      0.0.0.0         255.255.192.0   U         0 0          0 eth0172.31.208.0    0.0.0.0         255.255.240.0   U         0 0          0 eth0[root@Cc ~]# netstat -iKernel Interface tableIface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flgdocker0          1500       34      0      0 0            30      0      0      0 BMRUeth0             1500   660702      0      0 0        790356      0      0      0 BMRUlo              65536    50832      0      0 0         50832      0      0      0 LRUvethbb7d0dd      1500        8      0      0 0            23      0      0      0 BMRUvethf4f0960      1500       26      0      0 0            38      0      0      0 BMRU[root@Cc ~]# netstat -ntlpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program nametcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      923/nginx: master ptcp        0      0 0.0.0.0:23456           0.0.0.0:*               LISTEN      1425/sshdtcp        0      0 127.0.0.1:32000         0.0.0.0:*               LISTEN      1199/javatcp        0      0 0.0.0.0:8836            0.0.0.0:*               LISTEN      923/nginx: master ptcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      824/redis-server 0.tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      923/nginx: master ptcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1425/sshdtcp6       0      0 :::32768                :::*                    LISTEN      1731/docker-proxy-ctcp6       0      0 :::9000                 :::*                    LISTEN      1746/docker-proxy-ctcp6       0      0 :::3306                 :::*                    LISTEN      1508/mysqldtcp6       0      0 :::8180                 :::*                    LISTEN      3090/./server[root@Cc ~]#探测至目的地址的路由信息【traceroute】  显示本机到 baidu.com 所经过的路由[root@Cc ~]# traceroute -n baidu.comtraceroute to baidu.com (220.181.38.148), 30 hops max, 60 byte packets 1  * * * 2  * * * 3  11.220.31.154  1.371 ms 11.220.30.130  0.920 ms 11.220.30.138  3.912 ms 4  11.218.196.254  1.254 ms 11.204.180.122  1.597 ms 11.218.196.254  1.435 ms 5  116.251.117.10  1.938 ms 42.120.243.82  1.842 ms 116.251.117.2  2.458 ms 6  116.251.112.153  1.454 ms 116.251.94.17  2.001 ms 116.251.112.205  13.491 ms 7  36.110.169.221  2.931 ms 36.110.169.101  3.467 ms 106.38.196.253  3.093 ms 8  * 36.110.244.57  3.801 ms 36.110.244.49  3.765 ms 9  220.181.182.178  3.718 ms * *10  220.181.17.90  3.963 ms  4.313 ms 220.181.182.170  3.559 ms11  * * *14  * * *………………………………29  * * *30  * * *[root@Cc ~]#  域名不可达，最大 30 跳测试登录、控制远程【telnet】  找不到命令 ,可以连接互联网情况下使用yum install telnet安装  成功[root@Cc ~]# telnet 115.28.138.41 22Trying 115.28.138.41...Connected to 115.28.138.41.Escape character is '^]'.SSH-2.0-OpenSSH_7.4test sshdProtocol mismatch.Connection closed by foreign host.[root@Cc ~]# telnet baidu.com 80Trying 39.156.69.79...\\Connected to baidu.com.Escape character is '^]'.Connection closed by foreign host.[root@Cc ~]#  失败[root@Cc ~]# telnet 192.168.1.12 22Trying 192.168.1.12...下载网络文件【wget】  下载文件wget [地址]  断点续传wget -c   批量下载下载文件中 一些列网址 wget -i download.txt[root@Cc ~]# wget --help;GNU Wget 1.14，非交互式的网络文件下载工具。用法： wget [选项]... [URL]...长选项所必须的参数在使用短选项时也是必须的。启动：  -V,  --version           显示 Wget 的版本信息并退出。  -h,  --help              打印此帮助。  -b,  --background        启动后转入后台。  -e,  --execute=COMMAND   运行一个“.wgetrc”风格的命令。日志和输入文件：  -o,  --output-file=FILE    将日志信息写入 FILE。  -a,  --append-output=FILE  将信息添加至 FILE。  -d,  --debug               打印大量调试信息。  -q,  --quiet               安静模式 (无信息输出)。  -v,  --verbose             详尽的输出 (此为默认值)。  -nv, --no-verbose          关闭详尽输出，但不进入安静模式。       --report-speed=TYPE   Output bandwidth as TYPE.  TYPE can be bits.  -i,  --input-file=FILE     下载本地或外部 FILE 中的 URLs。  -F,  --force-html          把输入文件当成 HTML 文件。  -B,  --base=URL            解析与 URL 相关的                             HTML 输入文件 (由 -i -F 选项指定)。       --config=FILE         Specify config file to use.下载：  -t,  --tries=NUMBER            设置重试次数为 NUMBER (0 代表无限制)。       --retry-connrefused       即使拒绝连接也是重试。  -O,  --output-document=FILE    将文档写入 FILE。  -nc, --no-clobber              skip downloads that would download to                                 existing files (overwriting them).  -c,  --continue                断点续传下载文件。       --progress=TYPE           选择进度条类型。  -N,  --timestamping            只获取比本地文件新的文件。  --no-use-server-timestamps     不用服务器上的时间戳来设置本地文件。  -S,  --server-response         打印服务器响应。       --spider                  不下载任何文件。  -T,  --timeout=SECONDS         将所有超时设为 SECONDS 秒。       --dns-timeout=SECS        设置 DNS 查寻超时为 SECS 秒。       --connect-timeout=SECS    设置连接超时为 SECS 秒。       --read-timeout=SECS       设置读取超时为 SECS 秒。  -w,  --wait=SECONDS            等待间隔为 SECONDS 秒。       --waitretry=SECONDS       在获取文件的重试期间等待 1..SECONDS 秒。       --random-wait             获取多个文件时，每次随机等待间隔                                 0.5*WAIT...1.5*WAIT 秒。       --no-proxy                禁止使用代理。  -Q,  --quota=NUMBER            设置获取配额为 NUMBER 字节。       --bind-address=ADDRESS    绑定至本地主机上的 ADDRESS (主机名或是 IP)。       --limit-rate=RATE         限制下载速率为 RATE。       --no-dns-cache            关闭 DNS 查寻缓存。       --restrict-file-names=OS  限定文件名中的字符为 OS 允许的字符。       --ignore-case             匹配文件/目录时忽略大小写。  -4,  --inet4-only              仅连接至 IPv4 地址。  -6,  --inet6-only              仅连接至 IPv6 地址。       --prefer-family=FAMILY    首先连接至指定协议的地址                                 FAMILY 为 IPv6，IPv4 或是 none。       --user=USER               将 ftp 和 http 的用户名均设置为 USER。       --password=PASS           将 ftp 和 http 的密码均设置为 PASS。       --ask-password            提示输入密码。       --no-iri                  关闭 IRI 支持。       --local-encoding=ENC      IRI (国际化资源标识符) 使用 ENC 作为本地编码。       --remote-encoding=ENC     使用 ENC 作为默认远程编码。       --unlink                  remove file before clobber.目录：  -nd, --no-directories           不创建目录。  -x,  --force-directories        强制创建目录。  -nH, --no-host-directories      不要创建主目录。       --protocol-directories     在目录中使用协议名称。  -P,  --directory-prefix=PREFIX  以 PREFIX/... 保存文件       --cut-dirs=NUMBER          忽略远程目录中 NUMBER 个目录层。HTTP 选项：       --http-user=USER        设置 http 用户名为 USER。       --http-password=PASS    设置 http 密码为 PASS。       --no-cache              不在服务器上缓存数据。       --default-page=NAME     改变默认页                               (默认页通常是“index.html”)。  -E,  --adjust-extension      以合适的扩展名保存 HTML/CSS 文档。       --ignore-length         忽略头部的‘Content-Length’区域。       --header=STRING         在头部插入 STRING。       --max-redirect          每页所允许的最大重定向。       --proxy-user=USER       使用 USER 作为代理用户名。       --proxy-password=PASS   使用 PASS 作为代理密码。       --referer=URL           在 HTTP 请求头包含‘Referer: URL’。       --save-headers          将 HTTP 头保存至文件。  -U,  --user-agent=AGENT      标识为 AGENT 而不是 Wget/VERSION。       --no-http-keep-alive    禁用 HTTP keep-alive (永久连接)。       --no-cookies            不使用 cookies。       --load-cookies=FILE     会话开始前从 FILE 中载入 cookies。       --save-cookies=FILE     会话结束后保存 cookies 至 FILE。       --keep-session-cookies  载入并保存会话 (非永久) cookies。       --post-data=STRING      使用 POST 方式；把 STRING 作为数据发送。       --post-file=FILE        使用 POST 方式；发送 FILE 内容。       --content-disposition   当选中本地文件名时                               允许 Content-Disposition 头部 (尚在实验)。       --content-on-error      output the received content on server errors.       --auth-no-challenge     发送不含服务器询问的首次等待                               的基本 HTTP 验证信息。HTTPS (SSL/TLS) 选项：       --secure-protocol=PR     choose secure protocol, one of auto, SSLv2,                                SSLv3, TLSv1, TLSv1_1 and TLSv1_2.       --no-check-certificate   不要验证服务器的证书。       --certificate=FILE       客户端证书文件。       --certificate-type=TYPE  客户端证书类型，PEM 或 DER。       --private-key=FILE       私钥文件。       --private-key-type=TYPE  私钥文件类型，PEM 或 DER。       --ca-certificate=FILE    带有一组 CA 认证的文件。       --ca-directory=DIR       保存 CA 认证的哈希列表的目录。       --random-file=FILE       带有生成 SSL PRNG 的随机数据的文件。       --egd-file=FILE          用于命名带有随机数据的 EGD 套接字的文件。FTP 选项：       --ftp-user=USER         设置 ftp 用户名为 USER。       --ftp-password=PASS     设置 ftp 密码为 PASS。       --no-remove-listing     不要删除‘.listing’文件。       --no-glob               不在 FTP 文件名中使用通配符展开。       --no-passive-ftp        禁用“passive”传输模式。       --preserve-permissions  保留远程文件的权限。       --retr-symlinks         递归目录时，获取链接的文件 (而非目录)。WARC options:       --warc-file=FILENAME      save request/response data to a .warc.gz file.       --warc-header=STRING      insert STRING into the warcinfo record.       --warc-max-size=NUMBER    set maximum size of WARC files to NUMBER.       --warc-cdx                write CDX index files.       --warc-dedup=FILENAME     do not store records listed in this CDX file.       --no-warc-compression     do not compress WARC files with GZIP.       --no-warc-digests         do not calculate SHA1 digests.       --no-warc-keep-log        do not store the log file in a WARC record.       --warc-tempdir=DIRECTORY  location for temporary files created by the                                 WARC writer.递归下载：  -r,  --recursive          指定递归下载。  -l,  --level=NUMBER       最大递归深度 (inf 或 0 代表无限制，即全部下载)。       --delete-after       下载完成后删除本地文件。  -k,  --convert-links      让下载得到的 HTML 或 CSS 中的链接指向本地文件。  --backups=N   before writing file X, rotate up to N backup files.  -K,  --backup-converted   在转换文件 X 前先将它备份为 X.orig。  -m,  --mirror             -N -r -l inf --no-remove-listing 的缩写形式。  -p,  --page-requisites    下载所有用于显示 HTML 页面的图片之类的元素。       --strict-comments    用严格方式 (SGML) 处理 HTML 注释。递归接受/拒绝：  -A,  --accept=LIST               逗号分隔的可接受的扩展名列表。  -R,  --reject=LIST               逗号分隔的要拒绝的扩展名列表。       --accept-regex=REGEX        regex matching accepted URLs.       --reject-regex=REGEX        regex matching rejected URLs.       --regex-type=TYPE           regex type (posix|pcre).  -D,  --domains=LIST              逗号分隔的可接受的域列表。       --exclude-domains=LIST      逗号分隔的要拒绝的域列表。       --follow-ftp                跟踪 HTML 文档中的 FTP 链接。       --follow-tags=LIST          逗号分隔的跟踪的 HTML 标识列表。       --ignore-tags=LIST          逗号分隔的忽略的 HTML 标识列表。  -H,  --span-hosts                递归时转向外部主机。  -L,  --relative                  只跟踪有关系的链接。  -I,  --include-directories=LIST  允许目录的列表。  --trust-server-names             use the name specified by the redirection                                   url last component.  -X,  --exclude-directories=LIST  排除目录的列表。  -np, --no-parent                 不追溯至父目录。请将错误报告或建议寄给 &lt;bug-wget@gnu.org&gt;。[root@Cc ~]#网络配置查看某网卡配置[root@Cc ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes[root@Cc ~]#设置主机名  设置主机名之后需要重新的启动，我这里是切换用户登录，查看效果[root@Cc ~]# hostname Hyper[root@Cc ~]# su testUser[testUser@Hyper root]$ su root密码：[root@Hyper ~]#设置默认网关  方法一  [root@Hyper ~]# route add default wg 172.24.63.255  如果是虚拟机就可以试试设置网关，在这网络配置还是要小心为妙，我这里就没有执行这一行  方法二[root@Hyper ~]# cat /etc/sysconfig/network# Created by anacondaNETWORKING_IPV6=noPEERNTP=noGATEWAY=172.24.63.255[root@Hyper ~]#  重新启动网卡[root@Hyper ~]# /etc/rc.d/init.d/network restartRestarting network (via systemctl):                        [  确定  ][root@Hyper ~]#设置 DNS 服务[root@Hyper ~]# cat /etc/resolv.confoptions timeout:2 attempts:3 rotate single-request-reopen; generated by /usr/sbin/dhclient-scriptnameserver 100.100.2.136nameserver 100.100.2.138[root@Hyper ~]#动态主机配置协议 DHCP  好多概念知识，会拿出时间来讲解这张预留的空白Linux 域名服务 DNS  好多概念知识，会拿出时间来讲解这张预留的空白配置精确时间协议  好多概念知识，会拿出时间来讲解这张预留的空白监控网卡流量#预留"
  },
  
  {
    "title": "linux(CentOS7) 应用程序管理",
    "url": "/posts/8-RedHad-appliction-manger/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-28 16:11:12 +0800",
    





    
    "snippet": "应用程序管理软件包基础常见安装工具包  RPM  DPKGRPM 使用安装软件 （rz 示例）  都和以下载  ftp://ftp.pbone.net/mirror/ftp.centos.org/7.7.1908/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm  wget http://images.lichaocheng.top/sta...",
    "content": "应用程序管理软件包基础常见安装工具包  RPM  DPKGRPM 使用安装软件 （rz 示例）  都和以下载  ftp://ftp.pbone.net/mirror/ftp.centos.org/7.7.1908/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm  wget http://images.lichaocheng.top/static/upload/2020/03/28/6fc647af1780ffc0b127510a418445a1.rpm[root@Cc rpm]#  wget ftp://ftp.pbone.net/mirror/ftp.centos.org/7.7.1908/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm[root@Cc rpm]# pwd/root/RedHad/8/rpm[root@Cc rpm]# ll总用量 80-rw-r--r-- 1 root root 79376 3月  28 15:10 6fc647af1780ffc0b127510a418445a1.rpm[root@Cc rpm]# rpm -ivh lrzsz-0.12.20-36.el7.x86_64.rpm准备中...                          ################################# [100%]正在升级/安装...   1:lrzsz-0.12.20-36.el7             ################################# [100%][root@Cc rpm]# rz --versionrz (lrzsz) 0.12.20[root@Cc rpm]#升级[root@Cc rpm]# rpm -Uvh lrzsz-0.12.20-36.el7.x86_64.rpm 查看已安装的软件包、和查看安装位置[root@Cc rpm]# rpm -qa |grep rzlrzsz-0.12.20-36.el7.x86_64卸载[root@Cc rpm]# rpm -qa |grep rzlrzsz-0.12.20-36.el7.x86_64[root@Cc rpm]# rpm -e lrzsz-0.12.20-36.el7.x86_64[root@Cc rpm]# rz --version-bash: /usr/bin/rz: 没有那个文件或目录[root@Cc rpm]#查看文件属于哪个文件[root@Cc rpm]# which go/usr/local/go/go/bin/go[root@Cc rpm]#查看rpm说明信息[root@Cc rpm]# rpm -qip lrzsz-0.12.20-36.el7.x86_64.rpmName        : lrzszVersion     : 0.12.20Release     : 36.el7Architecture: x86_64Install Date: (not installed)Group       : Applications/CommunicationsSize        : 184846License     : GPLv2+Signature   : RSA/SHA256, 2014年07月04日 星期五 11时35分32秒, Key ID 24c6a8a7f4a80eb5Source RPM  : lrzsz-0.12.20-36.el7.src.rpmBuild Date  : 2014年06月10日 星期二 07时29分11秒Build Host  : worker1.bsys.centos.orgRelocations : (not relocatable)Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor      : CentOSURL         : http://www.ohse.de/uwe/software/lrzsz.htmlSummary     : The lrz and lsz modem communications programsDescription :Lrzsz (consisting of lrz and lsz) is a cosmetically modifiedzmodem/ymodem/xmodem package built from the public-domain version ofthe rzsz package. Lrzsz was created to provide a working GNUcopylefted Zmodem solution for Linux systems.[root@Cc rpm]#源码安装  主要是依赖 make 和Makefile 编译  make install ，执行完之后，安装一般会被安装在/uer/local下对应的文件夹，部分二进制文件放在usr/bin或在/usr/local/bin 对应的头文件被安装至/usr/include，帮助文档安装至/usr/local/share ,如果指定目录请加到环境变量里面去yum installLinux 函数库从源码安装 web 服务软件Nginx  下载地址【http://nginx.org/】  创建预知准备好的Nginx目录  rpm、源码、yum install 都可以          yum install nginx 【个人觉得最实用了】      对于相关 应用程序安装blog.lichaocheng.top 下的相关安装文章"
  },
  
  {
    "title": "linux(CentOS7) 用户和组",
    "url": "/posts/7-RedHad-user-group/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-28 00:03:12 +0800",
    





    
    "snippet": "用户和组Linux 用户管理登录时发生了什么  不管是终端还是图像界面登录系统校验  检查这个用户是否 /etc/passwd 中  再校验 /etc/shadow 密码是否正确  密码输入次数大于默认值 3 次重新输入用户名再输入密码用户类型      超级用户：超级用户 USER ID 为 0 root:x:0:0:root:/root:/bin/bash    系统用户  普通用户  ...",
    "content": "用户和组Linux 用户管理登录时发生了什么  不管是终端还是图像界面登录系统校验  检查这个用户是否 /etc/passwd 中  再校验 /etc/shadow 密码是否正确  密码输入次数大于默认值 3 次重新输入用户名再输入密码用户类型      超级用户：超级用户 USER ID 为 0 root:x:0:0:root:/root:/bin/bash    系统用户  普通用户  root 用户可以更改任何用户密码用户管理机制  用户账号文件【/etc/passwd】  密码文件【/etc/shadow】  用户组文件【/etc/group】/etc/passwd  文件中 * 表示该用户已被禁止，无法登录`用户名:密码:USER ID:GROUP ID :相关注释:主目录:使用shell``root:x:0:0:root:/root:/bin/bash`  USER ID :最多为 65535，UID 相同可人为同一用户，也具有相同权限如果该更改某些用户权限可以使用这方法  GROUP ID: 用户可以是用多个组，组可以有多个权限，和 windows 差不多/etc/shadow`用户名:密码:上次修改时间:两次修改密码间隔最少天数:两次修改密码间隔最多天数:提前多少天警告用户密码过期:在密码多少天过期后禁用用户:用户过期时间:保留字段``root:$6DQIY.H35tynh7gf2xB5jzrs8zYu.:18205:0:99999:7:::`  密码：x 表示用户禁止使用，不能登录  上次修改密码时间：单位天  两次修改间隔最少天数：0表示此功能被禁用，反则  两次修改间隔最多天数：99999 表示基本不需要修改/etc/group用户组名:用户组密码:用户组标识号:组内用户列表root:x:0:  组内用户列表：不同用户之间用逗号分隔，不能有空格用户管理命令添加用户【useradd】[root@Cc ~]# useradd --help用法：useradd [选项] 登录      useradd -D      useradd -D [选项]选项：  -b, --base-dir BASE_DIR       新账户的主目录的基目录  -c, --comment COMMENT         新账户的 GECOS 字段  -d, --home-dir HOME_DIR       新账户的主目录  -D, --defaults                显示或更改默认的 useradd 配置  -e, --expiredate EXPIRE_DATE  新账户的过期日期  -f, --inactive INACTIVE       新账户的密码不活动期  -g, --gid GROUP               新账户主组的名称或 ID  -G, --groups GROUPS   \t\t新账户的附加组列表  -h, --help                    显示此帮助信息并推出  -k, --skel SKEL_DIR   \t\t使用此目录作为骨架目录  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值  -l, --no-log-init     \t\t不要将此用户添加到最近登录和登录失败数据库  -m, --create-home     \t\t创建用户的主目录  -M, --no-create-home          不创建用户的主目录  -N, --no-user-group   \t\t不创建同名的组  -o, --non-unique              允许使用重复的 UID 创建用户  -p, --password PASSWORD       加密后的新账户密码  -r, --system                  创建一个系统账户  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files  -s, --shell SHELL             新账户的登录 shell  -u, --uid UID                 新账户的用户 ID  -U, --user-group              创建与用户同名的组  -Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER[root@Cc ~]#更改用户[usermod][root@Cc ~]# usermod --help用法：usermod [选项] 登录选项：  -c, --comment 注释             GECOS 字段的新值  -d, --home HOME_DIR           用户的新主目录  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态  -g, --gid GROUP               强制使用 GROUP 为新主组  -G, --groups GROUPS           新的附加组列表 GROUPS  -a, --append GROUP            将用户追加至上边 -G 中提到的附加组中，                                并不从其它组中删除此用户  -h, --help                    显示此帮助信息并推出  -l, --login LOGIN             新的登录名称  -L, --lock                    锁定用户帐号  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)  -o, --non-unique              允许使用重复的(非唯一的) UID  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files  -s, --shell SHELL             该用户帐号的新登录 shell  -u, --uid UID                 用户帐号的新 UID  -U, --unlock                  解锁用户帐号  -v, --add-subuids FIRST-LAST  add range of subordinate uids  -V, --del-subuids FIRST-LAST  remove range of subordinate uids  -w, --add-subgids FIRST-LAST  add range of subordinate gids  -W, --del-subgids FIRST-LAST  remove range of subordinate gids  -Z, --selinux-user  SEUSER    用户账户的新 SELinux 用户映射[root@Cc ~]#删除用户[userdel][root@Cc ~]# userdel --help用法：userdel [选项] 登录选项：  -f, --force                   force some actions that would fail otherwise                                e.g. removal of user still logged in                                or files, even if not owned by the user  -h, --help                    显示此帮助信息并推出  -r, --remove                  删除主目录和邮件池  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files  -Z, --selinux-user            为用户删除所有的 SELinux 用户映射[root@Cc ~]#更改或者设置用户密码 [passwd][root@Cc ~]# passwd --help用法: passwd [选项...] &lt;帐号名称&gt;  -k, --keep-tokens       保持身份验证令牌不过期  -d, --delete            删除已命名帐号的密码(只有根用户才能进行此操作)  -l, --lock              锁定指名帐户的密码(仅限 root 用户)  -u, --unlock            解锁指名账户的密码(仅限 root 用户)  -e, --expire            终止指名帐户的密码(仅限 root 用户)  -f, --force             强制执行操作  -x, --maximum=DAYS      密码的最长有效时限(只有根用户才能进行此操作)  -n, --minimum=DAYS      密码的最短有效时限(只有根用户才能进行此操作)  -w, --warning=DAYS      在密码过期前多少天开始提醒用户(只有根用户才能进行此操作)  -i, --inactive=DAYS     当密码过期后经过多少天该帐号会被禁用(只有根用户才能进行此操作)  -S, --status            报告已命名帐号的密码状态(只有根用户才能进行此操作)  --stdin                 从标准输入读取令牌(只有根用户才能进行此操作)Help options:  -?, --help              Show this help message  --usage                 Display brief usage message[root@Cc ~]#切换用户[su][root@Cc ~]# su --help用法：su [选项] [-] [USER [参数]...]将有效用户 id 和组 id 更改为 USER 的 id。单个 - 视为 -l。如果未指定 USER，将假定为 root。选项： -m, -p, --preserve-environment  不重置环境变量 -g, --group &lt;组&gt;             指定主组 -G, --supp-group &lt;组&gt;        指定一个辅助组 -, -l, --login                  使 shell 成为登录 shell -c, --command &lt;命令&gt;            使用 -c 向 shell 传递一条命令 --session-command &lt;命令&gt;        使用 -c 向 shell 传递一条命令                                 而不创建新会话 -f, --fast                      向shell 传递 -f 选项(csh 或 tcsh) -s, --shell &lt;shell&gt;             若 /etc/shells 允许，则运行 shell -h, --help     显示此帮助并退出 -V, --version  输出版本信息并退出[root@Cc ~]#普通用户获取超级权限[sudo][root@Cc ~]# sudo --help;sudo - 以其他用户身份执行一条命令usage: sudo -h | -K | -k | -Vusage: sudo -v [-AknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-AknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]usage: sudo [-AbEHknPS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...选项：  -A, --askpass                 使用助手程序进行密码提示  -b, --background              在后台运行命令  -C, --close-from=num          关闭所有 &gt;= num 的文件描述符  -E, --preserve-env            在执行命令时保留用户环境      --preserve-env=list       保留特定的环境变量  -e, --edit                    编辑文件而非执行命令  -g, --group=group             以指定的用户组或 ID 执行命令  -H, --set-home                将 HOME 变量设为目标用户的主目录。  -h, --help                    显示帮助消息并退出  -h, --host=host               在主机上运行命令(如果插件支持)  -i, --login                   以目标用户身份运行一个登录 shell；可同时指定一条命令  -K, --remove-timestamp        完全移除时间戳文件  -k, --reset-timestamp         无效的时间戳文件  -l, --list                    列出用户权限或检查某个特定命令；对于长格式，使用两次  -n, --non-interactive         非交互模式，不提示  -P, --preserve-groups         保留组向量，而非设置为目标的组向量  -p, --prompt=prompt           使用指定的密码提示  -r, --role=role               以指定的角色创建 SELinux 安全环境  -S, --stdin                   从标准输入读取密码  -s, --shell                   以目标用户运行 shell；可同时指定一条命令  -t, --type=type               以指定的类型创建 SELinux 安全环境  -T, --command-timeout=timeout 在达到指定时间限制后终止命令  -U, --other-user=user         在列表模式中显示用户的权限  -u, --user=user               以指定用户或 ID 运行命令(或编辑文件)  -V, --version                 显示版本信息并退出  -v, --validate                更新用户的时间戳而不执行命令  --                            停止处理命令行参数[root@Cc ~]#用户管理示例[root@Cc ~]# useradd testUser[root@Cc ~]# useradd testUserName[root@Cc ~]# cat /etc/passwd# 只复制了最后几行yf:x:1001:1001::/home/yf:/bin/bashlcc:x:1002:1002::/home/lcc:/bin/bashlccs:x:1003:1003::/home/ch:/bin/bashtestUser:x:1004:1004::/home/testUser:/bin/bashtestUserName:x:1005:1005::/home/testUserName:/bin/bash[root@Cc ~]# userdel yf[root@Cc ~]# userdel lcc[root@Cc ~]# userdel lccs[root@Cc ~]# cat /etc/passwd# 只复制了最后几行admin:x:1000:1000::/home/admin:/bin/bashnginx:x:996:994:nginx user:/var/cache/nginx:/sbin/nologinmysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/falseredis:x:995:993:Redis Database Server:/var/lib/redis:/sbin/nologindockerroot:x:994:991:Docker User:/var/lib/docker:/sbin/nologintestUser:x:1004:1004::/home/testUser:/bin/bashtestUserName:x:1005:1005::/home/testUserName:/bin/bash[root@Cc ~]# passwd testUser更改用户 testUser 的密码 。新的 密码：重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@Cc ~]# su testUser[testUser@Cc root]$ su root密码：[root@Cc ~]# su testUser[testUser@Cc root]$ llls: 无法打开目录.: 权限不够[testUser@Cc root]$ sudo ll我们信任您已经从系统管理员那里了解了日常注意事项。总结起来无外乎这三点：    #1) 尊重别人的隐私。    #2) 输入前要先考虑(后果和风险)。    #3) 权力越大，责任越大。[sudo] testUser 的密码：testUser 不在 sudoers 文件中。此事将被报告。[testUser@Cc ~]$ pwd/home/testUser[testUser@Cc ~]$用户组管理命令添加用户组【groupadd】[testUser@Cc ~]$ groupadd --help用法：groupadd [选项] 组选项:  -f, --force           如果组已经存在则成功退出                        并且如果 GID 已经存在则取消 -g  -g, --gid GID                 为新组使用 GID  -h, --help                    显示此帮助信息并推出  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值  -o, --non-unique              允许创建有重复 GID 的组  -p, --password PASSWORD       为新组使用此加密过的密码  -r, --system                  创建一个系统账户  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       directory prefix[testUser@Cc ~]$删除用户组【groupdel】[testUser@Cc ~]$ groupadd --help用法：groupadd [选项] 组选项:  -f, --force           如果组已经存在则成功退出                        并且如果 GID 已经存在则取消 -g  -g, --gid GID                 为新组使用 GID  -h, --help                    显示此帮助信息并推出  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值  -o, --non-unique              允许创建有重复 GID 的组  -p, --password PASSWORD       为新组使用此加密过的密码  -r, --system                  创建一个系统账户  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       directory prefix[testUser@Cc ~]$ groupdel --help用法：groupdel [选项] 组选项:  -h, --help                    显示此帮助信息并推出  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files  -f, --force                   delete group even if it is the primary group of a user[testUser@Cc ~]$修改用户组【groupmod】[testUser@Cc ~]$ groupdel --help用法：groupdel [选项] 组选项:  -h, --help                    显示此帮助信息并推出  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files  -f, --force                   delete group even if it is the primary group of a user[testUser@Cc ~]$ groupmod --help用法：groupmod [选项] 组选项:  -g, --gid GID                 将组 ID 改为 GID  -h, --help                    显示此帮助信息并推出  -n, --new-name NEW_GROUP      改名为 NEW_GROUP  -o, --non-unique              允许使用重复的 GID  -p, --password PASSWORD       将密码更改为(加密过的) PASSWORD  -R, --root CHROOT_DIR         chroot 到的目录  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files[testUser@Cc ~]$查看用户所在用户组【id 与 grep 组合 】[root@Cc testUser]# id testUseruid=1004(testUser) gid=1004(testUser) 组=1004(testUser)[root@Cc testUser]# id rootuid=0(root) gid=0(root) 组=0(root)[root@Cc testUser]# grep testUser /etc/passwdtestUser:x:1004:1004::/home/testUser:/bin/bashtestUserName:x:1005:1005::/home/testUserName:/bin/bash[root@Cc testUser]# grep 1004 /etc/grouptestUser:x:1004:[root@Cc testUser]#示例[root@Cc testUser]# groupadd testUserGroup[root@Cc testUser]# cat /etc/group |grep testtestUser:x:1004:testUserGroup:x:1005:[root@Cc testUser]# useradd -g testUserGroup testUserInGroup[root@Cc testUser]# groupdel testUserGroupgroupdel：不能移除用户“testUserInGroup”的主组[root@Cc testUser]# userdel -r testUserInGroup[root@Cc testUser]# groupdel testUserGroup[root@Cc testUser]# groupdel testUserGroup[root@Cc testUser]# cat /etc/group |grep testtestUser:x:1004:[root@Cc testUser]# groupmod -g 10002 testUsertestUser:x:10002:[root@Cc testUser]# groupmod -n lccGroup testUser[root@Cc testUser]# cat /etc/group |grep lcclccGroup:x:10002:[root@Cc testUser]#批量添加用户并设置密码预留应用程序管理"
  },
  
  {
    "title": "linux(CentOS7) 日志系统",
    "url": "/posts/6-RedHad-log/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-26 23:24:12 +0800",
    





    
    "snippet": "Linux 日志系统  日志用途  系统审计  检测追踪  分析统计          Web 应用请求量      错误码分布      性能      是否需要扩容      多少用户量      常见的日志文件  登录日志[root@Cc log]# lastlog用户名           端口     来自             最后登陆时间root             pt...",
    "content": "Linux 日志系统  日志用途  系统审计  检测追踪  分析统计          Web 应用请求量      错误码分布      性能      是否需要扩容      多少用户量      常见的日志文件  登录日志[root@Cc log]# lastlog用户名           端口     来自             最后登陆时间root             pts/1    113.118.200.16   四 3月 26 21:38:34 +0800 2020ftp                                        **从未登录过**sshd                                       **从未登录过**ntp                                        **从未登录过**nginx                                      **从未登录过**mysql                                      **从未登录过**redis                                      **从未登录过**dockerroot                                 **从未登录过**yf               pts/5                     一 3月 23 21:14:45 +0800 2020[root@Cc log]#  who  users（查看当前用户）  最近重启日志[root@Cc log]# last rebootreboot   system boot  3.10.0-1062.4.1. Fri Mar 20 17:14 - 22:55 (6+05:41)reboot   system boot  3.10.0-1062.4.1. Fri Mar 20 17:14 - 09:14  (-7:-59)日志文件说明/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一/var/log/secure 与安全相关的日志信息/var/log/maillog 与邮件相关的日志信息/var/log/cron 与定时任务相关的日志信息/var/log/spooler 与UUCP和news设备相关的日志信息/var/log/boot.log 守护进程启动和停止相关的日志消息日志系统rsyslog 日志系统  /etc/rsyslog.conf  默认配置，该配置文件对应日志文件请看上面【日志文件说明】使用日志轮转  主要配置文件 /etc/logrotate.conf  主要配置目录 /etc/logrotate.d[root@Cc etc]# logrotate --help;用法: logrotate [OPTION...] &lt;configfile&gt;  -d, --debug               详细显示指令执行过程  -f, --force               强行启动记录文件维护  -m, --mail=command        发送邮件的命令 (而不是 `/bin/mail')  -s, --state=statefile     指定状态文件  -v, --verbose             执行日志滚动式显示详细信息  -l, --log=STRING          Log file  -?\t\t\t\t\t\t帮助文档查看 nginx[root@Cc logrotate.d]# cat -n /etc/logrotate.d/nginx     1  /var/log/nginx/*.log {     2          daily     3          missingok     4          rotate 52     5          compress     6          delaycompress     7          notifempty     8          create 640 nginx adm     9          sharedscripts    10          postrotate    11                  if [ -f /var/run/nginx.pid ]; then    12                          kill -USR1 `cat /var/run/nginx.pid`    13                  fi    14          endscript    15  }[root@Cc logrotate.d]#范例—————利用系统日志定位问题这个预留，动手利用第五章知识完成7 用户和组"
  },
  
  {
    "title": "linux(CentOS7) 文件管理与磁盘管理",
    "url": "/posts/5-RedHad-file/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-26 23:23:12 +0800",
    





    
    "snippet": "文件管理认识分区[root@Cc ~]# df -hFilesystem      Size  Used Avail Use% Mounted ondevtmpfs        909M     0  909M   0% /dev[root@Cc ~]# df -h文件系统        容量  已用  可用 已用% 挂载点devtmpfs        909M     0  909M ...",
    "content": "文件管理认识分区[root@Cc ~]# df -hFilesystem      Size  Used Avail Use% Mounted ondevtmpfs        909M     0  909M   0% /dev[root@Cc ~]# df -h文件系统        容量  已用  可用 已用% 挂载点devtmpfs        909M     0  909M    0% /dev文件管理文件类型  普通文件 -  目录文件 d  块设备文件 d/c  连接文件  字符设备文件 d/c  socket 文件 s  管道文件 p文件属性权限  读…………………………r  写…………………………w  可执行…………………X示例-rwxrw-r--[-]表示普通文件[rwx]表示读写执行权限[rw-]所属与同一组的用户就有读写权限[r--]表示其他用户对该文件只有读权限  -rwxrwxrx：为文件最大权限，对应的编码为 777，表示任何用户都有读写执行此文件改变文件所有权  chown  chgrp改变文件权限chmod  r—-4—–读———read  w—2—–写——–write  x—-1—–执行—–[execute]示例[root@Cc 5]# touch test.sh[root@Cc 5]# ll总用量 0-rw-r--r-- 1 root root 0 3月  26 22:02 test.sh[root@Cc 5]# ./test.sh-bash: ./test.sh: 权限不够[root@Cc 5]#  test.sh没有执行权限[root@Cc 5]# chmod u+x test.sh[root@Cc 5]# ./test.sh  加上权限[root@Cc 5]# chmod o-r test.sh[root@Cc 5]# ll总用量 0-rwxr----- 1 root root 0 3月  26 22:02 test.sh[root@Cc 5]#  设置其他用户不可读[root@Cc 5]# ll总用量 0-rwxr----- 1 root root 0 3月  26 22:02 test.sh-rwxrwxr-x 1 root root 0 3月  26 22:11 test.txt[root@Cc 5]# chmod ugo+r test.txt[root@Cc 5]# chmod a+r test.txt[root@Cc 5]# chmod ug+w,o-w test.txt[root@Cc 5]# chmod u+x test.txt[root@Cc 5]# chmod -R a+r *[root@Cc 5]# chmod a-x test.txt      设置所有人可读    设置所有人可读    设置文件拥有者，其他所属群体可写入，其他用户则不能    设置该文件用者可执行    讲目录下所有文件子目录都设置为可读取    收回所有用户对test.txt执行权限  磁盘管理查看磁盘占用空间  df -ah 其中h是单位有k查看文件或者目录所占用空间  du示例[root@Cc lichaocheng]# du -sh1.9G    .[root@Cc lichaocheng]# du --max-depth=1 -h4.0K    ./vimTest78M     ./gogs181M    ./java130M    ./sonsul85M     ./rabbitmq1.2G    ./harbor6.5M    ./hugo112K    ./hf80K     ./sll11M     ./frp24K     ./file20K     ./C16M     ./frp116K     ./ssl111M    ./mongodb1.9G    .[root@Cc lichaocheng]#  统计大小  按照层级文件大小一些冷门命令  tune2fs（调整查看文件系统参数）  mkfs（格式化文件系统）挂在/卸载文件系统  mount 如果在 windows、mac 、或者自己电脑装了 linux 就可以使用到这个命令，这个只给你看下帮助文档[root@Cc lichaocheng]# mount --help;用法： mount [-lhV] mount -a [选项] mount [选项] [--source] &lt;源&gt; | [--target] &lt;目录&gt; mount [选项] &lt;源&gt; &lt;目录&gt; mount &lt;操作&gt; &lt;挂载点&gt; [&lt;目标&gt;]选项： -a, --all               挂载 fstab 中的所有文件系统 -c, --no-canonicalize   不对路径规范化 -f, --fake              空运行；跳过 mount(2) 系统调用 -F, --fork              对每个设备禁用 fork(和 -a 选项一起使用) -T, --fstab &lt;路径&gt;      /etc/fstab 的替代文件 -h, --help              显示此帮助并退出 -i, --internal-only     不调用 mount.&lt;类型&gt; 助手程序 -l, --show-labels       列出所有带有指定标签的挂载 -n, --no-mtab           不写 /etc/mtab -o, --options &lt;列表&gt;    挂载选项列表，以英文逗号分隔 -O, --test-opts &lt;列表&gt;  限制文件系统集合(和 -a 选项一起使用) -r, --read-only         以只读方式挂载文件系统(同 -o ro) -t, --types &lt;列表&gt;      限制文件系统类型集合     --source &lt;源&gt;       指明源(路径、标签、uuid)     --target &lt;目标&gt;     指明挂载点 -v, --verbose           打印当前进行的操作 -V, --version           显示版本信息并退出 -w, --rw, --read-write  以读写方式挂载文件系统(默认) -h, --help     显示此帮助并退出 -V, --version  输出版本信息并退出源： -L, --label &lt;标签&gt;      同 LABEL=&lt;label&gt; -U, --uuid &lt;uuid&gt;       同 UUID=&lt;uuid&gt; LABEL=&lt;标签&gt;            按文件系统标签指定设备 UUID=&lt;uuid&gt;             按文件系统 UUID 指定设备 PARTLABEL=&lt;标签&gt;        按分区标签指定设备 PARTUUID=&lt;uuid&gt;         按分区 UUID 指定设备 &lt;设备&gt;                  按路径指定设备 &lt;目录&gt;                  绑定挂载的挂载点(参阅 --bind/rbind) &lt;文件&gt;                  用于设置回环设备的常规文件操作： -B, --bind              挂载其他位置的子树(同 -o bind) -M, --move              将子树移动到其他位置 -R, --rbind             挂载其他位置的子树及其包含的所有挂载 --make-shared           将子树标记为 共享 --make-slave            将子树标记为 从属 --make-private          将子树标记为 私有 --make-unbindable       将子树标记为 不可绑定 --make-rshared          递归地将整个子树标记为 共享 --make-rslave           递归地将整个子树标记为 从属 --make-rprivate         递归地将整个子树标记为 私有 --make-runbindable      递归地将整个子树标记为 不可绑定基本磁盘管理  fdisk 类似 windows 下 PQMagic 工具 ，这个只给帮助文档[root@Cc lichaocheng]# fdisk --helpfdisk：无效选项 -- -用法： fdisk [选项] &lt;磁盘&gt;    更改分区表 fdisk [选项] -l &lt;磁盘&gt; 列出分区表 fdisk -s &lt;分区&gt;        给出分区大小(块数)选项： -b &lt;大小&gt;             扇区大小(512、1024、2048或4096) -c[=&lt;模式&gt;]           兼容模式：“dos”或“nondos”(默认) -h                    打印此帮助文本 -u[=&lt;单位&gt;]           显示单位：“cylinders”(柱面)或“sectors”(扇区，默认) -v                    打印程序版本 -C &lt;数字&gt;             指定柱面数 -H &lt;数字&gt;             指定磁头数 -S &lt;数字&gt;             指定每个磁道的扇区数交换空间管理磁盘冗余阵列 RAID监控硬盘空间（shell）是个联系暂时不写#!/bin/shfunction LOG(){\techo \"用于记录执行日志\"}function sendmsg(){\techo \"告警发生详细\"}function process(){\techo \"主处理逻辑\"}function main(){\tprocess}LOG \"process start\"mainLOG \"process end\""
  },
  
  {
    "title": "linux(CentOS7) 目录管理、系统管理",
    "url": "/posts/4.5-RedHad-system/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-25 23:48:12 +0800",
    





    
    "snippet": "目录管理命令nkdri  指定权限创建  -p递归创建[root@Cc 20200326]# mkdir -m777 mkdira[root@Cc 20200326]# ll总用量 8drwxrwxrwx 2 root root 4096 3月  25 22:52 mkdiradrwxr-xr-x 2 root root 4096 3月  25 22:39 pwd[root@Cc 20200...",
    "content": "目录管理命令nkdri  指定权限创建  -p递归创建[root@Cc 20200326]# mkdir -m777 mkdira[root@Cc 20200326]# ll总用量 8drwxrwxrwx 2 root root 4096 3月  25 22:52 mkdiradrwxr-xr-x 2 root root 4096 3月  25 22:39 pwd[root@Cc 20200326]#rmdir  删除ls  ls -lk k、h 为 k、M、G  大小显示排序[root@Cc lichaocheng]#  ls -lhS总用量 31M-rw-r--r-- 1 root  root   25M 11月  7 23:31 gogs_0.11.91_linux_amd64.tar.gz-rw-r--r-- 1 root  root  5.8M 2月  26 09:29 hugo.filepartdrwxr-xr-x 2 root  root  4.0K 2月   7 12:51 Cdrwxr-xr-x 3 root  root  4.0K 12月 17 11:31 filedrwxr-xr-x 3 root  root  4.0K 1月  17 17:34 frpdrwxr-xr-x 2 root  root  4.0K 11月 13 10:37 frp1drwxr-xr-x 8 admin admin 4.0K 1月  16 16:54 gogsdrwxr-xr-x 3 root  root  4.0K 11月 28 20:26 harbordrwxr-xr-x 2 root  root  4.0K 12月 19 15:54 hfdrwxr-xr-x 3 root  root  4.0K 2月  28 23:03 hugopwd  当前目录cd  cd -  cd /roottree  查看目录tar  打包不压缩[root@Cc tar]# tar -cvf tarTest.txt.tar tarTest.txttarTest.txt[root@Cc tar]# ll总用量 16drwxr-xr-x 2 root root  4096 3月  25 22:59 lcc-rw-r--r-- 1 root root     0 3月  25 23:01 tarTest.txt-rw-r--r-- 1 root root 10240 3月  25 23:01 tarTest.txt.tar[root@Cc tar]#  打包并使用 gzip 压缩[root@Cc tar]# tar -zcvf tarTest.txt.tar.gz ./lcc/./lcc/./lcc/b./lcc/a[root@Cc tar]# ll总用量 20drwxr-xr-x 2 root root  4096 3月  25 22:59 lcc-rw-r--r-- 1 root root     0 3月  25 23:01 tarTest.txt-rw-r--r-- 1 root root 10240 3月  25 23:01 tarTest.txt.tar-rw-r--r-- 1 root root   144 3月  25 23:02 tarTest.txt.tar.gz[root@Cc tar]#  使用 bzip2[root@Cc tar]# tar -jcvf tarTest.txt.tar.bz2 ./lcc/./lcc/./lcc/b./lcc/atar (child): bzip2：无法 exec: 没有那个文件或目录tar (child): Error is not recoverable: exiting nowtar: Child returned status 2tar: Error is not recoverable: exiting now[root@Cc tar]# ll总用量 20drwxr-xr-x 2 root root  4096 3月  25 22:59 lcc-rw-r--r-- 1 root root     0 3月  25 23:01 tarTest.txt-rw-r--r-- 1 root root 10240 3月  25 23:01 tarTest.txt.tar-rw-r--r-- 1 root root     0 3月  25 23:04 tarTest.txt.tar.bz2-rw-r--r-- 1 root root   144 3月  25 23:02 tarTest.txt.tar.gz[root@Cc tar]#  查看当前压缩包[root@Cc tar]# tar -ztvf tarTest.txt.tar.gzdrwxr-xr-x root/root         0 2020-03-25 22:59 ./lcc/-rw-r--r-- root/root         0 2020-03-25 22:59 ./lcc/b-rw-r--r-- root/root         0 2020-03-25 22:59 ./lcc/a[root@Cc tar]#  解压之中指定文件[root@Cc tar]# rm -rf lcc/[root@Cc tar]# ll总用量 16-rw-r--r-- 1 root root     0 3月  25 23:01 tarTest.txt-rw-r--r-- 1 root root 10240 3月  25 23:01 tarTest.txt.tar-rw-r--r-- 1 root root     0 3月  25 23:05 tarTest.txt.tar.bz2-rw-r--r-- 1 root root   144 3月  25 23:02 tarTest.txt.tar.gz[root@Cc tar]# tar -zxvf tarTest.txt.tar.gz ./lcc/b./lcc/b[root@Cc tar]# tree.├── lcc│   └── b├── tarTest.txt├── tarTest.txt.tar├── tarTest.txt.tar.bz2└── tarTest.txt.tar.gz1 directory, 5 files[root@Cc tar]#  保留文件属性[root@Cc tar]# tar -zxvpf tarTest.txt.tar.gz ./lcc/  排除某些文件tar --exclude /home/*log -zcvf tarTest.txt.tar.gz ./lcc/zip/uzipgzip/gunzipbzip2/bunzip2以上三种自己百度谷歌，我有时间会补上去系统管理man  可以查看 yum 命令手册，按 q 退出[root@Cc system]# man -c您需要什么手册页？[root@Cc system]# man yumexport（导出环境变量）  修改 go 环境变量为例[root@Cc system]# go env |grep GOPATHGOPATH=\"/opt/gopath\"[root@Cc system]# export GOPATH=\"/root\"[root@Cc system]# go env |grep GOPATHGOPATH=\"/root\"[root@Cc system]# export GOPATH=\"/opt/gopath\"  export -n          删除指定变量      history（查看历史）  将当前写入到文件[root@Cc history]# history -w history.txt  清楚当前 historyhistory -c  删除所有历史命令[root@Cc history]# rm -rf ~/.bash_history[root@Cc history]# history -c  可以配合history |grep [docker]查找date(时间操作)  不让费时间了clear(清除屏幕)  ctrl + luptime(查看系统负载)[root@Cc history]# uptime 23:33:15 up 5 days, 14:18,  2 users,  load average: 0.21, 0.32, 0.31[root@Cc history]#free(显示系统内存状况)[root@Cc history]# free -mdd(转换或者复制)  百度 填补任务管理at(单词任务)  指定时间输入到文件内部[root@Cc history]# at 17:20 tomorrowcrond(周期任务)  TODO 找时间填补关机命令shutdown (关机)haltreboot(重启)poweroff(终止系统运行)init(改变系统允许级别)  0 停机  1 单用户模式  2 多用户模式  3 完全多用户模式  4 么有用到  5 X11  6 重新启动          配置 /etc/inittab      文本操作  vi  vim最后总结（个人 shell）  用所学的 shell 备份重要的文件目录下次补上"
  },
  
  {
    "title": "linux(CentOS7) 目录结构",
    "url": "/posts/4.4-RedHad-dir/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-24 23:17:54 +0800",
    





    
    "snippet": "linux 目录结构            目录      功能说明                  /      根目录，整个文件系统的起点，包含所有其他目录和文件              /bin      存放基本的用户命令，如 ls、cp、mv、rm 等              /boot      启动加载器相关的文件，如内核镜像（vmlinuz）、初始化 RAM 磁盘镜像（...",
    "content": "linux 目录结构            目录      功能说明                  /      根目录，整个文件系统的起点，包含所有其他目录和文件              /bin      存放基本的用户命令，如 ls、cp、mv、rm 等              /boot      启动加载器相关的文件，如内核镜像（vmlinuz）、初始化 RAM 磁盘镜像（initrd）              /dev      设备文件目录，包含各种设备的接口文件              /etc      系统配置文件和脚本，如网络配置文件、服务配置文件、用户账户信息等              /home      用户主目录，如 /home/username，每个用户的个人文件存放于此              /lib      系统程序使用的共享库文件和内核模块              /media      挂载点，用于临时挂载可移动媒体，如 CD-ROM、USB 存储设备              /mnt      挂载点，用于临时挂载文件系统              /opt      用于安装附加软件包或应用程序              /proc      虚拟文件系统，提供系统进程和内核信息，如 /proc/cpuinfo、/proc/meminfo              /root      超级用户（root 用户）的主目录              /run      存放系统运行时的数据，如进程 ID 文件和套接字文件              /sbin      系统管理命令和守护进程程序，如 ifconfig、reboot、shutdown              /srv      存放特定服务相关的数据，如 HTTP、FTP 服务的数据              /sys      虚拟文件系统，提供与硬件和内核模块相关的信息和接口              /tmp      临时文件目录，系统重启后通常会清空              /usr      用户级程序和数据，如二进制文件（/usr/bin）、库文件（/usr/lib）、头文件（/usr/include）、文档（/usr/share/doc）等              /var      可变数据文件，如日志文件（/var/log）、缓存文件（/var/cache）、邮件（/var/mail）等      常用命令cp[root@Cc RedHad]#  cp /etc/nginx/conf.d/default.conf .[root@Cc RedHad]# ll总用量 4-rw-r--r-- 1 root root 750 3月  24 22:17 default.conf[root@Cc RedHad]#cp –help[root@Cc RedHad]# cp --help;用法：cp [选项]... [-T] 源文件 目标文件　或：cp [选项]... 源文件... 目录　或：cp [选项]... -t 目录 源文件...Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.Mandatory arguments to long options are mandatory for short options too.  -a, --archive                 等于-dR --preserve=all      --attributes-only 仅复制属性而不复制数据      --backup[=CONTROL           为每个已存在的目标文件创建备份  -b                            类似--backup 但不接受参数      --copy-contents           在递归处理是复制特殊文件内容  -d                            等于--no-dereference --preserve=links  -f, --force                  if an existing destination file cannot be                                 opened, remove it and try again (this option                                 is ignored when the -n option is also used)  -i, --interactive            prompt before overwrite (overrides a previous -n                                  option)  -H                           follow command-line symbolic links in SOURCE  -l, --link                   hard link files instead of copying  -L, --dereference            always follow symbolic links in SOURCE  -n, --no-clobber              不要覆盖已存在的文件(使前面的 -i 选项失效)  -P, --no-dereference          不跟随源文件中的符号链接  -p                            等于--preserve=模式,所有权,时间戳      --preserve[=属性列表      保持指定的属性(默认：模式,所有权,时间戳)，如果                                        可能保持附加属性：环境、链接、xattr 等  -c                           deprecated, same as --preserve=context      --sno-preserve=属性列表   不保留指定的文件属性      --parents                 复制前在目标目录创建来源文件路径中的所有目录  -R, -r, --recursive           递归复制目录及其子目录内的所有内容      --reflink[=WHEN]          控制克隆/CoW 副本。请查看下面的内如。      --remove-destination      尝试打开目标文件前先删除已存在的目的地                                        文件 (相对于 --force 选项)      --sparse=WHEN             控制创建稀疏文件的方式      --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠  -s, --symbolic-link           只创建符号链接而不复制文件  -S, --suffix=后缀             自行指定备份文件的后缀  -t,  --target-directory=目录  将所有参数指定的源文件/目录                                           复制至目标目录  -T, --no-target-directory     将目标目录视作普通文件  -u, --update                  只在源文件比目标文件新，或目标文件                                        不存在时才进行复制  -v, --verbose         显示详细的进行步骤  -x, --one-file-system 不跨越文件系统进行操作  -Z                           set SELinux security context of destination                                 file to default type      --context[=CTX]          like -Z, or if CTX is specified then set the                                 SELinux or SMACK security context to CTX      --help            显示此帮助信息并退出      --version         显示版本信息并退出默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件也被为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用--sparse=always 参数则不论源文件是否包含足够长的0 序列也将目标文件创文建为稀疏件。使用--sparse=never 参数禁止创建稀疏文件。当指定了--reflink[=always] 参数时执行轻量化的复制，即只在数据块被修改的情况下才复制。如果复制失败或者同时指定了--reflink=auto，则返回标准复制模式。The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.The version control method may be selected via the --backup option or throughthe VERSION_CONTROL environment variable.  Here are the values:  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份操作示例[root@Cc cp]# tree.├── file1│   └── file1.txt├── file2│   ├── file2.exe│   └── file2.txt└── file33 directories, 3 files[root@Cc cp]#复制多个文件[root@Cc cp]# cp -v file1/file1.txt  file2/file2.txt file3\"file1/file1.txt\" -&gt; \"file3/file1.txt\"\"file2/file2.txt\" -&gt; \"file3/file2.txt\"[root@Cc cp]# tree.├── file1│   └── file1.txt├── file2│   ├── file2.exe│   └── file2.txt└── file3    ├── file1.txt    └── file2.txt3 directories, 5 files[root@Cc cp]#复制文件夹[root@Cc cp]# cp -rv file3 file5[root@Cc cp]# tree.├── file1│   └── file1.txt├── file2│   ├── file2.exe│   └── file2.txt├── file3│   ├── file1.txt│   └── file2.txt└── file5    └── file3        ├── file1.txt        └── file2.txt5 directories, 7 files[root@Cc cp]#保留属性复制[root@Cc cp]# cp -a /etc/nginx/conf.d/default.conf .[root@Cc cp]# ll总用量 20-rw-r--r-- 1 root root  750 3月  23 11:51 default.confdrwxr-xr-x 2 root root 4096 3月  24 22:21 file1drwxr-xr-x 2 root root 4096 3月  24 22:22 file2drwxr-xr-x 2 root root 4096 3月  24 22:23 file3drwxr-xr-x 3 root root 4096 3月  24 22:25 file5并不复制本身，而是创建软链接  注释：修改软链接文件 本身文件也跟着改变[root@Cc cp]# ll总用量 20-rw-r--r-- 1 root root  750 3月  23 11:51 default.confdrwxr-xr-x 2 root root 4096 3月  24 22:21 file1drwxr-xr-x 2 root root 4096 3月  24 22:22 file2drwxr-xr-x 2 root root 4096 3月  24 22:23 file3drwxr-xr-x 3 root root 4096 3月  24 22:25 file5lrwxrwxrwx 1 root root   12 3月  24 22:31 testCP_S -&gt; default.conf[root@Cc cp]# cat testCP_Sserver {      listen 443 ssl default;  # 1.1版本后这样写      server_name lichaocheng.top; #填写绑定证书的域名      ssl_certificate  /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.pem;  # 指定证书的位置，绝对路径      ssl_certificate_key /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.key;  # 绝对路径，同上      ssl_session_timeout 5m;      ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置      ssl_prefer_server_ciphers on;      location / {          root   /opt/lichaocheng.top/lichaocheng.top; #站点目录，绝对路径          index  index.html index.htm;    }}[root@Cc cp]# cat default.confserver {      listen 443 ssl default;  # 1.1版本后这样写      server_name lichaocheng.top; #填写绑定证书的域名      ssl_certificate  /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.pem;  # 指定证书的位置，绝对路径      ssl_certificate_key /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.key;  # 绝对路径，同上      ssl_session_timeout 5m;      ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置      ssl_prefer_server_ciphers on;      location / {          root   /opt/lichaocheng.top/lichaocheng.top; #站点目录，绝对路径          index  index.html index.htm;    }}[root@Cc cp]#mvmv –help[root@Cc cp]# mv --help用法：mv [选项]... [-T] 源文件 目标文件　或：mv [选项]... 源文件... 目录　或：mv [选项]... -t 目录 源文件...Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.Mandatory arguments to long options are mandatory for short options too.      --backup[=CONTROL]       为每个已存在的目标文件创建备份  -b                           类似--backup 但不接受参数  -f, --force                  覆盖前不询问  -i, --interactive            覆盖前询问  -n, --no-clobber             不覆盖已存在文件如果您指定了-i、-f、-n 中的多个，仅最后一个生效。      --strip-trailing-slashes  去掉每个源文件参数尾部的斜线  -S, --suffix=SUFFIX           替换常用的备份文件后缀  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY  -T, --no-target-directory    treat DEST as a normal file  -u, --update                 move only when the SOURCE file is newer                                 than the destination file or when the                                 destination file is missing  -v, --verbose                explain what is being done  -Z, --context                set SELinux security context of destination                                 file to default type      --help            显示此帮助信息并退出      --version         显示版本信息并退出  none, off       不进行备份(即使使用了--backup 选项)  numbered, t     备份文件加上数字进行排序  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备份  simple, never   永远使用普通方式备份[root@Cc cp]#touchtouch –help[root@Cc cp]# touch --help;用法：touch [选项]... 文件...  -a                    只更改访问时间  -c, --no-create       不创建任何文件  -d, --date=字符串     使用指定字符串表示时间而非当前时间  -f                    (忽略)  -h, --no-dereference          会影响符号链接本身，而非符号链接所指示的目的地                                (当系统支持更改符号链接的所有者时，此选项才有用)  -m                    只更改修改时间  -r, --reference=FILE   use this file's times instead of current time  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time      --time=WORD        change the specified time:                           WORD is access, atime, or use: equivalent to -a                           WORD is modify or mtime: equivalent to -m      --help            显示此帮助信息并退出      --version         显示版本信息并退出请注意，-d 和-t 选项可接受不同的时间/日期格式。示例  时间格式[CCYYMMDDhhmm]touch -t \"01231215\" t3  CC 年份前两位  YY 年份后两位  MM 月  DD 天  hh 时  mm 分          一位数 0 补全      [root@Cc touch]# touch t1[root@Cc touch]# stat t1  文件：\"t1\"  大小：0               块：0          IO 块：4096   普通空文件设备：fd01h/64769d      Inode：668181      硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-24 22:44:43.908405308 +0800最近更改：2020-03-24 22:44:43.908405308 +0800最近改动：2020-03-24 22:44:43.908405308 +0800创建时间：-[root@Cc touch]# date2020年 03月 24日 星期二 22:49:18 CST[root@Cc touch]#[root@Cc touch]#[root@Cc touch]# touch -d \"2 day ago\" t1[root@Cc touch]# stat t1  文件：\"t1\"  大小：0               块：0          IO 块：4096   普通空文件设备：fd01h/64769d      Inode：668185      硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-03-22 22:49:50.941398201 +0800最近更改：2020-03-22 22:49:50.941398201 +0800最近改动：2020-03-24 22:49:50.941121499 +0800创建时间：-[root@Cc touch]# date2020年 03月 24日 星期二 22:50:01 CST[root@Cc touch]# touch -t \"01231215\" t3[root@Cc touch]# stat t3  文件：\"t3\"  大小：0               块：0          IO 块：4096   普通空文件设备：fd01h/64769d      Inode：668187      硬链接：1权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)最近访问：2020-01-23 12:15:00.000000000 +0800最近更改：2020-01-23 12:15:00.000000000 +0800最近改动：2020-03-24 22:50:53.180699023 +0800创建时间：-[root@Cc touch]#rmrm –help[root@Cc touch]# rm --help;用法：rm [选项]... 文件...Remove (unlink) the FILE(s).  -f, --force           ignore nonexistent files and arguments, never prompt  -i                    prompt before every removal  -I                    prompt once before removing more than three files, or                          when removing recursively; less intrusive than -i,                          while still giving protection against most mistakes      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or                          always (-i); without WHEN, prompt always      --one-file-system         递归删除一个层级时，跳过所有不符合命令行参                                数的文件系统上的文件      --no-preserve-root  do not treat '/' specially      --preserve-root   do not remove '/' (default)  -r, -R, --recursive   remove directories and their contents recursively  -d, --dir             remove empty directories  -v, --verbose         explain what is being done      --help            显示此帮助信息并退出      --version         显示版本信息并退出默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定的目录，以及其下所有的内容。To remove a file whose name starts with a '-', for example '-foo',use one of these commands:  rm -- -foo  rm ./-foo请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证该文件的内容无法还原，请考虑使用shred。查看文件  cat[root@Cc touch]# cat --help用法：cat [选项]... [文件]...将[文件]或标准输入组合输出到标准输出。  -A, --show-all           等于-vET  -b, --number-nonblank    对非空输出行编号  -e                       等于-vE  -E, --show-ends          在每行结束处显示\"$\"  -n, --number             对输出的所有行编号  -s, --squeeze-blank      不输出多行空行  -t                       与-vT 等价  -T, --show-tabs          将跳格字符显示为^I  -u                       (被忽略)  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外      --help            显示此帮助信息并退出      --version         显示版本信息并退出如果没有指定文件，或者文件为\"-\"，则从标准输入读取。示例：  cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。  cat        将标准输入的内容复制到标准输出。  tac[root@Cc touch]# tac --help用法：tac [选项]... [文件]...Write each FILE to standard output, last line first.With no FILE, or when FILE is -, read standard input.Mandatory arguments to long options are mandatory for short options too.  -b, --before                  在行前而非行尾添加分隔标志  -r, --regex                   将分隔标志视作正则表达式来解析  -s, --separator=字符串        使用指定字符串代替换行作为分隔标志      --help            显示此帮助信息并退出      --version         显示版本信息并退出  more[root@Cc touch]# more --helpmore: 未知选项 -help用法：more [选项] 文件...选项：  -d        显示帮助，而不是响铃  -f        统计逻辑行数而不是屏幕行数  -l        抑制换页(form feed)后的暂停  -p        不滚屏，清屏并显示文本  -c        不滚屏，显示文本并清理行尾  -u        抑制下划线  -s        将多个空行压缩为一行  -NUM      指定每屏显示的行数为 NUM  +NUM      从文件第 NUM 行开始显示  +/STRING  从匹配搜索字符串 STRING 的文件位置开始显示  -V        输出版本信息并退出[root@Cc touch]#  less这个好长  tac[root@Cc touch]# tac --help用法：tac [选项]... [文件]...  -b, --before                  在行前而非行尾添加分隔标志  -r, --regex                   将分隔标志视作正则表达式来解析  -s, --separator=字符串        使用指定字符串代替换行作为分隔标志      --help            显示此帮助信息并退出      --version         显示版本信息并退出  tail[root@Cc touch]# tail -n 3 ../cp/default.conf          index  index.html index.htm;    }}// 最后三行find[root@Cc ~]# find --help用法: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]默认路径为当前目录；默认表达式为 -print表达式可能由下列成份组成：操作符、选项、测试表达式以及动作：操作符 (优先级递减；未做任何指定时默认使用 -and):      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2比较测试 (N 可以是 +N 或 -N 或 N): -amin N -anewer FILE -atime N -cmin N      -cnewer 文件 -ctime N -empty -false -fstype 类型 -gid N -group 名称      -ilname 匹配模式 -iname 匹配模式 -inum N -ipath 匹配模式 -iregex 匹配模式      -links N -lname 匹配模式 -mmin N -mtime N -name 匹配模式 -newer 文件      -nouser -nogroup -path PATTERN -perm [-/]MODE -regex PATTERN      -readable -writable -executable      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N      -used N -user NAME -xtype [bcdpfls]      -context 文本操作: -delete -print0 -printf 格式 -fprintf 文件 格式 -print      -fprint0 文件 -fprint 文件 -ls -fls 文件 -prune -quit      -exec 命令 ; -exec 命令 {} + -ok 命令 ;      -execdir 命令 ; -execdir 命令 {} + -okdir 命令 ;文本文本操作  grep 过滤  diff 比较文件差异  ln 文件目录之间创建链接  file [文件或者文件夹] 显示类型  split 分割  join 合并  umask 文件权限把权限拿出来细讲下  unmask 范围[000~777]  r - 4 - 读  w - 2 - 写  x - 1 - 执行计算如下  最大权限 777 读、写、执行权限  当前环境 umask 值 ，系统为 002  对于当前目录，根据互补原则目录权限 755。而文件默认没有执行权限，最大 666，对应的权限 644          文件默认权限 666-022=644，目录默认权限 777-022=755      [root@Cc nmask]# umask0022[root@Cc nmask]# touch file;mkdir dir[root@Cc nmask]# ls -l总用量 4drwxr-xr-x 2 root root 4096 3月  24 23:28 dir-rw-r--r-- 1 root root    0 3月  24 23:28 file[root@Cc nmask]#目录管理"
  },
  
  {
    "title": "linux(CentOS7) 命令操作",
    "url": "/posts/4.1~4.3-RedHad-cmd/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-23 22:17:54 +0800",
    





    
    "snippet": "前言linux 系统架构  硬件  系统内核  命令解析器  上层应用程序初认命令行  [当前用户@计算机名字~]#  [当前用户@计算机名字~]$          #为 root 用户，$普通用户      [root@Cc ~]# su yf[yf@Cc root]$ su rootPassword:[root@Cc ~]#bash Shell别名  alias创建别名,unalias...",
    "content": "前言linux 系统架构  硬件  系统内核  命令解析器  上层应用程序初认命令行  [当前用户@计算机名字~]#  [当前用户@计算机名字~]$          #为 root 用户，$普通用户      [root@Cc ~]# su yf[yf@Cc root]$ su rootPassword:[root@Cc ~]#bash Shell别名  alias创建别名,unalias撤销别名[root@Cc ~]# alias cc='ls -l'[root@Cc ~]# cctotal 24drwxr-xr-x  2 root root 4096 Dec 11 22:44 Ccdrwxr-xr-x  7 root root 4096 Nov 22 19:56 FileRecvdrwxr-xr-x  5 root root 4096 Nov 28 11:45 fileWehChatdrwxr-xr-x 19 root root 4096 Mar  3 15:45 gogs-repositoriesdrwxr-xr-x 17 root root 4096 Mar 18 13:51 lichaochengdrwxr-xr-x  2 root root 4096 Mar 18 08:57 supervisord.d[root@Cc ~]# unalias cc[root@Cc ~]# cccc: fatal error: no input filescompilation terminated.[root@Cc ~]#历史命令使用      !!          上一个命令            找出特定字符命令  [root@Cc ~]# history | grep sou 1050  history | grep sou[root@Cc ~]#  ![num] 1050  history | grep sou 1051  history | grep ps 1052  ll 1053  history[root@Cc ~]# !1052lltotal 24drwxr-xr-x  2 root root 4096 Dec 11 22:44 Ccdrwxr-xr-x  7 root root 4096 Nov 22 19:56 FileRecvdrwxr-xr-x  5 root root 4096 Nov 28 11:45 fileWehChatdrwxr-xr-x 19 root root 4096 Mar  3 15:45 gogs-repositoriesdrwxr-xr-x 17 root root 4096 Mar 18 13:51 lichaochengdrwxr-xr-x  2 root root 4096 Mar 18 08:57 supervisord.d[root@Cc ~]#  通配符使用          多个字符、任意字符、范围查找、      [root@Cc ~]# ls /opt/go*/opt/gomod:Gin/opt/gopath:bin  pkg  src[root@Cc ~]#[root@Cc ~]# ls /bin/l?/bin/ld  /bin/ln  /bin/lp  /bin/ls[root@Cc ~]#[root@Cc ~]# ls [a-f]*Cc:fileWehChat:2019-09  2019-10  2019-11[root@Cc ~]# find /opt/ -name \"cc\"/opt/lichaocheng.top/lichaocheng.top.server/.git/objects/cc/opt/gopath/src/smtface/client_user_server/.git/objects/cc/opt/gopath/src/google.golang.org/grpc/.git/objects/cc/opt/client/bogl.lichaocheng.top/.git/objects/cc[root@Cc ~]#管道标准输入输出  注意 ctrl+d结束[root@Cc ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0IPADDR=172.24.40.83NETMASK=255.255.192.0ONBOOT=yesGATEWAY=172.24.63.253[root@Cc ~]# catlcclccyfyfcccc[root@Cc ~]#输入重定向[root@Cc ~]# wc&lt;  /etc/sysconfig/network-scripts/ifcfg-eth0 5  5 87[root@Cc ~]# cat&lt;  /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0IPADDR=172.24.40.83NETMASK=255.255.192.0ONBOOT=yesGATEWAY=172.24.63.253[root@Cc ~]# cat &lt;&lt;&lt;EEEEEE[root@Cc ~]#[root@Cc ~]# cat &lt;&lt;CC&gt; 第一个输入&gt; 第二个输入&gt; exit^C[root@Cc ~]# cat &lt;&lt;CC第一个输入第二个输入&gt; 第三个输入&gt; -bash: warning: here-document at line 50 delimited by end-of-file (wanted `CC')第一个输入第二个输入第三个输入  正确的值追加到文件[root@Cc ~]#[root@Cc RedHad]# lltotal 0-rw-r--r-- 1 root root 0 Mar 23 21:59 readme.md[root@Cc RedHad]# cat readme.md[root@Cc RedHad]# ls -l ./ &gt;&gt;  readme.md[root@Cc RedHad]# cat readme.mdtotal 0-rw-r--r-- 1 root root 0 Mar 23 21:59 readme.md  linux 更多重定向 百度、谷歌"
  },
  
  {
    "title": "linux(CentOS7)基础知识",
    "url": "/posts/1-3-RedHad-base/",
    "categories": "DevOps, RedHad",
    "tags": "System, RedHad",
    "date": "2020-03-23 22:17:54 +0800",
    





    
    "snippet": "linux 基础知识启动选择Red Hat 安装安装之后远程登入  查看是否启动[root@Cc ~]# ps -ef |grep sshdroot      1377     1  0 Mar20 ?        00:00:00 /usr/sbin/sshd -Droot     21020  1377  0 20:49 ?        00:00:00 sshd: root@pts...",
    "content": "linux 基础知识启动选择Red Hat 安装安装之后远程登入  查看是否启动[root@Cc ~]# ps -ef |grep sshdroot      1377     1  0 Mar20 ?        00:00:00 /usr/sbin/sshd -Droot     21020  1377  0 20:49 ?        00:00:00 sshd: root@pts/1root     21310 21022  0 21:02 pts/1    00:00:00 grep --color=auto sshd  查看 sshd 端口多少[root@Cc ~]# netstat -ntlp |grep sshdtcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1377/sshd      ssh 远程登入                  服务终端命令登陆        [root@Lgr ~]# ssh root@lichaocheng.toproot@lichaocheng.top's password:Last login: Mon Mar 23 21:04:51 2020 from 58.60.57.2Welcome to Alibaba Cloud Elastic Compute Service ![root@Cc ~]#                            可以使用工具                  xshell          FinalShell          Tabby                    linux 图像界面"
  },
  
  {
    "title": "frp 内网穿透",
    "url": "/posts/frp/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2020-03-23 13:32:25 +0800",
    





    
    "snippet": "frp 内网穿透环境准备  Linux 环境  Windows 环境  Linux 云服务 开启需要端口  Windows配置文件  *s.ini 是服务端配置文件  *c.ini 是客服端配置文件frps.ini（linux）目录结构[root@k8s-master linux]# ll总用量 11096-rwxrwxr-x 1 admin admin 11333632 1月   6 16...",
    "content": "frp 内网穿透环境准备  Linux 环境  Windows 环境  Linux 云服务 开启需要端口  Windows配置文件  *s.ini 是服务端配置文件  *c.ini 是客服端配置文件frps.ini（linux）目录结构[root@k8s-master linux]# ll总用量 11096-rwxrwxr-x 1 admin admin 11333632 1月   6 16:02 frps-rw-rw-r-- 1 admin admin     2518 1月  17 18:41 frps.ini-rw-rw---- 1 root  root      2377 1月  17 18:36 frps.log-rw-rw-r-- 1 admin admin    11358 1月   6 16:04 LICENSEdrwxrwxr-x 2 admin admin     4096 1月   6 16:04 systemd[root@k8s-master linux]#修改内容[common]# binde_addr是指定frp内网穿透服务器端监听的IP地址,默认为127.0.0.1，#如果使用IPv6地址的话，必须用方括号包括起来，比如 “[::1]:80”, “[ipv6-host]:http” or “[ipv6-host%zone]:80”bind_addr = 0.0.0.0# bind_port 是frp内网穿透服务器端监听的端口，默认是7000bind_port = 7000#frp内网穿透服务器可以支持虚拟主机的http和https协议，一般我们都用80，#可以直接用域名而不用增加端口号，如果使用其它端口，那么客户端也需要配置相同的其他端口。vhost_http_port = 8380vhost_https_port = 443dashboard_user = admin  #管理面板账号dashboard_pwd = lichaocheng   #管理面板密码# 这个是frp内网穿透服务器的web界面的端口，可以通过http://你的ip:7500查看frp内网穿透服务器端的连接情况，和各个frp内网穿透客户端的连接情况。dashboard_port = 7500auth_token = 123# 方括号内的ssh是代理名称，在同一个frp穿透服务器下的代理名称不能重复，否则不能启动。# bind_addr是frp客户端内网的ip，也可以是客户端内网同一局域网下的其他IP[ssh]##### type = tcpbind_addr = 0.0.0.0listen_port = 6000[web01]#http类型的内网穿透，必须设置vhost_http_port，并且所有的http类型的客户端都将通过同一个vhost_http_port访问。type = http# custom_domains是通过frp服务器端访问客户端的域名，必须输入完整的域名，# 并且不能是subdomain_host的子域名，否则frp服务不能启动，并且相应的域名需要解析到frp服务器端的公网IP并等待解析生效后，才可以使用。custom_domains = zhishi.com运行方式./frps -c frps.inifrpc.ini（Windows）目录结构Administrator@DESKTOP-DHQ6SHN MINGW64 ~/Desktop/fsdownload/frp_windows_amd64/frp_0.29.1_windows_amd64$ lltotal 21230-rwxr-xr-x 1 Administrator 197121 10482688 11月  2 21:22 frpc.exe*-rw-r--r-- 1 Administrator 197121      126 11月  2 21:25 frpc.ini-rw-r--r-- 1 Administrator 197121     7042 11月  2 21:25 frpc_full.ini-rwxr-xr-x 1 Administrator 197121 11220480 11月  2 21:23 frps.exe*-rw-r--r-- 1 Administrator 197121       26 11月  2 21:25 frps.ini-rw-r--r-- 1 Administrator 197121     2365 11月  2 21:25 frps_full.ini-rw-r--r-- 1 Administrator 197121    11358 11月  2 21:25 LICENSEdrwxr-xr-x 1 Administrator 197121        0 11月  2 21:25 systemd/Administrator@DESKTOP-DHQ6SHN MINGW64 ~/Desktop/fsdownload/frp_windows_amd64/frp_0.29.1_windows_amd64修改内容[common]server_addr = 60.205.176.110server_port = 7000auth_token = 123[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 6000[web01]#http类型的内网穿透，必须设置vhost_http_port，#并且所有的http类型的客户端都将通过同一个vhost_http_port访问。type = httplocal_ip = 127.0.0.1local_port = 8380custom_domains = web.zhishi.com运行方式./frpc.exe -c frpc.ininginx 代理域名映射server{    listen 80;    server_name frp.lichaocheng.top;    location / {        proxy_pass http://0.0.0.0:9000;    }}"
  },
  
  {
    "title": "Kubernetes概述",
    "url": "/posts/k8sBase/",
    "categories": "DevOps, Kubernetes",
    "tags": "LinuxTool, Kubernetes",
    "date": "2020-03-22 22:00:00 +0800",
    





    
    "snippet": "Kubernetes简介Kubernetes 是用于自动化容器操作的开源平台。它允许开发者在多个主机上部署、运行和管理容器化应用程序，并提供了一致性、可扩展性和弹性等方面的保障。Kubernetes 的设计目标是实现跨不同主机和云环境的容器编排。它可以运行在所有主流的云平台和数据中心中，包括 Amazon Web Services（AWS）、Microsoft Azure、Google Cl...",
    "content": "Kubernetes简介Kubernetes 是用于自动化容器操作的开源平台。它允许开发者在多个主机上部署、运行和管理容器化应用程序，并提供了一致性、可扩展性和弹性等方面的保障。Kubernetes 的设计目标是实现跨不同主机和云环境的容器编排。它可以运行在所有主流的云平台和数据中心中，包括 Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Platform（GCP）等。Kubernetes 不仅支持 Docker 容器，还支持其他容器运行时，如 rkt、CRI-O 等。Kubernetes 可以帮助开发者简化容器应用程序的部署、扩展和管理。它提供了以下功能：      调度：Kubernetes 使用调度器将容器调度到适当的节点上运行，从而实现负载均衡和资源利用率最大化。        自动伸缩：Kubernetes 可以根据容器的 CPU 利用率、内存使用情况或自定义指标来自动缩放容器数量。        自我修复：Kubernetes 监控容器的运行状态，并自动恢复失败的容器或节点。        滚动更新：Kubernetes 支持滚动更新容器，可以逐步将新版本的容器推出并停止旧版本的容器，从而实现无缝更新。        服务发现：Kubernetes 提供了内置的服务发现机制，可以根据服务名称和端口号自动路由请求到正确的容器。        存储管理：Kubernetes 支持多种存储类型，包括本地存储、网络存储和云存储等。        配置管理：Kubernetes 可以管理应用程序的配置文件，例如环境变量、命令行参数和配置文件等。        安全：Kubernetes 提供了多种安全机制，如 RBAC（基于角色的访问控制）、证书管理和网络策略等，保障容器化应用程序的安全性。  Kubernetes 的核心组件包括：      Kubernetes API Server：所有其他 Kubernetes 组件都与 API Server 交互，通过 API Server 操作集群状态。        etcd：分布式键值存储系统，用于存储 Kubernetes 集群的配置信息。        Kubernetes Controller Manager：监控集群的状态，并确保集群中的对象一直处于期望的状态。        Kubernetes Scheduler：根据容器的资源需求和可用性，将容器调度到可用的节点上运行。        kubelet：在每个节点上运行，负责管理该节点上的容器。        kube-proxy：在每个节点上运行，用于实现 Kubernetes 服务的负载均衡和网络代理。  Kubernetes 还包括其他组件，如 Dashboard、Helm 等，用于管理和监控 Kubernetes 集群。Kubernetes 你能做什么Kubernetes 可以在许多场景下使用，以下是一些常见的 Kubernetes 使用场景：      微服务架构：Kubernetes 提供了服务发现、自动负载均衡和容器编排等功能，可以帮助开发者构建和管理微服务架构，并实现微服务间的通信。        云原生应用程序：Kubernetes 是云原生应用程序开发的核心平台，它提供了可靠性、弹性和可扩展性等特性，有助于简化应用程序的部署和管理。        持续集成/持续交付（CI/CD）：Kubernetes 可以与 CI/CD 工具集成，从而实现自动化的应用程序构建、测试、部署和扩展等流程。        大数据处理：Kubernetes 可以帮助管理大量的计算任务，例如 Hadoop 和 Spark 等分布式计算框架。        IoT 应用程序：Kubernetes 可以帮助管理 IoT 设备和传感器产生的数据，例如通过容器化运行 MQTT 和 CoAP 流媒体协议。        边缘计算：Kubernetes 可以将应用程序部署到边缘节点上，从而实现对设备和传感器生成的数据的即时响应。  Kubernetes 特点Kubernetes 是一个强大的容器编排平台，具有以下特点：      可扩展性：Kubernetes 支持从单一节点到数千个节点的集群规模，并支持跨多个云供应商和数据中心的部署。        独立于基础设施：Kubernetes 可以运行在任何基础设施上，包括公共云、私有云和裸金属环境等。        自动化：Kubernetes 可以自动化部署、扩展、升级和恢复容器应用程序，从而降低了人工干预的需要。        服务发现和负载均衡：Kubernetes 可以帮助管理服务发现和负载均衡，从而实现容器应用程序的可靠性和弹性。        存储管理：Kubernetes 提供了多种存储类型，包括本地存储、网络存储和云存储等，可以轻松管理容器化应用程序的存储需求。        安全性：Kubernetes 提供了多种安全机制，如 RBAC（基于角色的访问控制）、证书管理和网络策略等，保障容器化应用程序的安全性。        多种工具和插件：Kubernetes 生态系统中有许多工具和插件，例如 Helm、Istio 和 Prometheus 等，可以帮助开发者更好地管理和监控容器化应用程序。  "
  },
  
  {
    "title": "Nginx 安装",
    "url": "/posts/Nginx-install/",
    "categories": "DevOps, Nginx",
    "tags": "Tools",
    "date": "2020-03-11 22:23:04 +0800",
    





    
    "snippet": "linux 命令安装1.添加Nginx到YUM源添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令:sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm2.安装Nginx在你的CentOS 7 服务器中使用yum命令从...",
    "content": "linux 命令安装1.添加Nginx到YUM源添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令:sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm2.安装Nginx在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx：sudo yum install -y nginxNginx将完成安装在你的CentOS 7 服务器中。3.启动Nginx刚安装的Nginx不会自行启动。运行Nginx:sudo systemctl start nginx.service配置CentOS 7 开机启动Nginxsudo systemctl enable nginx.service更多systemctl命令可查看《systemctl命令用法》Nginx配置信息网站文件存放默认目录`/usr/share/nginx/html`网站默认站点配置`/etc/nginx/conf.d/default.conf`自定义Nginx站点配置文件存放目录`/etc/nginx/conf.d/`Nginx全局配置`/etc/nginx/nginx.conf`Nginx启动`nginx -c nginx.conf`在这里你可以改变设置用户运行Nginx守护程序进程一样,和工作进程的数量得到了`Nginx`正在运行,等等。Linux查看公网IP您可以运行以下命令来显示你的服务器的公共IP地址:`ip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\\/.*$//'`基本命令重载配置nginx -s reloadsudo /etc/init.d/nginx {start|restart|stop}基本命令nginx -s    [***]            stop：快速关闭            quit：安全关闭            reload：重载配置文件            reopen：重新打开一个log文件，用于日志切割"
  },
  
  {
    "title": "Nginx配置",
    "url": "/posts/Nginx-conf/",
    "categories": "DevOps, Nginx",
    "tags": "Tools",
    "date": "2020-03-11 22:23:04 +0800",
    





    
    "snippet": "配置 httpsserver {    listen 443 ssl;  # 1.1版本后这样写    server_name lichaocheng.top; #填写绑定证书的域名    ssl_certificate  /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.pem;  # 指定证书的位置，绝对路径    ssl_...",
    "content": "配置 httpsserver {    listen 443 ssl;  # 1.1版本后这样写    server_name lichaocheng.top; #填写绑定证书的域名    ssl_certificate  /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.pem;  # 指定证书的位置，绝对路径    ssl_certificate_key /opt/lichaocheng.top/lichaocheng.top/sll/lichaocheng.top.key;  # 绝对路径，同上    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;    location / {        root   /opt/lichaocheng.top/lichaocheng.top; #站点目录，绝对路径        index  index.html index.htm;    }}server {    listen 443 ssl;  # 1.1版本后这样写    server_name hr.lichaocheng.top; #填写绑定证书的域名    ssl_certificate  /opt/client/hrclient/office/sll/hr.lichaocheng.top.pem;    ssl_certificate_key  /opt/client/hrclient/office/sll/hr.lichaocheng.top.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;    location / {        root   /opt/client/hrclient/office/office; #站点目录，绝对路径        index  index.html index.htm;    }}配置 httpserver{        listen 80;        server_name www.lichaocheng.top;        location / {                root /opt/gopath/src/Cc360428/lichaocheng.top;                index index.html index.htm;                #proxy_pass http://127.0.0.1:80;        }}http 强制 httpsserver{    listen 80;    server_name  lichaocheng.top;    rewrite ^(.*)$   https://$host$1 permanent;}https 转发内部接口/opt/gopath/src/GolangCodeFile/hrBeegoServer/confserver{    listen 443 ssl ;    server_name hrapi.lichaocheng.top;    ssl_certificate  /opt/gopath/src/GolangCodeFile/hrBeegoServer/conf/hrapi.lichaocheng.top.pem;    ssl_certificate_key  /opt/gopath/src/GolangCodeFile/hrBeegoServer/conf/hrapi.lichaocheng.top.key;    ssl_session_timeout  5m;    ssl_ciphers  HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers  on;        location / {                proxy_pass http://0.0.0.0:18080;        }}server{    listen 443 ssl ;    server_name meserver.lichaocheng.top;    ssl_certificate  /opt/lichaocheng.top/lichaocheng.top.server/conf/meserver.lichaocheng.top.pem;    ssl_certificate_key  /opt/lichaocheng.top/lichaocheng.top.server/conf/meserver.lichaocheng.top.key;    ssl_session_timeout  5m;    ssl_ciphers  HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers  on;        location / {                proxy_pass http://0.0.0.0:8180;        }}httpsserver {    listen 443 ssl;  # 1.1版本后这样写    server_name blog.lichaocheng.top; #填写绑定证书的域名    ssl_certificate \"/opt/client/bogl.lichaocheng.top/sll/blog.lichaocheng.top.csr\";    ssl_certificate_key \"/opt/client/bogl.lichaocheng.top/sll/blog.lichaocheng.top.key\";    #ssl_session_timeout 5m;    #ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;    #ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;    #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    #ssl_prefer_server_ciphers on;    location / {        root  /opt/client/bogl.lichaocheng.top/public;        index  index.html index.htm;    }}server {    listen 443;    server_name blog.lichaocheng.top; #填写绑定证书的域名    ssl on;    ssl_certificate /opt/client/bogl.lichaocheng.top/sll/blog.lichaocheng.top.crt;#填写你的证书所在的位置    ssl_certificate_key /opt/client/bogl.lichaocheng.top/sll/blog.lichaocheng.top.key;#填写你的key所在的位置    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;   location / {    root  /opt/client/bogl.lichaocheng.top/public;    index  index.html index.htm;   }}http 转发内部接口server{    listen 80;    server_name frp.lichaocheng.top;    location / {        proxy_pass http://0.0.0.0:9000;    }}端口映射stream {    server {        listen 8836;        proxy_pass localhost:3306;    }}"
  },
  
  {
    "title": "golang 包管理",
    "url": "/posts/golang-package/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils",
    "date": "2020-03-11 16:19:11 +0800",
    





    
    "snippet": "godep安装go get -u -v github.com/tools/godep使用      参考 1    参考 2  goverdor（go1.12 下 推荐使用）安装go get -u github.com/kardianos/govendor基本使用  进入项目目录govendor initgovendor fetch github.com/Cc360428/HelpPacka...",
    "content": "godep安装go get -u -v github.com/tools/godep使用      参考 1    参考 2  goverdor（go1.12 下 推荐使用）安装go get -u github.com/kardianos/govendor基本使用  进入项目目录govendor initgovendor fetch github.com/Cc360428/HelpPackage/UtilsHelpcat vendor/vendor.json{        \"comment\": \"\",        \"ignore\": \"test\",        \"package\": [                {                        \"checksumSHA1\": \"vT6zp7A2xIrOTza5mYU7ZR4it1c=\",                        \"path\": \"github.com/Cc360428/HelpPackage\",                        \"revision\": \"8c482c1a5d4c81ee28409d5efcc557b3fa1b89c2\",                        \"revisionTime\": \"2020-03-05T05:01:58Z\"                },                {                        \"path\": \"github.com/Cc360428/HelpPackage/UtilsHelp\",                        \"revision\": \"\"                }        ],        \"rootPath\": \"Cc360428/cloud\"}更多使用  govendor –help  依赖更新  移除依赖  查看依赖  依赖丢失缺点  必须在 gopath 目录下使用go mod  注：golang 版本升级到 1.11(建议 1.12)设置  注： GO111MODULE 有三个值（off、on、auto）windows setx GO111MODULE on setx GOPROXY https://goproxy.iolinuxexport GO111MODULE=onexport GOPROXY=https://goproxy.io使用  进入项目根目录下  初始化go mod init [mod 名字]  拉取缺少模块go mod tidy  下载依赖包go mod download  编辑 go.modgo mod edit  打印模块依赖图go mod graph  将依赖复制到 vendorvendor  验证依赖是否正确verify  解释为什么需要依赖whygo mod help$ go help modGo mod provides access to operations on modules.Note that support for modules is built into all the go commands,not just 'go mod'. For example, day-to-day adding, removing, upgrading,and downgrading of dependencies should be done using 'go get'.See 'go help modules' for an overview of module functionality.Usage:        go mod &lt;command&gt; [arguments]The commands are:        download    download modules to local cache        edit        edit go.mod from tools or scripts        graph       print module requirement graph        init        initialize new module in current directory        tidy        add missing and remove unused modules        vendor      make vendored copy of dependencies        verify      verify dependencies have expected content        why         explain why packages or modules are neededUse \"go help mod &lt;command&gt;\" for more information about a command."
  },
  
  {
    "title": "Golang Mysql Gorm",
    "url": "/posts/gorm/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb",
    "date": "2020-03-05 16:02:24 +0800",
    





    
    "snippet": "Gorm 概述官网gorm 对数据库的操作环境搭建下载依赖go get -u github.com/jinzhu/gorm实例（连接）package mainimport (\t\"fmt\"\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\" // logs\t\"github.com/jinzhu/gorm\"                      ...",
    "content": "Gorm 概述官网gorm 对数据库的操作环境搭建下载依赖go get -u github.com/jinzhu/gorm实例（连接）package mainimport (\t\"fmt\"\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\" // logs\t\"github.com/jinzhu/gorm\"                         // gorm\t_ \"github.com/jinzhu/gorm/dialects/mysql\"        // 导入初始化包)type Product struct {  gorm.Model  Code string  Price uint}func main() {\tdb, err := gorm.Open(Databases.Type, // 连接属性 （mysql）\t\tfmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=utf8&amp;parseTime=True&amp;loc=Local\",\t\t\tDatabases.User,     // 用户名\t\t\tDatabases.Password, // 密码\t\t\tDatabases.Host,     // 端口号\t\t\tDatabases.Name)) // 数据库名字\tif err != nil {\t\tlogs.Error(\"mysql 连接错误！\", err.Error())\t}\t defer db.Close()  // Migrate the schema  db.AutoMigrate(&amp;Product{})  // 创建  db.Create(&amp;Product{Code: \"L1212\", Price: 1000})  // 读取  var product Product  db.First(&amp;product, 1) // 查询id为1的product  db.First(&amp;product, \"code = ?\", \"L1212\") // 查询code为l1212的product  // 更新 - 更新product的price为2000  db.Model(&amp;product).Update(\"Price\", 2000)  // 删除 - 删除product  db.Delete(&amp;product)}模型定义 structStruct 标记            标记      实义                  column      指定列名              type      ~~数据类型              size      ~~大小，默认 255              primary_key      ~~主键              unique      ~~唯一              default      ~~默认值              precision      ~~精度              not null      ~~非空              auto_increment      ~~自增类型              index      创建索引              unique_index      ~~唯一索引              embedde      将结构体设置为嵌入              embedde_prefix      设置嵌入结构的前缀              -      忽略此字段      User struct Testtype User struct{    gorm.Model //  自增id 添加时间 修改时间 软删除时间    Name string `gorm:\"type:varchar(100);unique_index\"` // 类型 varchar 唯一索引    Address string `gorm:\"size(22)\"`// 设置大小    Image string `gorm:\"unique;not null\"` // 唯一 且不为空    Age int `gorm:\"index:age\"` // 给age字段创建age索引    Demo string `gorm:\"-\"` // 忽略该字段    Test int `gorm:\"auto_increment\"`  // 设置自增}"
  },
  
  {
    "title": "Go 类型转换",
    "url": "/posts/utils-variableAndArray/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils",
    "date": "2020-01-16 22:58:36 +0800",
    





    
    "snippet": "go 类型转换string int int64package mainimport (\t\"fmt\"\t\"strconv\")func main() {\tvar str string\tfmt.Printf(\"str type:%T\\n\", str)\tstr = \"123\"\tvar strInt int\t// string &gt; int\tstrInt, _ = strconv.Atoi(str)...",
    "content": "go 类型转换string int int64package mainimport (\t\"fmt\"\t\"strconv\")func main() {\tvar str string\tfmt.Printf(\"str type:%T\\n\", str)\tstr = \"123\"\tvar strInt int\t// string &gt; int\tstrInt, _ = strconv.Atoi(str)\tfmt.Println(str, strInt)\tvar strInt64 int64\t// string &gt; int64\tstrInt64, _ = strconv.ParseInt(str, 10, 64)\tfmt.Println(strInt64)\tvar intStr int\tintStr = 100\t// int &gt; string\tintToString := strconv.Itoa(intStr)\tfmt.Println(intToString)\t// int64 &gt; string\tint64ToStr := strconv.FormatInt(strInt64, 10)\tfmt.Println(int64ToStr)}整形互转  整形之间互转 int64(int) 需要转什么类型就括号外面什么类型package mainimport \"fmt\"func main() {\tvar int1 int\tint1 = 21\tvar int2 int64\t// int &gt; int64\tint2 = int64(int1)\tfmt.Println(int2)\tvar inta int64\tinta = 10\tvar intb int\t// int64 &gt; int64\tintb = int(inta)\tfmt.Println(intb)\tu := uint32(int1)\tfmt.Println(u)}bool To stringpackage mainimport (\t\"fmt\"\t\"strconv\")func main() {\tvar b bool\tformatBool := strconv.FormatBool(b)\tfmt.Println(formatBool)}fmt.Sprintf To string  参考链接package mainimport \"fmt\"func main() {\tvar byteType byte\tvar str string\tstr = fmt.Sprintf(\"整型 %d 浮点 %f byte %c %s\", 1, 3.14, byteType, \"字符串拼接\")\tfmt.Println(str)}"
  },
  
  {
    "title": "proto error ",
    "url": "/posts/proto-error/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb",
    "date": "2019-12-26 14:22:12 +0800",
    





    
    "snippet": "包名问题WARNING: Deprecated use of go_package option without a full import path in im.proto, please specify: option go_package = .;grpc;  解决问题          在 proto 文件中添加下面代码片段即可        option go_package = ...",
    "content": "包名问题WARNING: Deprecated use of go_package option without a full import path in im.proto, please specify: option go_package = .;grpc;  解决问题          在 proto 文件中添加下面代码片段即可        option go_package = \".;grpc\";  \".;grpc\"—-&gt;;前面是生成的文件路径，后者是生成文件 package 包名"
  },
  
  {
    "title": "protoc 工具",
    "url": "/posts/grpc-utils/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb",
    "date": "2019-12-26 14:22:12 +0800",
    





    
    "snippet": "gRPC安装 protoc 工具  https://github.com/protocolbuffers/protobuf/releases  -I 参数：指定 import 路径，可以指定多个-I 参数，编译时按顺序查找，不指定时默认查找当前目录  –go_out ：golang 编译支持，支持以下参数 - plugins=plugin1+plugin2 - 指定插件，目前只支持 grpc...",
    "content": "gRPC安装 protoc 工具  https://github.com/protocolbuffers/protobuf/releases  -I 参数：指定 import 路径，可以指定多个-I 参数，编译时按顺序查找，不指定时默认查找当前目录  –go_out ：golang 编译支持，支持以下参数 - plugins=plugin1+plugin2 - 指定插件，目前只支持 grpc，即：plugins=grpc - M 参数 - 指定导入的.proto 文件路径编译后对应的 golang 包名(不指定本参数默认就是.proto 文件中 import 语句的路径) - import_prefix=xxx - 为所有 import 路径添加前缀，主要用于编译子目录内的多个 proto 文件，这个参数按理说很有用，尤其适用替代一些情况时的 M 参数，但是实际使用时有个蛋疼的问题导致并不能达到我们预想的效果，自己尝试看看吧 - import_path=foo/bar - 用于指定未声明 package 或 go_package 的文件的包名，最右面的斜线前的字符会被忽略 - 末尾 :编译文件路径 .proto 文件路径(支持通配符)          完整实例        使用前安装：go get -u github.com/golang/protobuf/protoc-gen-goprotoc -I . --go_out=plugins=grpc,Mfoo/bar.proto=bar,import_prefix=foo/,import_path=foo/bar:. ./*.protoprotoc -I . --go_out=plugins=grpc:. dict.protocprotoc -I . --php_out=plugins=grpc:. zhly_pay.protocprotoc --java_out=:. zhly_pay.protocprotoc --js_out=:. zhly_pay.protocprotoc -I=$DIR  yun_mao.protoc  \\ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:$OUT_DIRprotoc --js_out=import_style=commonjs,binary:. yun_mao.protoc下载工具依赖go get google.golang.org/grpcgo get -u github.com/golang/protobuf/protoc-gen-gogo get -u github.com/golang/protobuf/创建.protoc 文件syntax = \"proto3\";  //语法声明package gRPCDemo; //包名// Greeter 微服务service Greeter {  // Sends a greeting  rpc SayHello (HelloRequest) returns (HelloReply) {}}// HelloRequest 请求数据格式message HelloRequest {  string name = 1;}// HelloReply 响应数据格式message HelloReply {  string message = 1;}syntax = \"proto3\";package protoc;service Greeter {  // 1、 查找最空闲的 tcpcluster rpc LookupCluster(LookupClusterRequest) returns (LookupClusterResponse){}  // 2、根据 clientid 发送数据。    rpc SendOutByClientId(SendOutByClientIdRequest) returns (SendOutByClientIdResponse){}  // 3、查找每个 tcpcluster 终端数  rpc LookUpAllClusterNumber(LookUpAllClusterNumberRequest) returns(LookUpAllClusterNumberResponse){}} // 1、 查找最空闲的 tcpcluster Requestmessage LookupClusterRequest{    string args = 1;} // 1、 查找最空闲的 tcpcluster Responsemessage LookupClusterResponse{   string clientId = 1;}// 2、根据 clientid 发送数据  Requestmessage SendOutByClientIdRequest{    string clientId = 1;    string  mgs = 2;}// 2、根据 clientid 发送数据  Responsemessage SendOutByClientIdResponse{    int64 code = 1;}// 3、查找每个 tcpcluster 终端数  Requestmessage LookUpAllClusterNumberRequest{}// 3、查找每个 tcpcluster 终端数  Responsemessage LookUpAllClusterNumberResponse{        map&lt;string, int64&gt; number = 1;}grpcuigo get github.com/fullstorydev/grpcuigo install github.com/fullstorydev/grpcui/cmd/grpcui验证下grpcui -help成功则会在 gopath/bin 目录下生成 grpcuigrpcui -bind 0.0.0.0 -port 8506 -plaintext 47.244.225.92:8502            webiui地址          端口号             grpc地址grpcui -bind 0.0.0.0 -port 8506 -plaintext 0.0.0.0:9002"
  },
  
  {
    "title": "gRPC 和 ui 操作",
    "url": "/posts/gRPC/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb",
    "date": "2019-12-26 14:22:12 +0800",
    





    
    "snippet": "gRPC安装 protoc 工具  https://github.com/protocolbuffers/protobuf/releases  -I 参数：指定 import 路径，可以指定多个-I 参数，编译时按顺序查找，不指定时默认查找当前目录  –go_out ：golang 编译支持，支持以下参数 - plugins=plugin1+plugin2 - 指定插件，目前只支持 grpc...",
    "content": "gRPC安装 protoc 工具  https://github.com/protocolbuffers/protobuf/releases  -I 参数：指定 import 路径，可以指定多个-I 参数，编译时按顺序查找，不指定时默认查找当前目录  –go_out ：golang 编译支持，支持以下参数 - plugins=plugin1+plugin2 - 指定插件，目前只支持 grpc，即：plugins=grpc - M 参数 - 指定导入的.proto 文件路径编译后对应的 golang 包名(不指定本参数默认就是.proto 文件中 import 语句的路径) - import_prefix=xxx - 为所有 import 路径添加前缀，主要用于编译子目录内的多个 proto 文件，这个参数按理说很有用，尤其适用替代一些情况时的 M 参数，但是实际使用时有个蛋疼的问题导致并不能达到我们预想的效果，自己尝试看看吧 - import_path=foo/bar - 用于指定未声明 package 或 go_package 的文件的包名，最右面的斜线前的字符会被忽略 - 末尾 :编译文件路径 .proto 文件路径(支持通配符)          完整实例        使用前安装：go get -u github.com/golang/protobuf/protoc-gen-goprotoc -I . --go_out=plugins=grpc,Mfoo/bar.proto=bar,import_prefix=foo/,import_path=foo/bar:. ./*.protoprotoc -I . --go_out=plugins=grpc:. dict.protocprotoc -I . --php_out=plugins=grpc:. zhly_pay.protocprotoc --java_out=:. zhly_pay.protocprotoc --js_out=:. zhly_pay.protocprotoc -I=$DIR  yun_mao.protoc  \\ --grpc-web_out=import_style=commonjs,mode=grpcwebtext:$OUT_DIRprotoc --js_out=import_style=commonjs,binary:. yun_mao.protoc下载工具依赖go get google.golang.org/grpcgo get -u github.com/golang/protobuf/protoc-gen-gogo get -u github.com/golang/protobuf/创建.protoc 文件syntax = \"proto3\";  //语法声明package gRPCDemo; //包名// Greeter 微服务service Greeter {  // Sends a greeting  rpc SayHello (HelloRequest) returns (HelloReply) {}}// HelloRequest 请求数据格式message HelloRequest {  string name = 1;}// HelloReply 响应数据格式message HelloReply {  string message = 1;}syntax = \"proto3\";package protoc;service Greeter {  // 1、 查找最空闲的 tcpcluster rpc LookupCluster(LookupClusterRequest) returns (LookupClusterResponse){}  // 2、根据 clientid 发送数据。    rpc SendOutByClientId(SendOutByClientIdRequest) returns (SendOutByClientIdResponse){}  // 3、查找每个 tcpcluster 终端数  rpc LookUpAllClusterNumber(LookUpAllClusterNumberRequest) returns(LookUpAllClusterNumberResponse){}} // 1、 查找最空闲的 tcpcluster Requestmessage LookupClusterRequest{    string args = 1;} // 1、 查找最空闲的 tcpcluster Responsemessage LookupClusterResponse{   string clientId = 1;}// 2、根据 clientid 发送数据  Requestmessage SendOutByClientIdRequest{    string clientId = 1;    string  mgs = 2;}// 2、根据 clientid 发送数据  Responsemessage SendOutByClientIdResponse{    int64 code = 1;}// 3、查找每个 tcpcluster 终端数  Requestmessage LookUpAllClusterNumberRequest{}// 3、查找每个 tcpcluster 终端数  Responsemessage LookUpAllClusterNumberResponse{        map&lt;string, int64&gt; number = 1;}grpcuigo get github.com/fullstorydev/grpcuigo install github.com/fullstorydev/grpcui/cmd/grpcui验证下grpcui -help成功则会在 gopath/bin 目录下生成 grpcuigrpcui -bind 0.0.0.0 -port 8506 -plaintext 47.244.225.92:8502            webiui地址          端口号             grpc地址grpcui -bind 0.0.0.0 -port 8506 -plaintext 0.0.0.0:8502GRPC 基础在 Go 中使用 gRPC 进行远程过程调用（RPC）需要以下步骤：      定义 protobuf 文件：首先，我们需要定义所使用的协议缓冲区（protobuf）文件。该文件描述了服务接口和消息类型。        生成代码：接下来，我们需要使用 protobuf 编译器将 protobuf 文件编译成相应的 Go 文件。可以使用 protoc 命令来完成此操作，也可以使用插件来自动生成代码。        实现服务器：我们需要实现 gRPC 服务器，这涉及到实现 protobuf 接口中定义的所有方法，以及相应的处理程序。        实现客户端：我们需要实现 gRPC 客户端，这涉及到使用 gRPC 客户端 API 来调用服务器上实现的方法。  下面是一个简单的示例：  定义 protobuf 文件：syntax = \"proto3\";package helloworld;service Greeter {  rpc SayHello (HelloRequest) returns (HelloReply) {}}message HelloRequest {  string name = 1;}message HelloReply {  string message = 1;}  生成代码：$ protoc --go_out=plugins=grpc:. helloworld.proto这将生成名为 helloworld.pb.go 的文件。  实现服务器：package mainimport (  \"context\"  \"log\"  \"net\"  \"google.golang.org/grpc\"  pb \"path/to/helloworld\")const (  port = \":50051\")type server struct{}func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {  log.Printf(\"Received: %v\", in.GetName())  return &amp;pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil}func main() {  lis, err := net.Listen(\"tcp\", port)  if err != nil {    log.Fatalf(\"failed to listen: %v\", err)  }  s := grpc.NewServer()  pb.RegisterGreeterServer(s, &amp;server{})  if err := s.Serve(lis); err != nil {    log.Fatalf(\"failed to serve: %v\", err)  }}  实现客户端：package mainimport (  \"context\"  \"log\"  \"google.golang.org/grpc\"  pb \"path/to/helloworld\")const (  address = \"localhost:50051\")func main() {  conn, err := grpc.Dial(address, grpc.WithInsecure())  if err != nil {    log.Fatalf(\"did not connect: %v\", err)  }  defer conn.Close()  c := pb.NewGreeterClient(conn)  name := \"world\"  r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest{Name: name})  if err != nil {    log.Fatalf(\"could not greet: %v\", err)  }  log.Printf(\"Greeting: %s\", r.GetMessage())}"
  },
  
  {
    "title": "Protocol Buffer 语法",
    "url": "/posts/Protocol-Buffer/",
    "categories": "Language, Go",
    "tags": "Go, GoWeb",
    "date": "2019-12-26 14:22:12 +0800",
    





    
    "snippet": "Protocol Buffer语法好的，下面我将更详细地说明 Protobuf 的语法。  Protobuf 版本Protobuf 定义了两个版本：proto2 和 proto3。其中，proto2 是旧版本，proto3 是新版本。proto3 做了很多改进，比如对标量类型的定义进行了优化，使其更加严格和一致；移除了一些不必要的特性；默认情况下启用了所有字段都是 required 约束（但...",
    "content": "Protocol Buffer语法好的，下面我将更详细地说明 Protobuf 的语法。  Protobuf 版本Protobuf 定义了两个版本：proto2 和 proto3。其中，proto2 是旧版本，proto3 是新版本。proto3 做了很多改进，比如对标量类型的定义进行了优化，使其更加严格和一致；移除了一些不必要的特性；默认情况下启用了所有字段都是 required 约束（但现在 required 已经被标记为 deprecated）等等。在 Protobuf 文件开头需要指定使用的版本，例如：syntax = \"proto3\";可以通过这个语句来告诉编译器使用 proto3 版本。  包名与许多编程语言类似，Protobuf 中也有包名的概念。一个 Protobuf 文件通常属于一个特定的包，并且由该包内的多个消息组成。使用 package 关键字来指定包名，例如：package example;这里指定了文件所属的包为 example。  引入其他文件如果一个 Protobuf 文件依赖于另一个文件中定义的类型，那么可以使用 import 关键字来引入该文件。例如：import \"google/protobuf/timestamp.proto\";这里引入了 Google 提供的 Protobuf 文件中的 timestamp.proto 文件，使得我们可以在该文件中使用 Timestamp 类型。  消息类型在 Protobuf 中，使用 message 关键字来定义消息类型。一个消息由一个或多个字段组成，每个字段有一个名称和一个类型。例如：message Person {  string name = 1;  int32 age = 2;}这里定义了一个名为 Person 的消息类型，它有两个字段：name 和 age。name 的类型是 string，age 的类型是 int32。  字段Protobuf 中的字段可以具有以下属性：  名称：用于标识该字段。  类型：定义了该字段所能包含的数据类型。  标识号：用于在二进制编码中标识该字段。  规则：指定该字段是否是必需的，可选的，重复的等。例如：message Person {  string name = 1;  int32 age = 2;  repeated string address = 3;  bool is_student = 4 [default = false];}这里定义了四个字段：  name：类型为 string，标识号为 1，必需的。  age：类型为 int32，标识号为 2，必需的。  address：类型为 string 数组，标识号为 3，可重复的。  is_student：类型为 bool，标识号为 4，可选的，默认值为 false。  枚举除了消息类型之外，Protobuf 还支持枚举类型。通过 enum 关键字定义一个枚举类型，例如：enum PhoneType {  MOBILE = 0;  HOME = 1;  WORK = 2;}这里定义了一个名为 PhoneType 的枚举类型，它包含三个值：MOBILE、HOME 和 WORK，对应的值分别为 0、1 和 2。  其他特性除了上述基本语法之外，Protobuf 还支持许多其他特性，如注释、嵌套类型、扩展等。具体可以参考 Protobuf 官方文档。"
  },
  
  {
    "title": "Databases（04735）",
    "url": "/posts/databases/",
    "categories": "Cc, SelfStudy, ComputerBasics",
    "tags": "SelfStudy",
    "date": "2019-12-20 13:57:01 +0800",
    





    
    "snippet": "数据库系统原理（04735）第一章数据库系统概述第三节数据库系统的结构模式：物理独立性 外模式：逻辑独立性  数据库系统结构          客户端系统结构      浏览器/服务器结构                  表示层、处理层、数据层                    第四节数据模型  数据模型的分类：概念层数据模型、逻辑层数据模型、物理层数据模型  组成三要素       ...",
    "content": "数据库系统原理（04735）第一章数据库系统概述第三节数据库系统的结构模式：物理独立性 外模式：逻辑独立性  数据库系统结构          客户端系统结构      浏览器/服务器结构                  表示层、处理层、数据层                    第四节数据模型  数据模型的分类：概念层数据模型、逻辑层数据模型、物理层数据模型  组成三要素          数据结构：      数据操作：      数据约束：            数据模型                  型：Type                    值：Value                    E-R 图：实体型（矩形）、属性（椭圆）、联系（棱形）                            逻辑模型                  层次模型          网状模型          关系模型          面向对象模型                            物理模型            习题  DBMS 提供子模式描述语言来严格定义子模式  关系数据库优点          建立在严格数据概念基础之上      关系模型对于透明、数据独立、保密性、简化了开发工作      第二章关系数据库（重点）关系数据库概述关系数据模型关系数据库模型  数据模型要素：数据结构、数据操作、数据约束  组成要素：关系数据库结构、关系操作集合、关系完整性约束  数据结构          表名（唯一）      列      行        关系数据模型          表（table）：也成关系、而为数据结构，由唯一的表名、列、行      关系（Relation）：关系逻辑对于的一张二维表，集本关系（基本表、基表），查询表、试图表      列（Column）：也称字段（Field）或属性（Attribute），属性的个数为关系的元或度；列值称为属性值，其取范围称为值域      行（Row）：也称元组（Tuple）记录（Record），是按照行存储的      分量（Component）：元组（行 ）其中的一个值      域（Domain）：表示属性取之范围      数据类型（Date Type）：每列的数据类型一样的      码或键（key）：属性得值都能用来唯一的标识该关系的元组      候选码或者候选键（Candidate Key）： 多个列      主属性、非主属性      主码或主键（Primary key）：在若干个候选码中指定一个唯一标识      全码或全键（All- Key）：关系模式的所有属性集合、主键或者主键      外码或外键（Foreign Key）：另一个关系的主键      参照关系和被参照关系      关系模式：关系模式是型（Type）、关系是值（Value），关系模式怼关系描述、不断改变        关系数据库所有关系的集合          每一个属性都是不可分解的（不允许表中有表）      每个关系属性必须命名，属性不同      不允许 key 完全相同的元组      顺序无关紧要、可以任意交换      列无关紧要、可以任意交换            关系操作集合          基本操作                  查询（Query）：一次一集合（结果集）          插入（Insert）          删除（Delete）          修改（Update）                    关系数据语言分类                  关系代数语言：操作对象、操作符、操作结果          SQL：结构化查询语言          关系演算语言：元祖关系演算、域关系演算                            关系代数                  传统的集合运算                          并 - U ：去掉相同的元组（数据）              差 - -              交 - U ：找出两个元组（数据）              笛卡尔积：R1*R2（第一个表的每一个行与第二个表的每一个行组合）                                            专门的关系运算                          选择(select): σF(R)                                  查询性别为男的：σsex=’男’(S1)                                            投影 πA(R)                                  选择列：π sname,age (S1)                                            链接（join）⋈ n : 链接              除：R/S                                关系完整性约束：正确性、相容性、一致性                          实体完整性主属性              参照完整性约束                                          关系数据库的规范化理论冗余和异常问题  数据冗余  更新异常  插入异常  删除异常函数依赖  完全依赖：  部分依赖：范式关系规范化过程  第一范式（1NF）：每一行取值，不可再分的，存在非属性对码的部分函数依赖          缺点：冗余高，插入操作异常、删除操作异常        第二范式（2NF）：所有的非主属性完全依赖候选关键字  第三范式：：每一个非主属性不传递函数依赖候选          第三范式改进（BCNF）      第三章数据库设计数据库设计概要  概述：1-数据库分析与设计阶段；2-数据库实现与操作阶段  目标：满足应用功能需求（存、取、删、改），改良数据库性能（数据高效存取和空间的节省共享性、完整性、一致性、安全保密性）  内容：用户对数据需求出发，结构和行为设计          结构设计（静态的）                  数据库概念结构设计          逻辑结构设计          物理结构设计                    数据库行为设计（动态的）：操作        方法：          直观设计方法（最原始的设计方法）      规范设计法：普遍的、常用数据设计方法                  常见的有                          新奥尔良设计方法：需求分许、概念结构设计、逻辑结构设计、物理结构设计              基于 E-模型设计方法              基于第三范式的设计方法，结构法设计方法                                          计算机辅助设计法（辅助软件工具-&gt;俗称【CASE】工具）        过程          需求分析      概念结构设计      逻辑结构设计      物理结构设计      数据实施      数据库的运行和维护      数据库设计基本步骤  需求分析（数据库设计的起点）          作用：后续概念设计、逻辑设计、物理设计、数据库建立与维护的依据      步骤                  确认数据库范围（第一项工作）          应用过程分析          收集与分析数据          编写需求分析报告                      概念结构设计（概念模型）：最大限度满足应用需求  逻辑结构设计：关系模型（层次、网状、关系数据来表示）  物理设计：数据库在存储设备上的结构  数据库实施          加载数据      应用程序设计      数据库试运行        数据库运行与维护：保证数据库的正常运行；最困难的工作室数据库重组与重构数据库设计方法  关系数据库设计过于各级模式          概念模式      逻辑模式      内模式        概念结构设计          E-R 图表示方法                  实体性、属性、联系                          实体性之间三种联系                                  一对一联系（1:1）：可以在两个实体类型转换成两个关系模式中的任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。                  一对多联系（1:N）：在 N 端实体类型转换成的关系模式中加入 1 端实体类型转换成的关系模式的键和联系类型的属性                  多对多联系（M:N）：将联系类型也转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合                                                                        局部信息结构设计      全局信息结构设计        逻辑结构设计方法          主要三项                  将 E-R 图转换为关系模型          对关系数据模型进行优化          设计面向用户外模式                      物理设计方法          建立索引（逻辑联系）      建立聚集（物理聚集）      第四章 SQL 与关系数据库基本操作（重点）SQL 概述（Structured Query Language，SQL）  结构化查询语言， SQL3 颁布标准-&gt;1999 年  特点：SQL 不是某个特定数据库供应商专有的语言  组成          数据查询      数据定义语言（DDL）                  cretate ：创建数据库或数据库对象          alter：修改数据库或数据库对象进行修改          drop：删除数据库的数据对象                    数据操纵（DML）：用于操纵数据库中各种对象，特别是检索和修改数据                  select：从表试图中检索数据          insert：将数据插入表或试图          update：修改表活着试图中的数据          delete：从表或试图中删除数据                    数据控制（DCL）：主要是权限                  grant：用于授予权限          revoke：用于收回权限                    MySQL 预备知识  关系型数据库：体积小、速度快、开放源代码  MySQL 基础          使用架构（LAMP、WAMP）；Linux、Apache、MySQL、（PHP、Perl、Python）、Windows      扩展语言要素                  常量：也称字面值或标量                          字符串：单引号、双引号括起来的字符序列              数值：整数常亮、浮点数常量              十六进制：每对十六进制数字转换为一个字符，X***              时间日期：用单引号将表示日期自负串号起来构成（例如：’2018-06-05’）              null 值：表示“没有值”、”无数据“                                变量：临时存储数据，随着程序变化而变化；变量属性有名字、数据类型                          用户变量：用户变量前常添加一个符号@用于区分              系统变量：大多数系统变量应用于其他的 SQL 语句时，必须在系统变量前添加两个@                                          运算符                  算数运算符          位运算符          比较运算符          逻辑运算符                    表达式：常量、变量、列名、复杂计算、运算符、函数的组合                  字符型          数值型          日期型                    数据定义      数据库模式定义                  创建数据库（create）                  if not                            选择数据库（use）: use test;                    修改数据库（alter）：alter database test default charcter set gb2312                    删除数据库（drop）: drop database test                    查看数据库（show）：show databases        create database if not exists mysql_test;use mysql_test; # 选择并且使用数据库alter database mysql_test default character set utf8;drop database mysql_test;drop database if exists test;                    表定义                              查询表结构            show create table mysql_test.customers;show columns from mysql_test.customers;desc mysql_test.customers;                                创建表            create table customers (  cust_id int not null auto_increment,# 设置自增，自动编号  cust_name char(50) not null,  cust_sex char(1) not null default 0,# 指定默认值  cust_address char(50) null,  cust_contact char(50) null,  primary key (cust_id) # 主键);                                修改数据表和更改值            alter table mysql_test.customers add cust_city char(50) not null default 'Wuhan' after cust_sex;# 添加一列，不能为空、默认值为'wuhan'、在'cust_sex'之后alter table mysql_test.customers change cust_sex sex char(1) null default 'm'; # 修改列名字，并且设置新的属性alter table mysql_test.customers alter column cust_city set default 'Beijing';# 修改字段属性alter table mysql_test.customers modify column cust_name char(20) first;alter table mysql_test.customers drop column cust_contact;# 删除多余的列alter table mysql_test.customers rename to mysql_test.backup_customers;# 修改表名rename table mysql_test.backup_customers to mysql_test.customers;# 修改表名drop table customers; # 删除表drop table if exists customers; #  询问是否存在再删除                                      索引定义                              优点：索引是提高数据文件访问效率的有效方法                                缺点                          以文件的形式存储，如果有大量的索引，索引文件可能比数据文件更快达到最大的文件尺寸              在提高查询速度的同时，会降低更新表的速度                                            分类：索引通常呗创建成单列索引和组合索引                                类型                          普通索引 index 或 key              唯一性索引 unique              主键 primary key                                            创建            create index index_name on mysql_test.customers(cust_name(3) asc ); # 索引升序create index index_name_and_address on mysql_test.customers(cust_name,cust_address);# 创建组合索引alter table mysql_test.customers add index index_seller_name(cust_contact);alter table customers add cust_index char(2);# 先添加临时字段alter table mysql_test.customers add constraint index_unique unique(cust_index);# 修改表时添加唯一字段                                查看            show index from mysql_test.customers;                                删除            drop index index_unique on mysql_test.customers;alter table mysql_test.customers drop index index_name;# 使用alter                              数据更新（重点）  插入数据（insert）          insert … values：insert into mysql_test.customers values(901,'Cc','F','jiangxi','jiujiang');      insert … set：insert into mysql_test.customers set cust_name=\"Lcc\" ,cust_address='beijing',cust_sex=default;      insert …select：insert into customers(cust_id,cust_name,cust_sex,cust_address,cust_contact) select cust_id,cust_name,cust_sex,cust_address,cust_contact from customers_back;        update：update customers set cust_name=\"HongCheng\" where cust_id=902;  delete：delete from customers where cust_name='ChaoChengLi';数据查询-定义：从数据库的一张或多张（试图）中检索出满足条件的数据信息，通常查询的结果是由 0 行（没有满足条件的数据）或多行记录组成的一个记录集合，允许选择一个或多个座位输出字段；使用灵活数学理论基础是关系数据模型中对表对象的一组关系运算，即选择投影和连接      select：select [列名|*] from table_name where 条件 group by 列名 having 条件 order by 列名 limit offset,rowcount        查询数据          查询内容        select cust_name,cust_address from customers;#指定列select * from customers;# 通配符（全部）select cust_name as name ,cust_address as address from customers;# 别名查询select case when cust_sex='F' then '男' else '女' end as sex from mysql_test.customers;# case 表达式(cust_sex内容等于'F'，则显示男，否则显示女)select case cust_id when 902 then \"一\" when 903 then '二' else '其他' end as name from customers;select cust_name,cust_sex ,cust_id+100 from customers;# 查处结果上cust_id都加上100                  聚合函数                                            函数名              说 明                                                          COUNT              求组中项数，返回 INT 类型整数                                      MAX              求最大值                                      MIN              求最小值                                      SUM              返回表达式中所有值的和                                      AVG              求组中值的平均值                                      STD 或 STDDEV              返回给定表达式中所有值的标准值                                      VARIANCE              返回给定表达式中所有值的方差                                      GROUP CONCAT              返回由属于一组的列值连接组合而成的结果                                      BIT AND              逻辑或                                      BIR OR              逻辑与                                      BIT XOR              逻辑异或                                      select count(cust_id) from customers;select count(*) from customers;select sum(cust_id) from customers;select min(cust_id) from customers;select avg(cust_id) from customers;                    from 子句与多表连接查询        # 准备drop table tbl1,tbl2;create table tbl1 (id int,sex int);create table tbl2 (id int,name char(30));insert into tbl1 values(1,0),(2,1),(3,0),(4,1);insert into tbl2 value(1,'Cc'),(2,'CH'),(3,'ChaoChengLi'),(5,\"Test\");                              交叉连接（笛卡尔积）:两张表记录行数的乘积            select * from tbl1 cross join tbl2;select * from tbl1 join tbl2;                                内连接：通过设置连接条件，来移除查询结果中某些数据之后交叉连接；如果on子句中的连接条件使用运算符=方式为等值连接，其他的为非等值连接            select * from tbl1 inner join tbl2 on tbl1.id=tbl2.id;#可以看到只查出了1，2，3                          自连接：可以将一个表与它本身进行连接，称自连接                                            外连接：交叉连接时，有时会输出不满足的条件记录                          左外连接：左表为基础，from中使用left outer join或left join                        select * from tbl1 laft join tbl2;                          右外连接：有表为基础，from 中使用right outer join或right join                                                  where 子句与条件查询                              比较运算符                                                            比较运算符                  说 明                                                                              =                  等于                                                  ＜＞                  不等于                                                  !=                  不等于                                                  ＜                  小于                                                  ＜=                  小于等于                                                  ＞                  大于                                                  ＞=                  大于等于                                                  ＜=＞                  不会返回 UNKNOWN                                                      insert into customers values(901,\"Cc\",'M',\"japan\",'sss'),(904,\"ChaoCheng\",'M',\"us\",'ttt');select * from customers where cust_sex='M';# 查找男性用户select * from customers where cust_id between 901 and 903;# 判断范围select * from customers where  cust_id in (901,903);# 查询指定select * from customers where cust_contact is null; # 查询 联系为空的select * from customers where cust_contact is not null;# 查询 联系不为空的                                子查询：把查出来的结果作为匹配的对象再次查询            select id from tbl1 where id  in (select id from tbl2 where id &gt; 0);# in 自查询结果集select * from tbl1 where id = 1 and exists (select id from tbl2 where id &gt; 0);# 查询此值是否在自查询结果中                          group by子句与分组：结果集中的数据根据选择列进行逻辑分组                        update customers set cust_address='beijing' where cust_id=901;select cust_address,cust_sex,count(*) as '人数' from customers group by cust_address,cust_sex;# 地址相同的男性和女性用户数量select cust_address,cust_sex,count(*) as '人数' from customers group by cust_address,cust_sex with rollup;# 在group by 上面再统计                                          having                select cust_name,cust_address from customers group by cust_address,cust_name having count(*) &lt;= 1;                                            having VS where                                  having                                          过滤分组                      可以包含聚合函数                      在数据分组后进行过滤                                                        where                                          过滤数据行                      不可以包含聚合函数                      在数据分组前进行过滤                                                                                                  order by子句：排序                select cust_name,cust_sex from customers order by cust_name desc ,cust_address desc;                                            limit : 限制 select 语句返回行数，两个参数（1-偏移量、2-最大数目），初始偏移量是 0（而不是 1）                select * from customers limit 2,2;# 偏移2个,最大数目2select * from customers limit 3; # 一个参数只显示最大记录数目                                                        视图  视图是数据库中一个对象，它是数据库系统提供给用户的一朵中角度观察数据的一种机制，视图不是数据库真实的表，而是一张虚拟表，其自身并不存储数据      优点          集中分散数据      简化查询语句      重用 SQL 语句      保护数据安全      共享所需数据      更改数据格式            操作    # 创建视图create or replace view customers_view as select * from customers where cust_sex='M' with check option;create view customers_view_back as select * from customers where cust_sex='M' with check option;# deletedrop view customers_view;drop view customers_view_back;# 查看show create view customers_view;# 插入insert into customers_view value(910,'MySql','M','US','jp');# 更新；更新视图内容会更新基表内容，基表内容修改也会修改视图内容update customers_view set cust_address='Ch';# 删除；对于依赖多个基表的视图，不能使用delete语句delete from customers_view where cust_name='Cc';# 查询select * from customers_view where cust_id=902;    第五章数据库编程（难点）存储过程  存储过程是一组为了完成某项特定功能的 SQL 语句集，其实质就是一段存储在数据库中的代码；存储过程可以有声明式的 SQL 语句（update 、create 、select）和过程式的 SQL 语句（if … then … else）组成。这组语句集经过编译后存储在数据库中，用户只需要通过指定存储过程的名字并给定参数（参数可有可无），可随时调用并执行，而不需要重新编译      优点          可增强 SQL 语言的功能和灵活性      良好的封装性      高性能      可减少网络流量      可作为一种安全机制来确保数据库的安全性和数据的完整性            创建    # 创建delimiter $$ # 定义结束符 delimiter !! 但是需要和end !! 对应起来create procedure sp_update_sex(in cid int,csex char(1))begin # 开始update customers set cust_sex=csex where cust_id=cid;end $$ # 结束        存储过程体                  使用declare语句声明局部变量：declare cid int (10);                  只能在存储过程体的begin...end语句块声明          必须在存储过程的开头处声明          不同于用户变量                          局部变量：前面没有@符号，只能在存储过程体的begin...end语句块使用              用户变量：前面有@符号，同时已声明的用户变量存在于整个会话中                                                  使用set语句为局部变量赋值（set cid=911）                    select into 语句把选定列值直接存储到局部变量中                    流程控制语句                  条件判断：if then else ；end if          循环：while 、repeat 、loop；iterate 退出当前循环，且重新开始下个循环                            游标（cursor）                  在 mysql 中一条 select…into 语句中成功执行后，会返回带有一行数据，这行数据可以被读取到存储过程中进行处理，然后在使用 select 语句进行数据检索时，若该语句成功被执行，则会返回一组结果集的数据行，该结果集拥有多行数据，这数据无法直接一行一行进行处理，此时需要使用游标；游标是一个 select 语句检索出来的结果集，在存储了游标后，应用程序或用户就可以更具需要滚动或浏览器中数据                          声明          打开：open cursor_name          读取：fetch cursor          关闭：close cursor_name                use mysql_test;delimiter $$ # mysql 默认是; delimiter ;create procedure sp_sumofrow (out rows int)begindeclare cid intdeclare found boolean default truedeclare cur_cid cursor for # 创建游标select cust_id from customers;declare continue handler for not foundset found=falseset rows=0open cur_cidfetch cur_id into cidwhile found doset rows=rows+1fetch cur_cid into cidend whileclose cur_id;end $$delimiter;call sp_sumofrow(@rows);                  注意事项                          只能用于存储过程或者存粗函数，不能单独在查询操作中使用              使用中可以用多个游标，但是在 begin…end 语句块每个游标的名字必须时唯一的              不是一条 select 语句，是被 select 语句检索出来的结果集                                                  调用存储过程、删除、查看        show procedure status;# 查看所有详情show create procedure sp_update_sex;# 查看call sp_update_sex(909,'M');# 调用drop procedure sp_update_sex; # 删除drop procedure if exists sp_update_sex; #  删除            存储函数  存储函数与存储过程一样，组成代码片段，调用语句      存储过程与存储函数区别          存储函数不能有参数，因自身就是输出函数参数；过程可以拥有输出参数      可以直接对存储函数调用，不需要call语句；存储过程需要call调用      存储函数必须包含return语句；存储过程必须要包含这个特殊语句            操作    # 创建use mysql_test;delimiter $$create function fn_search(cid int)returns char(20)deterministicbegindeclare sex char(20);select cust_sex into sex from customers where cust_id=cid;if sex is null thenreturn (select'没有该用户');else if sex='f' thenreturn (select'女');else return (select'男');end if;end if;end $$delimiter ;# 调用select fn_search(902);# 删除drop function fn_search;drop function if exists fn_search;  第六章数据库安全与保护数据库完整性：数据的正确性和相容性  作用：防止数据库中存在不符合定义的数据  约束的作用对象          列级约束：列类型、取值范围、精度等约束      元组约束：元组中的各个字段之间的相互约束      表级约束：若干个元组，关系之间的联系约束            核心：实体完整性、参照完整性、用户定义性的完整性          实体完整性：通过主键约束和候选键约束实现（规则如下）                  每个表只能定义一个主键                          主键：一个表只能有一个；primary key              候选键：可以定义若干个；unique                                主键的值（键值）必须能够唯一标志表每一行记录，且不能为空          复合主键不能包含不必要的多余的列          一个列名在复合主键的列表中只能出现一次                            参照完整性：在通过创建表或更新表同时定义一个外键声明实现                              方式                          在某个列定义属性后直接加上reference definition语法              在表列属性定义后添加foreign key(index_col name...)                        use mysql_test;create table orders (  order_id int not null auto_increment,  order_product char(50) not null,  order_product_type char(50) not null,  cust_id int null,  order_date datetime not null,  order_price double not null,  order_amount int not null,  primary key(order_id),  foreign key (cust_id) references customers(cust_id) on delete restrict on update restrict);                                完整性约束                          非空约束：not null              check：check （expr）              触发器                                            命名完整性约束（指定约束的名字）                                更新完整性约束                          完整性约束不能直接修改              使用alter table语句，可以独立的删除完整性约束，而且不会删除表本身（使用 drop table 删除表，会自动删除）                                          触发器（Trigger）  在关系表上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法，一旦定义无需用户调用，任何对表的修改操作均有数据库服务器自动激活相应的触发器；触发器与表的关系十分密切，其主要作用是实现主键和外键不能保证负责的参照完整性和数据一致性，从而有效地保护表中的数据      注意：创建中，每个表每个事件每次只允许一个触发器，因每个表最多支持6个触发器（insert、update、delete）之前，之后        操作    # 创建create trigger customers_insert_trigger after insert on customers for each row set @str='one customers added!'# 删除drop trigger customers_insert_trigger;drop trigger if exists customers_insert_trigger;# insertcreate trigger customers_insert_trigger after insert on customers for each row set @str=new.cust_id;# updatecreate trigger customers_update_trigger before update on customers for each row set new.cust_address=old.cust_contact;  安全性与访问控制：防止不合法的操作而造成数据泄漏，更改或破坏create user 'Cc'@'localhost' identified by 'password';# 创建show grants for 'Cc'@'localhost';# 查看set password for 'Cc'@'localhost' = '123456asdf';# update passworddrop user 'Cc'@'localhost';# 删除grant select (cust_id,cust_name) on mysql_test.customers to 'Cc'@'localhost';# 授权 目标用户需要重新登录select cust_id,cust_name from mysql_test.customers; #  授权登录用户查看下结果grant all on mysql_test.* to 'Cc'@'localhost';#  授权mysql_test 库的所有操作权限grant create user on *.* to 'Cc'@'localhost'; # 创建用户的权限revoke select on mysql_test.* from 'Cc'@'localhost';# 撤回权限事务与并发控制：事务保证数据一致性的基本手段  用户定义操作序列，这些操作作为一个完整工作但愿，要么全部执行，要么全部不执行，是一个不可分割的工作单位，事务中的操作一般是对数据的更新操作（增、删、改）  特征（ACID）          原子性：事务时不可分割的最小工作单位      一致性      隔离性      持续性（永久性）        锁-&gt;做常用的并发控制          含义：事务通过向系统请求对他的希望的数据加锁，以确保他的不被非预期改变      锁：一个锁是实质上是允许阻止一个事物对一个数据对象存取特权      类型                  排他锁（X 锁）用于写操作          共享锁（S 锁）用于读操作                    原理                  事务 T 对 D 数据加 X 或 S 锁，必须等待事务释放锁才能进行写或者读          事务一直占有获得锁直到结束是释放锁                    粒度：单元数据大小；锁粒度越细，并发性越大，软件复杂性和系统开销也就越大      锁级别（一致性或隔离性）：0 ～ 3 级封锁      死锁和活锁                  活锁：活锁处理方案—-先来先服务          死锁：活锁的预防方案                          一次性锁请求              锁请求排序              序列化处理              资源剥夺                                死锁检测：图论的方法检测死锁，并以正在执行的事务为节点                    可串行性：基本操作的一种排序                  两段封锁法                          发展（Growing）或加锁阶段              收缩（Shrinking）或放缩阶段                                          备份与恢复：保证数据库的可靠性和完整性      数据丢失的途经：计算机硬件故障、计算机软件故障、病毒、认为误操作、自然灾害、盗窃        概念：数据备份通过数据导出数据或复制表文件的方式来制作数据的副本；数据库的恢复是以备份为基础的，与备份相对应的系统维护和管理操作        操作    SELECT * FROM mysql_test.customersINTO OUTFILE '/opt/work/backupfile.txt'FIELDS TERMINATED BY ','OPTIONALLY ENCLOSED BY \"\"LINES TERMINATED BY '?';        需要注意：多个用户使用数据库情况下，为了得到一个一致的备份，需要在指定表上使用lock tables table name read语句做一个读锁定，为防止其他用户更新，而当恢复时，则需要使用lock tables，table name write语句做一个写锁定，以避免发生数据冲突，数据库备份或恢复完毕之后，需要使用unlock tables 语句对该表进行解锁  第七章数据库应用设计与开发实例第八章数据库管理技术的发展"
  },
  
  {
    "title": "Golang 锁",
    "url": "/posts/Lock/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils",
    "date": "2019-12-12 22:58:36 +0800",
    





    
    "snippet": "锁  sync 包中 Locker 提供互斥锁（Mutex）和读写锁（RWMutex）      为什么要锁          go run test1.go |sort|uniq |wc -l会发现下面代码明明是递增 但是结果会出现最后可能不是999          package main  import (    \"fmt\"    \"time\"  )  func main() {  ...",
    "content": "锁  sync 包中 Locker 提供互斥锁（Mutex）和读写锁（RWMutex）      为什么要锁          go run test1.go |sort|uniq |wc -l会发现下面代码明明是递增 但是结果会出现最后可能不是999          package main  import (    \"fmt\"    \"time\"  )  func main() {    var a = 0    for i := 0; i &lt; 999; i++ {      go func(idx int) {        a += 1        fmt.Println(a)      }(i)    }    time.Sleep(time.Second)  }            怎么解决以上问题          可是使用锁来实现        package mainimport (  \"fmt\"  \"sync\"  \"time\")func main() {  var a = 0  var lock sync.Mutex  for i := 0; i &lt; 999; i++ {    go func(idx int) {      lock.Lock()      defer lock.Unlock()      a += 1      fmt.Println(a)    }(i)  }  // 等待 1s 结束主程序  // 确保所有协程执行完  time.Sleep(time.Second)}      互斥锁（Mutex）  只能有一个线程占用资源，其他线程只能等待package mainimport (  \"fmt\"  \"sync\")var mutex sync.Mutexfunc printFunc(str string) {  mutex.Lock()  defer mutex.Unlock()  for _, data := range str {    fmt.Printf(\"%c\", data)  }  fmt.Println()}func main() {  var waitGroup sync.WaitGroup  waitGroup.Add(2)  go func() {    defer waitGroup.Done()    printFunc(\"hello\")  }()  go func() {    defer waitGroup.Done()    printFunc(\"world\")  }()  waitGroup.Wait()}读写锁（RWMutex）读写      写操作的锁定和解锁    func (*RWMutex) Lock      func (*RWMutex) Unlock    读操作的锁定和解锁  func (*RWMutex) Rlock  func (*RWMutex) RUnlock前言  当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。所以说这里的读锁定（RLock）目的其实是告诉写锁定：有很多人正在读取数据，你给我站一边去，等它们读（读解锁）完你再来写（写锁定）。我们可以将其总结为如下三条：  同时只能有一个 goroutine能够获得写锁定  同时可以有任意多个 gorouinte获得读锁定      同时只能存在写锁定或读锁定（读和写互斥）    package mainimport (  \"fmt\"  \"sync\"  \"time\")var str = \"Hello World\"var rw sync.RWMutexfunc main() {  go func() {    for i := 0; i &lt; 100; i++ {      read()    }  }()  go func() {    for i := 0; i &lt; 1; i++ {      write(\"write\")    }  }()  time.Sleep(time.Second * 2)}// 读func read() {  rw.RLock()  defer rw.RUnlock()  fmt.Println(\"读\", str)}// 写func write(n string) {  rw.Lock()  defer rw.Unlock()  str += \"no HelloWorld \" + n  fmt.Println(\"写\", str)  for i := 0; i &lt; 100; i++ {    fmt.Println(\"在写入请等下\")  }}      "
  },
  
  {
    "title": "Go 1.12 版本更新",
    "url": "/posts/go-1.12/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoVersion",
    "date": "2019-12-06 17:11:22 +0800",
    





    
    "snippet": "go mod 1.12 学习go modules(check version)  检查 golang 版本如果没有生成 go.sum 或者报错请输入export GOPROXY=https://goproxy.ioC:\\Users\\admin&gt;go versiongo version go1.12.9 windows/amd64把 golang 升级到 1.11（现在1.12 已经发布...",
    "content": "go mod 1.12 学习go modules(check version)  检查 golang 版本如果没有生成 go.sum 或者报错请输入export GOPROXY=https://goproxy.ioC:\\Users\\admin&gt;go versiongo version go1.12.9 windows/amd64把 golang 升级到 1.11（现在1.12 已经发布了，建议使用1.12）设置 GO111MODULEGO111MODULEGO111MODULE 有三个值：off, on和auto（默认值）。GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：当前目录在GOPATH/src之外且该目录包含go.mod文件当前文件在包含go.mod文件的目录下面。当modules 功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。      download          download modules to local cache(下载依赖包)            edit          edit go.mod from tools or scripts（编辑 go.mod            graph          print module requirement graph (打印模块依赖图)            init          initialize new module in current directory（在当前目录初始化 mod）            tidy          add missing and remove unused modules(拉取缺少的模块，移除不用的模块)            vendor          make vendored copy of dependencies(将依赖复制到 vendor 下)            verify          verify dependencies have expected content (验证依赖是否正确）            why          explain why packages or modules are needed(解释为什么需要依赖)            go.mod          module: 语句指定包的名字（路径）      require: 语句指定的依赖项模块      replace: 语句可以替换依赖项模块      exclude: 语句可以忽略依赖项模块      "
  },
  
  {
    "title": "MySql lock",
    "url": "/posts/mysql-lock/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2019-09-18 12:21:48 +0800",
    





    
    "snippet": "MySQL 锁  表级锁 和 行级锁mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| mylock         || test           |+----------------+2 rows in set (0.03 sec)表锁  表锁有两种  元数据锁（Meta Data...",
    "content": "MySQL 锁  表级锁 和 行级锁mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| mylock         || test           |+----------------+2 rows in set (0.03 sec)表锁  表锁有两种  元数据锁（Meta Data Lock，MDL）查询争用状态变量show status like 'table_locks%';+-----------------------+-------+| Variable_name         | Value |+-----------------------+-------+| Table_locks_immediate | 104   || Table_locks_waited    | 0     |+-----------------------+-------+2 rows in set (0.04 sec)  Table_locks_immediate：产生表级锁定的次数  Table_locks_waited：出现表级锁定争用而发生等待的请求数#### 表锁两种形式 lock table 表名称1 read(write)  开启 read 其他 select... 可以查但是不能修改会自动加入行锁  开启 write 其他 select .... 会查询锁住  表共享读锁（Table Read Lock）  session1: lock table mylock read; 给 mylock 表加读锁  session1: select * from mylock; 可以查询  session1：select * from tdep; 不能访问非锁定表(1100 - Table ‘test’ was not locked with LOCK TABLES)  session2：select * from mylock; 可以查询 没有锁  session2：update mylock set name='x' where id=2; 修改阻塞,自动加行写锁  session1：unlock tables; 释放表锁  session2：Rows matched: 1 Changed: 1 Warnings: 0 修改执行完成  session1：select * from tdep; 可以访问  表独占写锁（Table Write Lock）  session1:lock table mylock write;给 mylock 表加写锁  session1:select * from mylock;当前 session 可以查询  session1：select * from tdep;不能访问非锁定表  session1：update mylock set name='y' where id=2;可以执行  session2：select * from mylock;查询阻塞  session1：unlock tables;释放表锁  session2：4 rows in set (22.57 sec)查询执行完成  session1：select * from tdep;可以访问  元数据锁（MDL）MetaDataLock          简单讲就是数据库存储的数据或者表结构，可以通过 show或者 select 来查看 ，但是元数据锁 在 mysql5.5引进的对 metadata对事务级别保护，5.5 之前是语句级别。所谓语句级别，即 语句执行完成后，无论事务是否提交或回滚，其表结构可以被其他会话更新；而事务级别则是在 事务结束后才释放MDL，引进 MDL主要解决两个问题        一个是事务隔离问题，比如在 可重复隔离级别下，会话 A 在 2 次查询期间，会话 B 对表结构做了修改，两次查询结果就会不一致，无法满足可重 复读的要求；  另外一个是 数据复制的问题，比如会话 A 先执行了更新语句期间，另外一个会话 B 做了表结构变更并且先提交，就会导致 slave 在重做时，先重做 alter，再重做 update 时就会出现复制错误的现象  session1: begin;开启事务select * from mylock;加 MDL 读锁  session2: alter table mylock add f int; 修改阻塞  session1：commit; 提交事务 或者 rollback 释放读锁  session2：Query OK, 0 rows affected (38.67 sec)修改完成行锁(InnoDB)按照范围分类  记录锁、间隙锁、Next-Key锁  记录锁（Record Locks）:锁定索引中一条记录。 例如主键或唯一索引等值条件指定 where id=3  间隙锁（Gap Locks）: 锁定索引记录之间的间隙，或者是某一条记录之前和之后加锁，该机制主要为了解决幻读问题。  Next-Key 锁: 记录锁 + 间隙锁，RR 隔离级下默认使用 Next-Key 锁，即锁定当前记录也锁定记录间隙。按照功能分类  共享读锁（S）、排他写锁（X）      共享读锁（行读锁）          行级锁        1、session1: begin;开启事务未提交select * from mylock  where id=1 lock in share mode; 手动加 id=1 的行读锁,使用索引2、session2：update mylock set name='y' where id=2; 未锁定该行可以修改3、session2：update mylock set name='y' where id=1; 锁定该行修改阻塞          ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 锁定超时        4、session1:commit; 提交事务 或者 rollback 释放读锁5、session2：update mylock set name=’y’ where id=1;` 修改成功                  行级锁升级为表锁（未使用索引行锁升级为表锁）                  session1: begin;开启事务未提交select * from mylock  where id=1 lock in share mode;手动加 id=1 的行读锁,使用索引          session2：update mylock set name='y' where id=2;未锁定该行可以修改          session2：update mylock set name='y' where id=1;锁定该行修改阻塞ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction– 锁定超时          session1: commit; –提交事务 或者 rollback 释放读锁          session2：update mylock set name='y' where id=1; –修改成功                          排他写锁（行写锁）行产生写锁时，在MVCC下仍然可读，因为MVCC下的select读不需要获取锁（无锁），所以不会阻塞          session1: begin;开启事务未提交,手动加”id=1”的行写锁,select * from mylock  where id=1 for update;      session2：select * from mylock  where id=2 ; 可以访问      session2: select * from mylock  where id=1 ;可以读 不加锁      session2: select * from mylock  where id=1 lock in share mode ;加读锁被阻塞      session1：commit; 提交事务 或者 rollback 释放写锁      session2：执行成功            间隙锁    在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock 的机制主要是 解决可重复读模式下的的 幻读问题死锁  两个 session 互相等待 对方资源释放之后才能释放自己资源造成死锁  session1: begin;开启事务未提交,手动加行写锁 id=1 ，使用索引`update mylock set name=’m’ where id=1;  session2：begin;开启事务未提交,手动加行写锁 id=2使用索引update mylock set name='m' where id=2;  session1:update mylock set name='nn' where id=2; 加写锁被阻塞  session2：update mylock set name='nn' where id=1; 加写锁会死锁，不允许操作  ERROR 1213 (40001): Deadlock found when trying to get lock; try restartingtransaction避免死锁越是轻量的事务，占有越少的锁资源，这样发生死锁的几率就越小 1.避免使用子查询，尽量使用主键等等，以 提高SQL运行速度 2.尽量快提交事务，减少持有锁的时间"
  },
  
  {
    "title": "TCP/IP",
    "url": "/posts/tcpip/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2019-08-22 12:48:54 +0800",
    





    
    "snippet": "TCP/IP  TCP/IP 在传输层连个不同协议，传输控制协议(TCP)、用户数据协议(UDP)TCP——UDP  TCP 数据传输单位 TCP 报文段，UDP 数据传输单位 UDP 报文或者用户数据报  TCP 面向连接，UDP 面向无连接  TCP 高度可靠，UDP 不能保证数据可靠性传输  TCP 复杂性因此开销大，UDP 简单性具有较高的传输效率TCP  传输控制协议，面向连接，可...",
    "content": "TCP/IP  TCP/IP 在传输层连个不同协议，传输控制协议(TCP)、用户数据协议(UDP)TCP——UDP  TCP 数据传输单位 TCP 报文段，UDP 数据传输单位 UDP 报文或者用户数据报  TCP 面向连接，UDP 面向无连接  TCP 高度可靠，UDP 不能保证数据可靠性传输  TCP 复杂性因此开销大，UDP 简单性具有较高的传输效率TCP  传输控制协议，面向连接，可靠。一旦数据报被破坏或丢失将会重新传输，TCP 会检测传输错误并予修正，可靠全双工数据传输协议服务主要功能  数据流的多路复用  检测数据段完整性  重新排序  流量监控  复杂的时钟机制  高校的确认方式TCP 报文  端口号：用来标识同一台计算机的不同的应用进程          源端口：源端口和 IP 地址的作用是标识报文的返回地址      目的端口：端口指明接收方计算机上的应用程序接口        发送序列号  确认号  报头长度  预留  编码位          URG：紧急指针      ACK：确认号有效      PSH：要求接收端尽快将这个报文交给应用层      RST：复位一个 TCP 连接      SYN：同步序列号用于建立连接      FIN：发送端完成任务并要求终止传输        窗口  紧急指针  选项  填充  数据TCP 三次握手      客户端发送—————————–SYN，seq=x—————————————&gt;服务端          SYS（同步信号）、seq（生成序列号）            客户端&lt;—————————SYN，ACK=X+1，seq=y————————服务端发送          SYS（同步信号）、ACK（客户端发送序列号加随机数）、seq（生成序列号）            客户端发送————————–SYN，ACK=y+1———————————–&gt;服务端          SYS（同步信号）、ACK（服务端发送发送序列号加随机数）、seq（生成序列号）      四次挥手      客户端发送———————FIN，ACK—————————-&gt;服务端          FIN（终止传输）、ACK（确认收到最后一个包）            客户端&lt;————————–ACK————————————-服务端发送          ACK（确认收到）            客户端&lt;————————–FIN————————————–服务端发送          FIN（终止发送）            客户端发送———————-ACK———————————–&gt;服务端          ACK（确认终止发送）      UDP"
  },
  
  {
    "title": "IP协议",
    "url": "/posts/ip/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2019-08-21 12:48:54 +0800",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "HTTP协议",
    "url": "/posts/http/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2019-08-20 12:48:54 +0800",
    





    
    "snippet": "HTTP 协议  Hyper Text Transfer Protocol 超文本传输协议  http 消息结构体、请求方法、响应头信息、状态码、content-type  http 版本：HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2.0消息结构体      客户端            服务端      请求方法  HTTP/1.0：GET、 POST 、 HEAD ...",
    "content": "HTTP 协议  Hyper Text Transfer Protocol 超文本传输协议  http 消息结构体、请求方法、响应头信息、状态码、content-type  http 版本：HTTP/0.9、HTTP/1.0、HTTP/1.1、HTTP/2.0消息结构体      客户端            服务端      请求方法  HTTP/1.0：GET、 POST 、 HEAD  HTTP/1.1：增加了 OPTIONS、PUT、PATCH、DELETE、TRACE 、 CONNECT            序号      方法      描述                  1      GET      请求指定的页面信息，并返回实体主体。              2      HEAD      类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头              3      POST      向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。              4      PUT      从客户端向服务器传送的数据取代指定的文档的内容。              5      DELETE      请求服务器删除指定的页面。              6      CONNECT      HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。              7      OPTIONS      允许客户端查看服务器的性能。              8      TRACE      回显服务器收到的请求，主要用于测试或诊断。              9      PATCH      是对 PUT 方法的补充，用来对已知资源进行局部更新 。      响应头信息            应答头      说明                  Allow      服务器支持哪些请求方法（如 GET、POST 等）。              Content-Encoding      文档的编码（Encode）方法。只有在解码之后才可以得到 Content-Type 头指定的内容类型。利用 gzip 压缩文档能够显著地减少 HTML 文档的下载时间。Java 的 GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix 上的 Netscape 和 Windows 上的 IE 4、IE 5 才支持它。因此，Servlet 应该通过查看 Accept-Encoding 头（即 request.getHeader(“Accept-Encoding”)）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的 HTML 页面，为其他浏览器返回普通页面。              Content-Length      表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入 Content-Length 头，最后通过 byteArrayStream.writeTo(response.getOutputStream()发送内容。              Content-Type      表示后面的文档属于什么 MIME 类型。Servlet 默认为 text/plain，但通常需要显式地指定为 text/html。由于经常要设置 Content-Type，因此 HttpServletResponse 提供了一个专用的方法 setContentType。              Date      当前的 GMT 时间。你可以用 setDateHeader 来设置这个头以避免转换时间格式的麻烦。              Expires      应该在什么时候认为文档已经过期，从而不再缓存它？              Last-Modified      文档的最后改动时间。客户可以通过 If-Modified-Since 请求头提供一个日期，该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个 304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置。              Location      表示客户应当到哪里去提取文档。Location 通常不是直接设置的，而是通过 HttpServletResponse 的 sendRedirect 方法，该方法同时设置状态代码为 302。              Refresh      表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过 setHeader(“Refresh”, “5; URL=http://host/path”)让浏览器读取指定的页面。 注意这种功能通常是通过设置 HTML 页面 HEAD 区的＜ META HTTP-EQUIV=”Refresh” CONTENT=”5;URL=http://host/path”＞实现，这是因为，自动刷新或重定向对于那些不能使用 CGI 或 Servlet 的 HTML 编写者十分重要。但是，对于 Servlet 来说，直接设置 Refresh 头更加方便。 注意 Refresh 的意义是”N 秒之后刷新本页面或访问指定页面”，而不是”每隔 N 秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个 Refresh 头，而发送 204 状态代码则可以阻止浏览器继续刷新，不管是使用 Refresh 头还是＜ META HTTP-EQUIV=”Refresh” …＞。 注意 Refresh 头不属于 HTTP 1.1 正式规范的一部分，而是一个扩展，但 Netscape 和 IE 都支持它。              Server      服务器名字。Servlet 一般不设置这个值，而是由 Web 服务器自己设置。              Set-Cookie      设置和页面关联的 Cookie。Servlet 不应使用 response.setHeader(“Set-Cookie”, …)，而是应使用 HttpServletResponse 提供的专用方法 addCookie。参见下文有关 Cookie 设置的讨论。              WWW-Authenticate      客户应该在 Authorization 头中提供什么类型的授权信息？在包含 401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼”executives＼””)。 注意 Servlet 一般不进行这方面的处理，而是让 Web 服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。      状态码  状态码分类            分类      分类描述                  1**      信息，服务器收到请求，需要请求者继续执行操作              2**      成功，操作被成功接收并处理              3**      重定向，需要进一步的操作以完成请求              4**      客户端错误，请求包含语法错误或无法完成请求              5**      服务器错误，服务器在处理请求的过程中发生了错误        状态码列表            状态码      状态码英文名称      中文描述                  100      Continue      服务器收到了请求的初始部分，并且请客户端继续发送              101      Switching Protocols      切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。扩展（http 请求 websocket 就会提升切换成 101）                                           200      OK      请求成功。一般用于 GET 与 POST 请求              201      Created      已创建。成功请求并创建了新的资源              202      Accepted      已接受。已经接受请求，但未处理完成              203      Non-Authoritative Information      非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本              204      No Content      无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档              205      Reset Content      重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域              206      Partial Content      部分内容。服务器成功处理了部分 GET 请求                                           300      Multiple Choices      多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择              301      Moved Permanently      永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替              302      Found      临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI              303      See Other      查看其它地址。与 301 类似。使用 GET 和 POST 请求查看              304      Not Modified      未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源              305      Use Proxy      使用代理。所请求的资源必须通过代理访问              306      Unused      已经被废弃的 HTTP 状态码              307      Temporary Redirect      临时重定向。与 302 类似。使用 GET 请求重定向                                           400      Bad Request      客户端请求的语法错误，服务器无法理解              401      Unauthorized      请求要求用户的身份认证              402      Payment Required      保留，将来使用              403      Forbidden      服务器理解请求客户端的请求，但是拒绝执行此请求              404      Not Found      服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面              405      Method Not Allowed      客户端请求中的方法被禁止              406      Not Acceptable      服务器无法根据客户端请求的内容特性完成请求              407      Proxy Authentication Required      请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权              408      Request Time-out      服务器等待客户端发送的请求时间过长，超时              409      Conflict      服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突              410      Gone      客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置              411      Length Required      服务器无法处理客户端发送的不带 Content-Length 的请求信息              412      Precondition Failed      客户端请求信息的先决条件错误              413      Request Entity Too Large      由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息              414      Request-URI Too Large      请求的 URI 过长（URI 通常为网址），服务器无法处理              415      Unsupported Media Type      服务器无法处理请求附带的媒体格式              416      Requested range not satisfiable      客户端请求的范围无效              417      Expectation Failed      服务器无法满足 Expect 的请求头信息                                           500      Internal Server Error      服务器内部错误，无法完成请求              501      Not Implemented      服务器不支持请求的功能，无法完成请求              502      Bad Gateway      作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应              503      Service Unavailable      由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中              504      Gateway Time-out      充当网关或代理的服务器，未及时从远端服务器获取请求              505      HTTP Version not supported      服务器不支持请求的 HTTP 协议的版本，无法完成处理      content-type  媒体格式类型          text/html ： HTML 格式      text/plain ：纯文本格式      text/xml ： XML 格式      image/gif ：gif 图片格式      image/jpeg ：jpg 图片格式      image/png：png 图片格式        application 开头的媒体格式          application/xhtml+xml ：XHTML 格式      application/xml： XML 数据格式      application/atom+xml ：Atom XML 聚合格式      application/json： JSON 数据格式      application/pdf：pdf 格式      application/msword ： Word 文档格式      application/octet-stream ： 二进制流数据（如常见的文件下载）      application/x-www-form-urlencoded ： &lt;form encType=\"\"&gt;中默认的 encType，form 表单数据被编码为 key/value 格式发送到服务器（表单默认的提交数据的格式）      "
  },
  
  {
    "title": "物理层",
    "url": "/posts/bit/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2019-08-19 12:48:54 +0800",
    





    
    "snippet": "物理层",
    "content": "物理层"
  },
  
  {
    "title": "网络基础",
    "url": "/posts/NetworkEngineerBase/",
    "categories": "DevOps, Network",
    "tags": "LinuxTool, Network",
    "date": "2019-08-18 12:48:54 +0800",
    





    
    "snippet": "计算机网络基础OSI 与 TCP/IPOSITCP/IP物理层  网络接口网际层  IP 协议：主要的网际层协议，用于网络互联  ICMP 协议：报文协议，用于报告差错，向路由器主机发送差错报文  ARP 协议：地址解析协议，用于将 IP 解析成物理地址  RARP 协议：逆地址协议，物理地址解析到 IP 地址运输层  TCP：传输控制协议是面向连接协议，提供可靠的主机到主机的数据传输服务。...",
    "content": "计算机网络基础OSI 与 TCP/IPOSITCP/IP物理层  网络接口网际层  IP 协议：主要的网际层协议，用于网络互联  ICMP 协议：报文协议，用于报告差错，向路由器主机发送差错报文  ARP 协议：地址解析协议，用于将 IP 解析成物理地址  RARP 协议：逆地址协议，物理地址解析到 IP 地址运输层  TCP：传输控制协议是面向连接协议，提供可靠的主机到主机的数据传输服务。保证数据传输的可靠性、无差错、不丢失、无重复的按序到达  UDP：面向无连接，不可靠的端对端的数据传输服务，UDP 减少很多额外开销，因此传输效率高应用层  TELNET  FTP：文件传输协议，用于主机与主机之间文件上传下载  SMTP：邮件传输协议，用于电子邮件  DNS：域名解析协议"
  },
  
  {
    "title": "Eclipse中Maven项目创建",
    "url": "/posts/SSM+Redis_base/",
    "categories": "Language, Java",
    "tags": "Server, Java, Java Base",
    "date": "2019-06-03 14:10:00 +0800",
    





    
    "snippet": "Eclipse中Maven项目创建Maven项目创建项目创建之后，要到javax.servlet下的包资源会报错解决方法搭建SSM配置web.xml  配置DispatcherServlet，是SpringMVC的核心组件，用于接收所有请求，然后分发到各控制器，在配置时，必须确定初始化时加载的Spring配置文件是哪些！配置CharacterEncodingFilter，即字符编码过滤器，用...",
    "content": "Eclipse中Maven项目创建Maven项目创建项目创建之后，要到javax.servlet下的包资源会报错解决方法搭建SSM配置web.xml  配置DispatcherServlet，是SpringMVC的核心组件，用于接收所有请求，然后分发到各控制器，在配置时，必须确定初始化时加载的Spring配置文件是哪些！配置CharacterEncodingFilter，即字符编码过滤器，用于设置接收请求参数时的编码、响应的编码，必须确定所使用的编码。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns=\"http://java.sun.com/xml/ns/javaee\"\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\tversion=\"2.5\"&gt;\t&lt;display-name&gt;myssm&lt;/display-name&gt;\t&lt;welcome-file-list&gt;\t\t&lt;welcome-file&gt;index.html&lt;/welcome-file&gt;\t\t&lt;welcome-file&gt;index.htm&lt;/welcome-file&gt;\t\t&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\t\t&lt;welcome-file&gt;default.html&lt;/welcome-file&gt;\t\t&lt;welcome-file&gt;default.htm&lt;/welcome-file&gt;\t\t&lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;\t&lt;/welcome-file-list&gt;\t&lt;!-- 配置是哪个Servlet --&gt;\t&lt;servlet&gt;\t\t&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;\t\t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\t\t&lt;!-- 当Servlet被初始化时加载Spring配置文件 --&gt;\t\t&lt;init-param&gt;\t\t\t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\t\t\t&lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;\t\t&lt;/init-param&gt;\t\t&lt;!-- 当Tomcat启动时就初始化当前Servlet --&gt;\t\t&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\t&lt;/servlet&gt;\t&lt;!-- 配置Servlet对应的请求路径 --&gt;\t&lt;servlet-mapping&gt;\t\t&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;\t\t&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;\t&lt;/servlet-mapping&gt;\t&lt;!-- 配置字符编码过滤器 --&gt;\t&lt;filter&gt;\t\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\t\t&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\t\t&lt;init-param&gt;\t\t\t&lt;param-name&gt;encoding&lt;/param-name&gt;\t\t\t&lt;param-value&gt;utf-8&lt;/param-value&gt;\t\t&lt;/init-param&gt;\t&lt;/filter&gt;\t&lt;filter-mapping&gt;\t\t&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;\t\t&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\t&lt;/filter-mapping&gt;&lt;/web-app&gt;配置spring-mvc.xml  应该配置组件扫描，扫描目标是控制器类所在的包，虽然该功能可以配置为根级包，但是，不推荐这样做！关于视图解析器，使用的InternalResourceViewResolver，需要配置前缀和后缀，本次应该把前缀配置为/，而不是/WEB-INF/，主要是考虑到有HTML、CSS、JS文件，这些文件如果存放在/WEB-INF/下是无法被用户访问的！关于拦截器，本项目也需要使用登录拦截器，所以，把此前项目中的拦截器类复制到当前项目，并调整配置，主要是拦截器类所在的包！关于注解驱动，是固定的配置，每个项目中都添加即可。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\"\txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\txmlns:jee=\"http://www.springframework.org/schema/jee\"\txmlns:tx=\"http://www.springframework.org/schema/tx\"\txmlns:aop=\"http://www.springframework.org/schema/aop\"\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txmlns:util=\"http://www.springframework.org/schema/util\"\txmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\txsi:schemaLocation=\"\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\t\thttp://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd\t\thttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\t\thttp://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\t\thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd\"&gt;\t&lt;!-- 开启组件扫描 --&gt;\t&lt;context:component-scan\t\tbase-package=\"cn.myssm.store.controller\" /&gt;\t&lt;!-- 视图解析器：根据视图名称得到视图资源 --&gt;\t&lt;bean\t\tclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\t\t&lt;!-- 配置前缀 --&gt;\t\t&lt;property name=\"prefix\" value=\"/WEB-INF/\" /&gt;\t\t&lt;!-- 配置后缀 --&gt;\t\t&lt;property name=\"suffix\" value=\".jsp\" /&gt;\t&lt;/bean&gt;\t&lt;!-- 配置拦截器链 --&gt;\t&lt;mvc:interceptors&gt;\t\t&lt;!-- 配置第1个拦截器 --&gt;\t\t&lt;mvc:interceptor&gt;\t\t\t&lt;!-- 1. 拦截的路径 --&gt;\t\t\t&lt;mvc:mapping path=\"/user/**\" /&gt;\t\t\t&lt;mvc:mapping path=\"/main/index.do\" /&gt;\t\t\t&lt;!-- 2. 例外的路径，不拦截的路径，即白名单 --&gt;\t\t\t&lt;mvc:exclude-mapping path=\"/user/reg.do\" /&gt;\t\t\t&lt;mvc:exclude-mapping path=\"/user/handle_reg.do\" /&gt;\t\t\t&lt;mvc:exclude-mapping path=\"/user/login.do\" /&gt;\t\t\t&lt;mvc:exclude-mapping path=\"/user/handle_login.do\" /&gt;\t\t\t&lt;!-- 3. 指定拦截器类 --&gt;\t\t\t&lt;bean class=\"cn.myssm.store.interceptor.LoginInterceptor\" /&gt;\t\t&lt;/mvc:interceptor&gt;\t&lt;/mvc:interceptors&gt;\t&lt;!-- 注解驱动 --&gt;\t&lt;mvc:annotation-driven /&gt;&lt;/beans&gt;配置spring-service.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"  \txmlns:jee=\"http://www.springframework.org/schema/jee\" \txmlns:tx=\"http://www.springframework.org/schema/tx\"\txmlns:aop=\"http://www.springframework.org/schema/aop\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txmlns:util=\"http://www.springframework.org/schema/util\"\txmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\txsi:schemaLocation=\"\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\t\thttp://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd\t\thttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\t\thttp://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\t\thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd\"&gt;\t&lt;!-- 开启组件扫描 --&gt;\t&lt;context:component-scan \t\tbase-package=\"cn.myssm.store.service.impl\" /&gt;&lt;/beans&gt;配置db.properties  重点检查url中的数据库名称、password的值！     url=jdbc:mysql://localhost:3306/myssm?useUnicode=true&amp;characterEncoding=utf8   driver=com.mysql.jdbc.Driver   username=root   password=123456   initialSize=5   maxActive=50  配置spring-dao.xml关于加载db.properties，通常是固定做法，即使更换项目也无须修改！关于BasicDataSource，也是固定做法，无须修改！关于MapperScannerConfigurer，需要检查持久层接口所在的包！关于SqlSessionFactoryBean，需要检查持久层映射的XML文件所在的文件夹！&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"  \txmlns:jee=\"http://www.springframework.org/schema/jee\" \txmlns:tx=\"http://www.springframework.org/schema/tx\"\txmlns:aop=\"http://www.springframework.org/schema/aop\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\txmlns:util=\"http://www.springframework.org/schema/util\"\txmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\txsi:schemaLocation=\"\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd\t\thttp://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd\t\thttp://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd\t\thttp://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd\t\thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\t\thttp://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd\"&gt;\t\t&lt;!-- 读取db.properties --&gt;\t&lt;util:properties id=\"dbConfig\"\t\tlocation=\"classpath:db.properties\" /&gt;\t\t\t&lt;!-- 配置数据源：BasicDataSource --&gt;\t&lt;bean id=\"ds\" \t\tclass=\"org.apache.commons.dbcp.BasicDataSource\"&gt;\t\t&lt;!-- 以下配置中 --&gt;\t\t&lt;!-- name的值是BasicDataSource中的属性名(方法名) --&gt;\t\t&lt;!-- value的值是引用以上读取的配置文件 --&gt;\t\t&lt;property name=\"url\" \t\t\tvalue=\"#{dbConfig.url}\" /&gt;\t\t&lt;property name=\"driverClassName\" \t\t\tvalue=\"#{dbConfig.driver}\" /&gt;\t\t&lt;property name=\"username\" \t\t\tvalue=\"#{dbConfig.username}\" /&gt;\t\t&lt;property name=\"password\" \t\t\tvalue=\"#{dbConfig.password}\" /&gt;\t\t&lt;property name=\"initialSize\" \t\t\tvalue=\"#{dbConfig.initialSize}\" /&gt;\t\t&lt;property name=\"maxActive\" \t\t\tvalue=\"#{dbConfig.maxActive}\" /&gt;\t&lt;/bean&gt;\t\t&lt;!-- 配置MapperScannerConfigurer --&gt;\t&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\t\t&lt;!-- 配置接口文件所在的包 --&gt;\t\t&lt;property name=\"basePackage\"\t\t\tvalue=\"cn.myssm.store.mapper\" /&gt;\t&lt;/bean&gt;\t\t&lt;!-- 配置SqlSessionFactoryBean --&gt;\t&lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\t\t&lt;!-- 配置使用哪个数据源，ref属性的值是前序配置的数据源的bean id --&gt;\t\t&lt;property name=\"dataSource\" \t\t\tref=\"ds\" /&gt;\t\t&lt;!-- 配置XML映射文件的位置 --&gt;\t\t&lt;property name=\"mapperLocations\"\t\t\tvalue=\"classpath:mappers/*.xml\" /&gt;\t&lt;/bean&gt;beans&gt;配置mappers/UserMapper.xml这个配置文件主要是和接口对应起来，UserMapper.xml类似的xml文件主要是写SQL语句关于一些Xml语句的增删改查写法请查阅先关资料&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;  &lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\"      \t\"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"cn.myssm.store.mapper.UserMapper\"&gt;\t&lt;!-- 插入用户数据 --&gt;\t&lt;!-- Integer insert(User user) --&gt;\t&lt;insert id=\"insert\"\t\tparameterType=\"cn.myssm.store.entity.User\"\t\tuseGeneratedKeys=\"true\"\t\tkeyProperty=\"id\"&gt;\t\tINSERT INTO t_user (\t\t\tusername,\t\t\tpassword,\t\t\temail,\t\t\tphone,\t\t\tgender,\t\t\tavatar,\t\t\tsalt,\t\t\tstatus,\t\t\tis_delete,\t\t\tcreated_user,\t\t\tcreated_time,\t\t\tmodified_user,\t\t\tmodified_time\t\t) VALUES (\t\t\t#{username},\t\t\t#{password},\t\t\t#{email},\t\t\t#{phone},\t\t\t#{gender},\t\t\t#{avatar},\t\t\t#{salt},\t\t\t#{status},\t\t\t#{isDelete},\t\t\t#{createdUser},\t\t\t#{createdTime},\t\t\t#{modifiedUser},\t\t\t#{modifiedTime}\t\t)\t&lt;/insert&gt;&lt;/mapper&gt;pom.xmlpom文件管理jar依赖&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.myssm.hyper&lt;/groupId&gt;  &lt;artifactId&gt;myssm&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;dependencies&gt;\t\t&lt;!-- SpringMVC --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\t\t\t&lt;version&gt;4.3.9.RELEASE&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- Spring-JDBC --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\t\t\t&lt;version&gt;4.3.9.RELEASE&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- JUnit：单元测试 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;junit&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;junit&lt;/artifactId&gt;\t\t\t&lt;version&gt;4.12&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- MyBatis --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis&lt;/artifactId&gt;\t\t\t&lt;version&gt;3.4.6&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- MyBatis整合Spring --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.3.2&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- MySQL --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;mysql&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\t\t\t&lt;version&gt;5.1.6&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- DBCP --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.4&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t&lt;!-- Jackson：解决ResponseBody的乱码问题，且自动装响应结果设置为json --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\t\t\t&lt;version&gt;2.9.7&lt;/version&gt;\t\t&lt;/dependency&gt;\t\t\t\t&lt;!-- 文件上传 --&gt;\t\t&lt;dependency&gt;\t\t\t&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\t\t\t&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\t\t\t&lt;version&gt;1.3.3&lt;/version&gt;\t\t&lt;/dependency&gt;\t&lt;/dependencies&gt;  &lt;/project&gt;包结构Redis操作系统安装Redis  电脑主系统是Windows因此为了方便，在Windows系统安装SecureCRT来链接Linux系统。  下载redis压缩包：http://www.redis.cn/download.html  安装redis需要gcc环境，因此Linux系统中需要安装gcc环境：yum install gcc-c++$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz$ cd redis-5.0.3$ make$ src/redis-server修改后台启动Redis修改redis.conf文件 daemonize yes（大概在100+行）pom.xml文件中添加jar包  &lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;     &lt;artifactId&gt;jedis&lt;/artifactId&gt;     &lt;version&gt;2.9.0&lt;/version&gt;   &lt;/dependency&gt;redis.properties    redis.hostname=47.94.3.11    redis.port=6379    redis.database=0    redis.pool.maxActive=600    redis.pool.maxIdle=300    redis.pool.maxWait=3000    redis.pool.testOnBorrow=truespring-redis.xml&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\"\txsi:schemaLocation=\"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-3.2.xsd\"&gt;\t&lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt;\t\t&lt;property name=\"maxTotal\" value=\"${redis.pool.maxActive}\" /&gt;\t\t&lt;property name=\"maxIdle\" value=\"${redis.pool.maxIdle}\" /&gt;\t\t&lt;property name=\"maxWaitMillis\" value=\"${redis.pool.maxWait}\" /&gt;\t\t&lt;property name=\"testOnBorrow\" value=\"${redis.pool.testOnBorrow}\" /&gt;\t&lt;/bean&gt; \t&lt;bean id=\"jedisWritePool\" class=\"com.imooc.myo2o.cache.JedisPoolWriper\"\t\tdepends-on=\"jedisPoolConfig\"&gt;\t\t&lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\" /&gt;\t\t&lt;constructor-arg index=\"1\" value=\"${redis.hostname}\" /&gt;\t\t&lt;constructor-arg index=\"2\" value=\"${redis.port}\" type=\"int\" /&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisKeys\" class=\"com.imooc.myo2o.cache.JedisUtil$Keys\"\t\tscope=\"singleton\"&gt;\t\t&lt;constructor-arg ref=\"jedisUtil\"&gt;&lt;/constructor-arg&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisStrings\" class=\"com.imooc.myo2o.cache.JedisUtil$Strings\"\t\tscope=\"singleton\"&gt;\t\t&lt;constructor-arg ref=\"jedisUtil\"&gt;&lt;/constructor-arg&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisLists\" class=\"com.imooc.myo2o.cache.JedisUtil$Lists\"\t\tscope=\"singleton\"&gt;\t\t&lt;constructor-arg ref=\"jedisUtil\"&gt;&lt;/constructor-arg&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisSets\" class=\"com.imooc.myo2o.cache.JedisUtil$Sets\"\t\tscope=\"singleton\"&gt;\t\t&lt;constructor-arg ref=\"jedisUtil\"&gt;&lt;/constructor-arg&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisHash\" class=\"com.imooc.myo2o.cache.JedisUtil$Hash\"\t\tscope=\"singleton\"&gt;\t\t&lt;constructor-arg ref=\"jedisUtil\"&gt;&lt;/constructor-arg&gt;\t&lt;/bean&gt;\t&lt;bean id=\"jedisUtil\" class=\"com.imooc.myo2o.cache.JedisUtil\"\t\tscope=\"singleton\"&gt;\t\t&lt;property name=\"jedisPool\"&gt;\t\t\t&lt;ref bean=\"jedisWritePool\" /&gt;\t\t&lt;/property&gt;\t&lt;/bean&gt;&lt;/beans&gt;    web.xml中配置 spring-redis.xml、redis.properties即可"
  },
  
  {
    "title": "beego 路由设置",
    "url": "/posts/beego-router/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoWeb, Beego",
    "date": "2019-05-06 15:21:24 +0800",
    





    
    "snippet": "路由注解routers  // routers/routers.go  package routers  import (    \"lichaocheng/yun_mao/controllers\"    \"github.com/astaxie/beego\"  )  func init() {    ns := beego.NewNamespace(\"/v1\",      beego.NSNa...",
    "content": "路由注解routers  // routers/routers.go  package routers  import (    \"lichaocheng/yun_mao/controllers\"    \"github.com/astaxie/beego\"  )  func init() {    ns := beego.NewNamespace(\"/v1\",      beego.NSNamespace(\"/test\",        beego.NSInclude(          &amp;test.StatisticsController{},        ),      ),    )    beego.AddNamespace(ns)  }controller  package home  import (    \"github.com/astaxie/beego\"  )  type Test struct {    beego.Controller  }  func (this *Test) URLMapping() {    this.Mapping(\"Test\", this.Test)  }  // Test TestCode  // @Title test  // @Description test  // @Param\tbody \ttrue \"test\"  // @Success 201  // @Failure 403  // @router /test/get/name [Post]  func (this *Test) Test() {      fmt.Println(\"Test\")  }配置文件conf/app.confEnableDocs=true启动目录bee run -gendoc=true -downdoc=true生成commentsRouter*.go注意事项  main.go 增加    if beego.BConfig.RunMode == \"dev\" {      beego.BConfig.WebConfig.DirectoryIndex = true      beego.BConfig.WebConfig.StaticDir[\"/swagger\"] = \"swagger\"    }  必须在gopath          route.go 注解路由运行是通过 CommentRouterPath 解析的，会在同文件下生成 commentsRouter_controllers.go 文件，但需要注意工程必须在 GOPATH 路径下，不然无法生成，也会无法匹配路由      操作步骤                  如果是 go mod init test/testv1          export GO111MODULE=off          cd gopath/src          mkdir test          cd test          mkdir testv1          cp code .          bee run -gendoc=true -downdoc=true          cd router                                                                      ls                  grep “mmentsRouter”                                                              cp 生成的文件 go mod 目录下          export GO111MODULE=on          bee run -gendoc=true -downdoc=true          启动项目                    "
  },
  
  {
    "title": "beego 高级编程",
    "url": "/posts/beego-pro/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoWeb, Beego",
    "date": "2019-05-06 15:21:24 +0800",
    





    
    "snippet": "beego 高级编程进程内监控API 自动化文档API 全局设置  必须设置在 routers/router.go 文件的注释，最顶部：  // @APIVersion 1.0.0  // @Title mobile API  // @Description mobile has every tool to get any job done, so codename for the new ...",
    "content": "beego 高级编程进程内监控API 自动化文档API 全局设置  必须设置在 routers/router.go 文件的注释，最顶部：  // @APIVersion 1.0.0  // @Title mobile API  // @Description mobile has every tool to get any job done, so codename for the new mobile APIs.  // @Contact astaxie@gmail.com  package routers全局的注释如上所示，是显示给全局应用的设置信息，有如下这些设置  @APIVersion  @Title  @Description  @Contact  @TermsOfServiceUrl  @License  @LicenseUrl路由解析须知目前自动化文档只支持如下的写法的解析，其他写法函数不会自动解析，即 namespace+Include 的写法，而且只支持二级解析，一级版本号，二级分别表示应用模块  func init() {      ns :=          beego.NewNamespace(\"/v1\",              beego.NSNamespace(\"/customer\",                  beego.NSInclude(                      &amp;controllers.CustomerController{},                      &amp;controllers.CustomerCookieCheckerController{},                  ),              ),              beego.NSNamespace(\"/catalog\",                  beego.NSInclude(                      &amp;controllers.CatalogController{},                  ),              ),              beego.NSNamespace(\"/newsletter\",                  beego.NSInclude(                      &amp;controllers.NewsLetterController{},                  ),              ),              beego.NSNamespace(\"/cms\",                  beego.NSInclude(                      &amp;controllers.CMSController{},                  ),              ),              beego.NSNamespace(\"/suggest\",                  beego.NSInclude(                      &amp;controllers.SearchController{},                  ),              ),          )      beego.AddNamespace(ns)  }应用注释  package controllers  import \"github.com/astaxie/beego\"  // CMS API  type CMSController struct {      beego.Controller  }  func (c *CMSController) URLMapping() {      c.Mapping(\"StaticBlock\", c.StaticBlock)      c.Mapping(\"Product\", c.Product)  }  // @Title getStaticBlock  // @Description get all the staticblock by key  // @Param   key     path    string  true        \"The email for login\"  // @Success 200 {object} models.ZDTCustomer.Customer  // @Failure 400 Invalid email supplied  // @Failure 404 User not found  // @router /staticblock/:key [get]  func (c *CMSController) StaticBlock() {  }  // @Title Get Product list  // @Description Get Product list by some info  // @Success 200 {object} models.ZDTProduct.ProductList  // @Param   category_id     query   int false       \"category id\"  // @Param   brand_id    query   int false       \"brand id\"  // @Param   query   query   string  false       \"query of search\"  // @Param   segment query   string  false       \"segment\"  // @Param   sort    query   string  false       \"sort option\"  // @Param   dir     query   string  false       \"direction asc or desc\"  // @Param   offset  query   int     false       \"offset\"  // @Param   limit   query   int     false       \"count limit\"  // @Param   price           query   float       false       \"price\"  // @Param   special_price   query   bool        false       \"whether this is special price\"  // @Param   size            query   string      false       \"size filter\"  // @Param   color           query   string      false       \"color filter\"  // @Param   format          query   bool        false       \"choose return format\"  // @Failure 400 no enough input  // @Failure 500 get products common error  // @router /products [get]  func (c *CMSController) Product() {  }Other  首先是 CMSController 定义上面的注释，这个是用来显示这个模块的作用。接下来就是每一个函数上面的注释，这里列出来支持的各种注释：@Title这个 API 所表达的含义，是一个文本，空格之后的内容全部解析为 title@Description这个 API 详细的描述，是一个文本，空格之后的内容全部解析为 Description@Param参数，表示需要传递到服务器端的参数，有五列参数，使用空格或者 tab 分割，五个分别表示的含义如下参数名参数类型，可以有的值是 formData、query、path、body、header，formData 表示是 post 请求的数据，query 表示带在 url 之后的参数，path 表示请求路径上得参数，例如上面例子里面的 key，body 表示是一个 raw 数据请求，header 表示带在 header 信息中得参数。参数类型是否必须注释@Success成功返回给客户端的信息，三个参数，第一个是 status code。第二个参数是返回的类型，必须使用 {} 包含，第三个是返回的对象或者字符串信息，如果是 {object} 类型，那么 bee 工具在生成 docs 的时候会扫描对应的对象，这里填写的是想对你项目的目录名和对象，例如 models.ZDTProduct.ProductList 就表示 /models/ZDTProduct 目录下的 ProductList 对象。三个参数必须通过空格分隔@Failure失败返回的信息，包含两个参数，使用空格分隔，第一个表示 status code，第二个表示错误信息@router路由信息，包含两个参数，使用空格分隔，第一个是请求的路由地址，支持正则和自定义路由，和之前的路由规则一样，第二个参数是支持的请求方法,放在 [] 之中，如果有多个方法，那么使用 , 分隔。自动化生成文档  第一开启应用内文档开关，在配置文件中设置：EnableDocs = true  然后在你的 main.go 函数中引入 _ “beeapi/docs”（beego 1.7.0 之后版本不需要添加该引用）  这样你就已经内置了 docs 在你的 API 应用中，然后你就使用 bee run -gendoc=true -downdoc=true,让我们的 API 应用跑起来，-gendoc=true 表示每次自动化的 build 文档，-downdoc=true 就会自动的下载 swagger 文档查看器备注CORS两种解决方案：把 swagger 集成到应用中，下载请到 swagger,然后放在项目目录下：if beego.BConfig.RunMode == \"dev\" {    beego.BConfig.WebConfig.DirectoryIndex = true    beego.BConfig.WebConfig.StaticDir[\"/swagger\"] = \"swagger\"}API 增加 CORS 支持ctx.Output.Header(\"Access-Control-Allow-Origin\", \"*\")自动生成代码bee generate appcode -tables=\"news\" -conn=\"root:123123@tcp(127.0.0.1:3306)/beegodb\"bee generate appcode -tables=\"cargo_track\" -conn=\"root:zhly@2019@tcp(47.244.225.92:9936)/yun_mao?charset=utf8&amp;loc=Asia%2FShanghai\"bee generate scaffold goods -fields=\"id:int,name:string,image:string\" -conn=\"root:123123@tcp(127.0.0.1:3306)/beegodb\""
  },
  
  {
    "title": "Beego MVC",
    "url": "/posts/beego-mvc/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoWeb, Beego",
    "date": "2019-05-06 15:21:24 +0800",
    





    
    "snippet": "beego MVC自动生成 controller 和 models  bee generate appcode -tables=\"integral_acquisition\" -conn=\"shareaio_server:shareaio@2019@tcp(47.244.225.92:9936)/shareaio_server\"controller接口 swagger  func (this ...",
    "content": "beego MVC自动生成 controller 和 models  bee generate appcode -tables=\"integral_acquisition\" -conn=\"shareaio_server:shareaio@2019@tcp(47.244.225.92:9936)/shareaio_server\"controller接口 swagger  func (this *StatisticsController) URLMapping() {    this.Mapping(\"VisitorTraffic\", this.VisitorTraffic)  }  // @Summary 首页点赞  // @Title 标题  // @Description 描述  // @Param   Authorization     header    string  true       \"Authorization\"  // @Success 200 {object} models.ZDTProduct.ProductList  // @Failure  // @router /test [get]  func (this *StatisticsController) VisitorTraffic() {  }model一对多      一对多关系info 多个订单Info 里面写    InfoOrder \t\t[]*InfoOrder \t`orm:\"reverse(many)\"` //设置一对多的反向关系        OrderInfo 里面写    Info        \t*Info \t\t\t `orm:\"rel(fk)\"`  //设置一对多关系            多对多  struct  type Id struct {    Id int64 `json:\"id,omitempty\"`//第一个为显示的json数据名称；第二个设置为空就不展示  }字段备注  type User struct{    Id int64 `orm:\"auto;description(id)\" json:\"id\"`    UId int64 `orm:\"size(11);description(余额支付的用户名)\" json:\"u_id\"`  }  CREATE TABLE `t_user` (    `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',    `u_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '余额支付的用户名',    PRIMARY KEY (`id`)  ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;view"
  },
  
  {
    "title": "Beego Error",
    "url": "/posts/beego-error/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoWeb, Beego",
    "date": "2019-05-06 15:21:24 +0800",
    





    
    "snippet": "Beego 错误信息记载1.swagger 错误信息注解写错了  可以用以下方式解决：检查那个地方出错，建议使用下面的第一种方法  bee generate docs  bee run watchall true2.MySQL 运行时突然停止了错误1、查看 mysql 版本方法一：status;方法二：select version();2、Mysql 启动、停止、重启常用命令a、启动方式1、...",
    "content": "Beego 错误信息记载1.swagger 错误信息注解写错了  可以用以下方式解决：检查那个地方出错，建议使用下面的第一种方法  bee generate docs  bee run watchall true2.MySQL 运行时突然停止了错误1、查看 mysql 版本方法一：status;方法二：select version();2、Mysql 启动、停止、重启常用命令a、启动方式1、使用 service 启动：[root@localhost /]# service mysqld start (5.0 版本是 mysqld)[root@szxdb etc]# service mysql start (5.5.7 版本是 mysql)2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start3、使用 safe_mysqld 启动：safe_mysqld&amp;b、停止1、使用 service 启动：service mysqld stop2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop3、mysqladmin shutdownc、重启1、使用 service 启动：service mysqld restartservice mysql restart (5.5.7 版本命令)2、使用 mysqld 脚本启动：/etc/init.d/mysqld restart3.redis 初始化错误dial tcp 127.0.0.1:6379: connectex: No connection could be made because the target machine actively refused it.  解决方案  检查 redis 是否正常启动  检查 redis IP 地址与密码          检查方案              进入相应的 reids 安装的目录                  windows 与 Linux                      Windows：redis-server.exe redis.windows.conflinux：./src/redis-server redis.conf &amp;                              3.Linux 开启端口  我们可以输入命令查看防火墙的状态firewall-cmd –state  如果上一步处于关闭状态，输入命令systemctl start firewalld.service  开启 8080 端口，输入命令firewall-cmd –zone=public –add-port=8080/tcp –permanent          让我们来解释一下上一个命令：        –zone=public：表示作用域为公共的；–add-port=8080/tcp：添加 tcp 协议的端口 8080；–permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；  输入命令重启防火墙systemctl restart firewalld.service  输入命令重新载入配置firewall-cmd –reloadmodel  Handler crashed with error  table name:未找到表解决分布式跨域问题  beego.InsertFilter(\"*\", beego.BeforeRouter, cors.Allow(&amp;cors.Options{      AllowAllOrigins:  true,      AllowMethods:     []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},      AllowHeaders:     []string{\"Origin\", \"Authorization\", \"Access-Control-Allow-Origin\", \"Access-Control-Allow-Headers\", \"Content-Type\"},      ExposeHeaders:    []string{\"Content-Length\", \"Access-Control-Allow-Origin\", \"Access-Control-Allow-Headers\", \"Content-Type\"},      AllowCredentials: true,  }))"
  },
  
  {
    "title": "Beego Base",
    "url": "/posts/base-beego/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoWeb, Beego",
    "date": "2019-05-06 15:21:24 +0800",
    





    
    "snippet": "BeegoGithubCreate hello directory, cd hello directorymkdir hellocd helloInit modulego mod initDownload and installgo get github.com/beego/beego/v2@latestCreate file hello.go```gopackage mainimport ...",
    "content": "BeegoGithubCreate hello directory, cd hello directorymkdir hellocd helloInit modulego mod initDownload and installgo get github.com/beego/beego/v2@latestCreate file hello.go```gopackage mainimport \"github.com/beego/beego/v2/server/web\"func main() {  web.Run()}```Build and rungo build hello.go./helloGo to http://localhost:8080Congratulations! You’ve just built your first beego app.Features  RESTful support  MVC architecture  Modularity  Auto API documents  Annotation router  Namespace  Powerful development tools  Full stack for Web &amp; APIModules  orm  session  logs  config  cache  context  admin  httplib  task  i18nCommunity  Welcome to join us in Slack: https://beego.slack.com invite,  QQ Group ID:523992905  Contribution Guide.Licensebeego source code is licensed under the Apache Licence, Version 2.0(https://www.apache.org/licenses/LICENSE-2.0.html)."
  },
  
  {
    "title": "Go Github Project",
    "url": "/posts/go-github-project/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoUtils",
    "date": "2019-04-29 22:58:36 +0800",
    





    
    "snippet": "Github Golang Package读取配置文件包  https://github.com/spf13/viper  参考链接监听文件  https://github.com/fsnotify/fsnotify  参考链接交叉变异工具  github.com/mitchellh/gox  参考链接sgox -os=\"windows linux\" -arch=\"amd64\" ./钉钉自定...",
    "content": "Github Golang Package读取配置文件包  https://github.com/spf13/viper  参考链接监听文件  https://github.com/fsnotify/fsnotify  参考链接交叉变异工具  github.com/mitchellh/gox  参考链接sgox -os=\"windows linux\" -arch=\"amd64\" ./钉钉自定义机器人https://github.com/blinkbean/dingtalk"
  },
  
  {
    "title": "Golang 代码规范",
    "url": "/posts/other/",
    "categories": "Language, Go",
    "tags": "Go",
    "date": "2019-04-29 22:58:36 +0800",
    





    
    "snippet": "代码规范Go 代码规范（或 Go 规范）旨在使代码更具可读性、可维护性和可重用性。以下是一些主要的规则：  格式化：使用 gofmt 工具来格式化代码以提高可读性。  命名：遵循有意义的命名方式，使用驼峰式命名法，在变量名和函数名中使用小写字母开头，公共函数和变量名应该首字母大写。  注释：对于每一个包、函数、类型、方法和变量都应该添加注释，尽可能用单行注释。  导入：将所有依赖项导入放在文...",
    "content": "代码规范Go 代码规范（或 Go 规范）旨在使代码更具可读性、可维护性和可重用性。以下是一些主要的规则：  格式化：使用 gofmt 工具来格式化代码以提高可读性。  命名：遵循有意义的命名方式，使用驼峰式命名法，在变量名和函数名中使用小写字母开头，公共函数和变量名应该首字母大写。  注释：对于每一个包、函数、类型、方法和变量都应该添加注释，尽可能用单行注释。  导入：将所有依赖项导入放在文件顶部。  错误处理：避免使用 panic 和 recover 函数，应该使用错误处理机制来处理错误。  测试：为每个函数编写测试代码，并确保测试覆盖率达到最大程度。  接口：尽可能使用接口类型而不是具体类型，因为接口类型灵活且易于扩展。  并发：使用 goroutine 和通道来实现并发操作，而不是使用共享内存。  包结构：将相关的函数和变量组织成包，同时避免循环依赖。  性能：尽可能使用指针和原始数据类型来提高性能，同时避免过度优化。详细解释      格式化：Go 官方推荐使用 gofmt 工具进行格式化。gofmt 是一个命令行工具，它会自动将代码格式化为 Go 规范。例如：    // 不符合 Go 规范的写法if (x==0) {    // ...}// 符合 Go 规范的写法if x == 0 {    // ...}            命名：在 Go 语言中，驼峰式命名法是首选。变量名和函数名应该以小写字母开头，公共函数和变量名（可以被其他包访问）应该首字母大写。另外，名称应该尽可能地表达其含义，避免缩写或不必要的简称。例如：    // 不符合 Go 规范的写法var num intfunc calc(x int, y int) int {}// 符合 Go 规范的写法var number intfunc Calculate(x int, y int) int {}            注释：在 Go 语言中，注释使用 // 或 /* ... */ 来表示单行或多行注释。每个包、函数、类型、方法和变量都应该添加注释，以便其他人更容易理解你的代码。注释应该简短、精确，尽可能用单行注释。例如：    // 计算两个数字的和func Add(x int, y int) int {    return x + y}            导入：在 Go 语言中，应该将所有依赖项导入放在文件顶部，每个导入占一行，并按字母顺序排列。如果要使用包中的某些函数或变量，应该使用包名称作为前缀。例如：    import (    \"fmt\"    \"io/ioutil\"    \"net/http\")func main() {    resp, err := http.Get(\"http://example.com\")    if err != nil {        // ...    }    defer resp.Body.Close()    body, err := ioutil.ReadAll(resp.Body)    if err != nil {        // ...    }    fmt.Println(string(body))}            错误处理：在 Go 语言中，错误处理是一种重要的编程技术。通常情况下，函数返回值应该包括一个 error 类型的变量，用于指示函数执行是否成功。可以使用 errors 包来创建自定义错误。例如：    func DoSomething() error {    if err := doStep1(); err != nil {        return err    }    if err := doStep2(); err != nil {        return err    }    return nil}func doStep1() error {    // 如果发生错误，则返回自定义的错误    return errors.New(\"发生了一个错误\")}            测试：为每个函数和方法编写测试代码是 Go 语言中的一条重要规则。测试代码应该覆盖每个函数的所有分支路径，以保证代码质量。同时，应该使用测试框架（如 Go 的内置测试框架）来自动运行测试代码。例如：    func TestAdd(t *testing.T) {    result := Add(2, 3)    if result != 5 {        t.Errorf(\"Add(2, 3) = %d; want 5\", result)    }}      "
  },
  
  {
    "title": "Day14（testing）",
    "url": "/posts/14-testing/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:14 +0800",
    





    
    "snippet": "testing  Golang 自带了一个轻量级的测试框架，可以用来编写单元测试和基准测试。该测试框架主要包含了以下几个组件：  testing.T 结构体：代表了一个单元测试，它包含了一系列断言函数，用于判断测试结果是否正确；  testing.B 结构体：代表了一个基准测试，它用于测试代码的性能；  testing.M 结构体：代表了一个测试 suite，可以用于对一组测试进行分组；  ...",
    "content": "testing  Golang 自带了一个轻量级的测试框架，可以用来编写单元测试和基准测试。该测试框架主要包含了以下几个组件：  testing.T 结构体：代表了一个单元测试，它包含了一系列断言函数，用于判断测试结果是否正确；  testing.B 结构体：代表了一个基准测试，它用于测试代码的性能；  testing.M 结构体：代表了一个测试 suite，可以用于对一组测试进行分组；  testing.TB 接口：是 testing.T 和 testing.B 的父接口，提供了一些公共的方法，比如 Log、Fail 等。测试框架提供了一系列的函数，用于编写测试用例和基准测试，例如：  func TestXxx(*testing.T)：用于编写单元测试，其中 Xxx 是测试函数的名称；  func BenchmarkXxx(*testing.B)：用于编写基准测试，其中 Xxx 是测试函数的名称；  func Example()：用于编写示例代码，用于生成文档。下面是一个简单的示例，演示了如何使用 testing.T 编写单元测试：package mainimport \"testing\"func TestAdd(t *testing.T) {    result := Add(2, 3)    expected := 5    if result != expected {        t.Errorf(\"Add(2, 3) = %d, expected %d\", result, expected)    }}func Add(a, b int) int {    return a + b}  在上面的代码中，我们定义了一个 Add() 函数，它接收两个整数参数，并返回它们的和。然后，我们使用 TestAdd() 函数编写了一个单元测试，其中通过调用 Add() 函数来计算 2 + 3 的结果，并使用 t.Errorf() 函数来判断计算结果是否等于期望结果。我们可以通过运行 go test 命令来运行这个测试，例如：$ go test -v=== RUN   TestAdd--- PASS: TestAdd (0.00s)PASSok      _/home/user/example    0.001s"
  },
  
  {
    "title": "Day13（Time）",
    "url": "/posts/13-time/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:13 +0800",
    





    
    "snippet": "时间包  时间包 time 提供了日期和时间相关的函数和结构体。使用这个包可以完成时间格式化、时间比较、定时器等功能获取当前时间now := time.Now()fmt.Println(now)时间格式化输出t := time.Now()fmt.Println(t.Format(\"2006-01-02 15:04:05\"))时间比较t1 := time.Date(2021, 1, 1, 0,...",
    "content": "时间包  时间包 time 提供了日期和时间相关的函数和结构体。使用这个包可以完成时间格式化、时间比较、定时器等功能获取当前时间now := time.Now()fmt.Println(now)时间格式化输出t := time.Now()fmt.Println(t.Format(\"2006-01-02 15:04:05\"))时间比较t1 := time.Date(2021, 1, 1, 0, 0, 0, 0, time.UTC)t2 := time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)if t1.Before(t2) {    fmt.Println(\"t1 is before t2\")}定时器ticker := time.NewTicker(1 * time.Second)go func() {    for t := range ticker.C {        fmt.Println(\"Tick at\", t)    }}()time.Sleep(5 * time.Second)ticker.Stop()fmt.Println(\"Ticker stopped\")  以上代码使用了 NewTicker 创建了一个 1 秒钟的定时器，然后在一个单独的 goroutine 中，使用 range 遍历了这个定时器，并在定时器到期时输出当前时间。主 goroutine 中使用 Sleep 让程序等待 5 秒钟，然后使用 Stop 停止定时器。时间包 time 还有很多其他的用法，例如定时任务、时区转换等。在 Golang 开发中，经常需要用到时间相关的操作，因此熟悉时间包的使用是很重要的。"
  },
  
  {
    "title": "Day12（反射）",
    "url": "/posts/12-reflect/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:12 +0800",
    





    
    "snippet": "反射介绍  反射是 Golang 中的一项重要特性，它提供了一种机制，可以在运行时动态地获取变量的类型信息、值信息、方法、字段等，并可以通过反射进行值的修改和调用方法。这使得 Golang 具备了更高的灵活性和通用性。  在 Golang 中，反射通过 reflect 包实现，该包提供了一些函数和类型，可以用于检查变量的类型、值、方法、字段等信息。例如，reflect.TypeOf() 函数...",
    "content": "反射介绍  反射是 Golang 中的一项重要特性，它提供了一种机制，可以在运行时动态地获取变量的类型信息、值信息、方法、字段等，并可以通过反射进行值的修改和调用方法。这使得 Golang 具备了更高的灵活性和通用性。  在 Golang 中，反射通过 reflect 包实现，该包提供了一些函数和类型，可以用于检查变量的类型、值、方法、字段等信息。例如，reflect.TypeOf() 函数可以获取变量的类型信息，reflect.ValueOf() 函数可以获取变量的值信息。通过 reflect.Value 类型，可以获取变量的字段值和方法，并进行相应的操作。  Golang 中的结构体和接口也支持反射操作。通过反射，可以获取结构体的字段名、字段类型和字段值等信息，并进行相应的修改。接口类型也支持反射，可以通过反射来查询一个接口是否实现了某个接口类型，或者获取一个接口的动态类型信息。  反射的使用需要注意性能问题。由于反射操作相对于常规的类型断言和函数调用等操作，开销要更大，因此在性能敏感的场景中要谨慎使用。此外，反射操作可能会引起一些不可预知的错误，例如类型不匹配、未导出的字段和方法等，因此在使用反射时需要格外小心。  总的来说，反射是 Golang 语言中非常重要的一项特性，它使得 Golang 具备了更高的灵活性和通用性。反射在框架、测试工具、ORM 等方面得到了广泛应用。但是，在使用反射时需要注意性能问题和潜在的错误，同时也需要遵循一些最佳实践和规范例子package mainimport (    \"fmt\"    \"reflect\")type User struct {    Name string    Age  int}func main() {    u := User{Name: \"Tom\", Age: 18}    // 获取结构体的类型信息    t := reflect.TypeOf(u)    fmt.Println(\"Type:\", t)    // 获取结构体的值信息    v := reflect.ValueOf(u)    fmt.Println(\"Value:\", v)    // 遍历结构体的字段    for i := 0; i &lt; t.NumField(); i++ {        field := t.Field(i)        value := v.Field(i)        fmt.Printf(\"Field Name: %v, Field Value: %v\\n\", field.Name, value)    }}      输出结果    Type: main.UserValue: {Tom 18}Field Name: Name, Field Value: TomField Name: Age, Field Value: 18        在上面的例子中，我们首先定义了一个结构体 User，其中包含两个字段 Name 和 Age。然后我们创建了一个 User 类型的变量 u，并使用 reflect.TypeOf() 函数获取它的类型信息，使用 reflect.ValueOf() 函数获取它的值信息。  接着，我们通过遍历结构体的字段，使用 t.Field(i) 和 v.Field(i) 分别获取字段的类型信息和值信息，并打印出来。这里需要注意的是，字段的类型信息是通过反射获取的 reflect.StructField 类型，字段的值信息是通过反射获取的 reflect.Value 类型，需要通过调用 .Name 和 .Interface() 方法来获取它们的字符串表示形式。  通过这个例子，可以看出反射在 Golang 中的使用方式，以及如何获取结构体的字段信息和值信息。"
  },
  
  {
    "title": "Day11（并发编程）",
    "url": "/posts/11-Concurrent/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:11 +0800",
    





    
    "snippet": "概念  并发：把任务在不同的时间点交给处理器进行处理同一时间点，任务并不会同时进行  并行：把每一个任务分配给每一个处理器独立完成，在同一时间点任务一定是同时运行的简介使用  创建：使用 go 关键字创建一个 goroutine go functionName()      调整并发运行性能                  例子：        runtime.GOMAXPROCS(num...",
    "content": "概念  并发：把任务在不同的时间点交给处理器进行处理同一时间点，任务并不会同时进行  并行：把每一个任务分配给每一个处理器独立完成，在同一时间点任务一定是同时运行的简介使用  创建：使用 go 关键字创建一个 goroutine go functionName()      调整并发运行性能                  例子：        runtime.GOMAXPROCS(number)number -&gt; 逻辑CPU数量number &lt; 1 不修改任务参数       = 1 单核心执行       &gt; 1 多核并发执行cpuNUmber := runtime.NumCPU() // 查询CPU数量fmt.Println(cpuNUmber)runtime.GOMAXPROCS(cpuNUmber)                            批注                  Go1.5 之前 默认使用单核执行，之后默认执行上面语句，以便让代码并发执行，最大效率的利用 CPU          GOMAXPROCS 也是环境变量，在应用启动前设置环境变量也可以起到相同的作用                    通道（channel）  在多个 goroutine 间通信的管道并发编程goroutine  时间片轮转以及调度 goroutine  协程 使用 go 关键字创建，并发执行package mainimport (\t\"fmt\"\t\"time\")func task() {\tvar i int\tfor {\t\ti++\t\tfmt.Println(\"new Task\")\t\tif i == 3 {\t\t\tbreak\t\t}\t\ttime.Sleep(time.Second)\t}}func main() {\tgo task()\tvar i int\tfor {\t\ti++\t\tfmt.Println(\"main func\")\t\tif i == 3 {\t\t\tbreak\t\t}\t\ttime.Sleep(time.Second)\t}}new Taskmain funcmain funcnew Taskmain func      主协程退出其他子协程也会退出          下面程序只会打印 main      package mainimport \"fmt\"func main(){\tgo func ()  {\t\tfor i := 0; i &lt; 5; i++ {\t\t\tfmt.Println(\"子协程\")\t\t}\t}()\tfmt.Println(\"main\")}      runtime工具包          Gosched、Goexit、GOMAXPROCS              Gosched 让出时间片 先让别的协程，执行再执行此协程        package mainimport (\t\"fmt\"\t\"runtime\")func main() {\tgo func() {\t\tfor i := 0; i &lt; 3; i++ {\t\t\tfmt.Println(\"Cc\")\t\t}\t}()\tfor i := 0; i &lt; 2; i++ {\t\truntime.Gosched()\t\tfmt.Println(\"Lcc\")\t}}        CcCcCcLccLcc              Goexit 终止此协程与 return 不同后者终止次函数        package mainimport (\t\"fmt\"\t\"runtime\"\t\"time\")func exit() {\tfmt.Println(\"exit a\")\t// return\truntime.Goexit()\tfmt.Println(\"exit b\")}func main() {\tgo func() {\t\tfmt.Println(\"go func 1\")\t\texit()\t\tfmt.Println(\"go fun 2\")\t}()\t// 等待\ttime.Sleep(time.Second * 5)}        go func 1exit a              GOMAXPROCS指定核数运行 1~4 时打印交叉        package mainimport (\t\"fmt\"\t\"runtime\"\t\"time\")func main() {\truntime.GOMAXPROCS(4)\tfor i := 0; i &lt; 100; i++ {\t\tgo fmt.Print(1)\t\tfmt.Print(0)\t}\ttime.Sleep(time.Second * 2)}      channel  资源竞争共享内存  每使用 channel 造成资源竞争和共享内存问题，两个协程同时使用 printer打印值会造成不一，不会同步，把相关的 ch 注释且可以解决package mainimport (\t\"fmt\"\t\"time\")// var ch = make(chan int)func printer(word string) {\tfor _, v := range word {\t\tfmt.Printf(\"%c\", v)\t\ttime.Sleep(time.Second)\t}}// lcc 打印 titlefunc lcc() {   //  ch &lt;- 1\tprinter(\"title\")}// Cc 打印 wordfunc Cc() {  //  &lt;- ch\tprinter(\"word\")}func main() {\tgo lcc()\tgo Cc()\ttime.Sleep(time.Second * 10)}package mainimport (\t\"fmt\")func main() {\t//创建channel\tch := make(chan string)\tdefer fmt.Println(\"main  end\")\tgo func() {\t\tdefer fmt.Println(\"func end\")\t\tfor i := 0; i &lt; 2; i++ {\t\t\tfmt.Println(\"Func for\")\t\t}\t\tch &lt;- \"ch wr\"\t}()\tstr := &lt;-ch //没有数据前，阻塞\tfmt.Println(\"rd  = \", str)}      无缓冲与有缓冲          无缓冲接收前，不会保存任何通道值，需要发送端和接收端同时准备好才能完成操纵，则会造成堵塞等待        package mainimport (\t\"fmt\"\t\"time\")func main() {\t//创建一个无缓存的channel\tch := make(chan int, 0)\t//len(ch)缓冲区剩余数据个数， cap(ch)缓冲区大小\tfmt.Printf(\"len(ch) = %d, cap(ch)= %d\\n\", len(ch), cap(ch))\t//新建协程\tgo func() {\t\tfor i := 0; i &lt; 3; i++ {\t\t\tfmt.Printf(\"子协程：i = %d\\n\", i)\t\t\tch &lt;- i //往chan写内容\t\t}\t}()\t//延时\ttime.Sleep(2 * time.Second)\tfor i := 0; i &lt; 3; i++ {\t\tnum := &lt;-ch //读管道中内容，没有内容前，阻塞\t\tfmt.Println(\"num = \", num)\t}}              有缓存接收前，会保存一个或多个通道值，只有通道没有接收值才会堵塞        package mainimport (\t\"fmt\"\t\"time\")func main() {\t//创建一个有缓存的channel\tch := make(chan int, 3)\t//len(ch)缓冲区剩余数据个数， cap(ch)缓冲区大小\tfmt.Printf(\"len(ch) = %d, cap(ch)= %d\\n\", len(ch), cap(ch))\t//新建协程\tgo func() {\t\tfor i := 0; i &lt; 10; i++ {\t\t\tch &lt;- i //往chan写内容\t\t\tfmt.Printf(\"子协程[%d]: len(ch) = %d, cap(ch)= %d\\n\", i, len(ch), cap(ch))\t\t}\t}()\t//延时\ttime.Sleep(2 * time.Second)\tfor i := 0; i &lt; 10; i++ {\t\tnum := &lt;-ch //读管道中内容，没有内容前，阻塞\t\tfmt.Println(\"num = \", num)\t}}            关闭  package mainimport \"fmt\"var ch = make(chan int)func main() {\tgo func() {\t\tfor i := 0; i &lt; 5; i++ {\t\t\tch &lt;- i\t\t}\t\tclose(ch)\t}()\tfor {\t\tif i, ok := &lt;-ch; ok == true {\t\t\tfmt.Println(i)\t\t} else {\t\t\tbreak\t\t}\t}}01234  单方向 channel(生产者、消费者)package mainimport \"fmt\"// write 写func write(write chan&lt;- string) {\tfor i := 0; i &lt; 3; i++ {\t\twrite &lt;- fmt.Sprint(\"Cc\", i)\t}\tdefer close(write)}// read 读func read(read &lt;-chan string) {\tfor v := range read {\t\tfmt.Println(v)\t}}func main() {\tch := make(chan string)\tgo write(ch)\tread(ch)}Cc 写0Cc 写1Cc 写2sync  sync.WaitGroup ，等待子协程执行完之后再退出主协程package mainimport (\t\"fmt\"\t\"sync\")func main() {\tvar group sync.WaitGroup\t// 添加两个\tgroup.Add(2)\tgo func() {\t\tfor i := 0; i &lt; 3; i++ {\t\t\tfmt.Println(\"func1 ---&gt;\", i)\t\t}\t\t// 执行完之后去除一个执行完毕\t\tgroup.Done()\t}()\tgo func() {\t\tfor i := 0; i &lt; 4; i++ {\t\t\tfmt.Println(\"func2 ---&gt;\", i)\t\t}\t\t// 去除一个执行完毕\t\tgroup.Done()\t}()\t// 等待group 数量为0 ，如果Done()方法数量和添加数量不一至，会造成deadlock! 死锁！\tgroup.Wait()}func2 ---&gt; 0func2 ---&gt; 1func2 ---&gt; 2func2 ---&gt; 3func1 ---&gt; 0func1 ---&gt; 1func1 ---&gt; 2"
  },
  
  {
    "title": "Day10（接口和错误处理）",
    "url": "/posts/10-interfaceAndError/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:10 +0800",
    





    
    "snippet": "interface And Panic、Error  源码interface接口创建使用package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"\t\"github.com/pkg/errors\")// UserInterfacetype UserInterface interface {\tAdd(User) er...",
    "content": "interface And Panic、Error  源码interface接口创建使用package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"\t\"github.com/pkg/errors\")// UserInterfacetype UserInterface interface {\tAdd(User) error\tGet(int) (User, error)\tDelete(int) error\tUpdate(User) error\tList(int, int) ([]User, int, error)}// Usertype User struct {\tId   int\tName string\tAge  int}// 获取func (u *User) Get(id int) (user User, err error) {\tif id == 0 {\t\treturn user, errors.New(\"id not\")\t}\tuser.Age = 18\tuser.Name = \"Get\"\tuser.Id = id\treturn}// Addfunc (u *User) Add(user User) error {\treturn nil}// 删除func (u *User) Delete(id int) error {\treturn nil}// 添加func (u *User) Update(user User) error {\treturn nil}// 列表func (u *User) List(l, o int) (list []User, total int, err error) {\treturn}func main() {\tvar userInterface UserInterface\tuserInterface = new(User)\tuser, err := userInterface.Get(1)\tif err != nil {\t\tlogs.Error(err.Error())\t\treturn\t}\tlogs.Info(user)\tu := new(User)\tue, err := u.Get(0)\tif err != nil {\t\tlogs.Error(err.Error())\t\treturn\t}\tlogs.Info(ue)}2020/04/25 17:55:05.333 [I] [day10.go:63]  {1 Get 18}2020/04/25 17:55:05.369 [E] [day10.go:67]  id notPanic、ErrorPanic  recover() 捕捉程序终止异常，正常的打印捕捉异常，可以试试 把 defer func(){}() 代码注释，会不会打印 usr defer ，程序会自动将整个程序全部停止package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"\t\"runtime\")func AddressOrNil(f func()) {\tdefer func() {\t\tif r := recover(); r != nil {\t\t\tswitch r.(type) {\t\t\tcase runtime.Error: // 运行时错误\t\t\t\tlogs.Info(\"runtime error:\", r)\t\t\tdefault: // 非运行时错误\t\t\t\tlogs.Info(\"error:\", r)\t\t\t}\t\t}\t}()\tf()}func main() {\tAddressOrNil(func() {\t\tvar a *struct{ Name string }\t\ta.Name = \"Cc\"\t})\tlogs.Info(\"usr defer \")}2020/04/25 18:24:27.623 [I] [panic.go:13]  runtime error: runtime error: invalid memory address or nil pointer dereference2020/04/25 18:24:27.661 [I] [panic.go:28]  usr defererror  程序中错误处理 大致分两大类：panic会造成程序终止 ， error 程序错误，或者自定义的业务逻辑不合法抛出异常  自定义方法一定业务逻辑返回 error 这个返回值是在最后一个（习惯）"
  },
  
  {
    "title": "Day09（MapAndContainer）",
    "url": "/posts/9-mapAndContainer/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:09 +0800",
    





    
    "snippet": "集合(map) 和容器(Container)源码Map  Map 是一种无序键值对的集合，通过 Key来检索数据，key 类似索引，指向数据值，可以使用 for迭代，但是 map是无序的，无法决定他的返回值顺序，这是因为 map 是使用 hash 来实现的删除元素、判断是否存在package mainimport (\t\"github.com/Cc360428/HelpPackage/Util...",
    "content": "集合(map) 和容器(Container)源码Map  Map 是一种无序键值对的集合，通过 Key来检索数据，key 类似索引，指向数据值，可以使用 for迭代，但是 map是无序的，无法决定他的返回值顺序，这是因为 map 是使用 hash 来实现的删除元素、判断是否存在package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tm1 := map[string]string{\t\t\"name1\": \"lcc\",\t\t\"name2\": \"Cc\",\t\t\"name3\": \"Cc360428\"}\tlogs.Info(m1)\tm2 := make(map[int]int)\tm2[1] = 11\tm2[2] = 22\tm2[3] = 33\tm2[4] = 44\tm2[5] = 55\tlogs.Info(m2)\tdelete(m2, 4)\tlogs.Info(m2)\tif v, ok := m2[88]; !ok {\t\t// ok 存在返回true 反之 false\t\tlogs.Info(\"check key no\")\t} else {\t\t// 当不存在就返回默认值\t\tlogs.Info(\"check  key is：\", v)\t}}2020/04/25 10:30:05.829 [I] [map.go:12]  map[name1:lcc name2:Cc name3:Cc360428]2020/04/25 10:30:05.858 [I] [map.go:19]  map[1:11 2:22 3:33 4:44 5:55]2020/04/25 10:30:05.858 [I] [map.go:21]  map[1:11 2:22 3:33 5:55]2020/04/25 10:30:05.858 [I] [map.go:24]  check key noContainer（heap、list、ring）  单链表结构      双链表结构与删除          知道上一个下一个，删除时要告诉上一个下个删除        双向链表与环形链表heap（堆）  源码文档  heap 包提供了对任意类型（实现了 heap.Interface接口）的堆操作。（最小）堆是具有“每个节点都是以其为根的子树中最小值”属性的树。  树的最小元素为其根元素，索引 0的位置。  heap是常用的实现优先队列的方法。要创建一个优先队列，实现一个具有使用（负的）优先级作为比较的依据的 Less 方法的 Heap 接口，如此一来可用 Push 添加项目而用 Pop 取出队列最高优先级的项目。  实现优先队列package mainimport (\t\"container/heap\"\t\"fmt\")type Item struct {\tvalue    string // 优先级队列中的数据，可以是任意类型，这里使用string\tpriority int    // 优先级队列中节点的优先级\tindex    int    // index是该节点在堆中的位置}// 优先级队列需要实现heap的interfacetype PriorityQueue []*Item// 绑定Len方法func (pq PriorityQueue) Len() int {\treturn len(pq)}// 绑定Less方法，这里用的是小于号，生成的是小根堆func (pq PriorityQueue) Less(i, j int) bool {\treturn pq[i].priority &lt; pq[j].priority}// 绑定swap方法func (pq PriorityQueue) Swap(i, j int) {\tpq[i], pq[j] = pq[j], pq[i]\tpq[i].index, pq[j].index = i, j}// 绑定put方法，将index置为-1是为了标识该数据已经出了优先级队列了func (pq *PriorityQueue) Pop() interface{} {\told := *pq\tn := len(old)\titem := old[n-1]\t*pq = old[0 : n-1]\titem.index = -1\treturn item}// 绑定push方法func (pq *PriorityQueue) Push(x interface{}) {\tn := len(*pq)\titem := x.(*Item)\titem.index = n\t*pq = append(*pq, item)}// 更新修改了优先级和值的item在优先级队列中的位置func (pq *PriorityQueue) update(item *Item, value string, priority int) {\titem.value = value\titem.priority = priority\theap.Fix(pq, item.index)}func main() {\t// 创建节点并设计他们的优先级\titems := map[string]int{\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9}\ti := 0\tpq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化\tfor k, v := range items {             // 将节点放到优先级队列中\t\tpq[i] = &amp;Item{\t\t\tvalue:    k,\t\t\tpriority: v,\t\t\tindex:    i}\t\ti++\t}\theap.Init(&amp;pq) // 初始化堆\titem := &amp;Item{ // 创建一个item\t\tvalue:    \"李四\",\t\tpriority: 1,\t}\theap.Push(&amp;pq, item)           // 入优先级队列\tpq.update(item, item.value, 6) // 更新item的优先级\tfor len(pq) &gt; 0 {\t\titem := heap.Pop(&amp;pq).(*Item)\t\tfmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index)\t}}03:张三 index:-0105:二毛 index:-0106:李四 index:-0109:狗蛋 index:-01list（双向链表）  源码文档  双向链表 ，Element 元素是链接列表的元素  MoveBefore：给定的元素移动到另一个元素的前面  MoveAfter：给定的元素移动到另一个元素的后面  MoveToFront：把给定的元素移动到链表的最前端  MoveToBack：把给定的元素移动到链表的最后端  Front：获取链表中最前端  Back：获取链表中最后端  InsertBefore：指定的元素之前插入新元素  InsertAfter：指定的元素之后插入新元素  PushFront：用于在链表的最前端插入新元素。  PushBack：用于在链表的最前端插入新元素。package mainimport (\t\"container/list\"\t\"fmt\"\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tlistType := list.New()\t// 尾部添加\tlistType.PushFront(\"lcc\")\tlistType.PushFront(18)\t// 头部添加\tlistType.PushFront(\"hello\")\tfor e := listType.Front(); e != nil; e = e.Next() {\t\tfmt.Print(e.Value, \" \")\t}\tfmt.Print(\"\\n\")\tfor e := listType.Front(); e != nil; e = e.Next() {\t\tif e.Value == \"hello\" {\t\t\t// 指定元素之后插入新元素\t\t\tlistType.InsertAfter(\"World\", e)\t\t}\t\tif e.Value == \"lcc\" {\t\t\t// 指定元素之前插入新元素\t\t\tlistType.InsertBefore(\"Cc\", e)\t\t}\t}\tfor e := listType.Front(); e != nil; e = e.Next() {\t\tfmt.Print(e.Value, \" \")\t}\tfmt.Print(\"\\n\")\tfor e := listType.Back(); e != nil; e = e.Next() {\t\tfmt.Print(e.Value)\t}\t// 最前元素\tlogs.Info(listType.Front().Value)\t// 最后元素\tlogs.Info(listType.Back().Value)\tfor e := listType.Front(); e != nil; e = e.Next() {\t\tif e.Value == \"lcc\" {\t\t\t// 指定元素之前插入新元素\t\t\tlistType.MoveBefore(e, e)\t\t}\t}}hello 18 lcchello World 18 Cc lcclcc2020/04/25 16:16:21.548 [I] [list.go:39]  hello2020/04/25 16:16:21.577 [I] [list.go:41]  lccring（环）  源码文档  ring 实现了环形链表的操作package mainimport (\t\"container/ring\"\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tring1 := ring.New(3)\tfor i := 1; i &lt;= 3; i++ {\t\tring1.Value = i\t\tring1 = ring1.Next()\t}\tring2 := ring.New(3)\tfor i := 0; i &lt;= ring2.Len(); i++ {\t\tring2.Value = i\t\tring2 = ring2.Next()\t}\tr := ring1.Link(ring2)\tlogs.Info(r.Len())\tr.Do(func(p interface{}) {\t\tlogs.Info(p.(int))\t})\tlogs.Info(r.Value)\tlogs.Info(r.Next().Value)\tlogs.Info(r.Prev().Value)\t// ring 的遍历\tfor p := r.Next(); p != r; p = p.Next() {\t\tlogs.Info(p.Value.(int))\t}}2020/04/25 16:15:42.181 [I] [ring.go:20]  62020/04/25 16:15:42.216 [I] [ring.go:23]  22020/04/25 16:15:42.216 [I] [ring.go:23]  32020/04/25 16:15:42.216 [I] [ring.go:23]  12020/04/25 16:15:42.216 [I] [ring.go:23]  12020/04/25 16:15:42.216 [I] [ring.go:23]  22020/04/25 16:15:42.216 [I] [ring.go:23]  32020/04/25 16:15:42.216 [I] [ring.go:25]  22020/04/25 16:15:42.216 [I] [ring.go:26]  32020/04/25 16:15:42.216 [I] [ring.go:27]  32020/04/25 16:15:42.216 [I] [ring.go:30]  32020/04/25 16:15:42.216 [I] [ring.go:30]  12020/04/25 16:15:42.217 [I] [ring.go:30]  12020/04/25 16:15:42.218 [I] [ring.go:30]  22020/04/25 16:15:42.218 [I] [ring.go:30]  3"
  },
  
  {
    "title": "Day08（切片 slice 和 range）",
    "url": "/posts/8-sliceAndRanger/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:08 +0800",
    





    
    "snippet": "切片（slice） 和 range 使用源码切片（slice）  Go 数组在一定情况下，不能满足开发业务需求（数组固定长度、有很多局限性），切片是可变长度序列，切片底层就是数组做了一层封装（也叫做动态数组）。切片可以自动扩容，切片是引用类型，包含地址、长度（len）、容量（cap）切片什么时候扩容  如果切片的容量小于 1024 个元素，那么扩容的时候 slice的 cap就翻番，乘以 2...",
    "content": "切片（slice） 和 range 使用源码切片（slice）  Go 数组在一定情况下，不能满足开发业务需求（数组固定长度、有很多局限性），切片是可变长度序列，切片底层就是数组做了一层封装（也叫做动态数组）。切片可以自动扩容，切片是引用类型，包含地址、长度（len）、容量（cap）切片什么时候扩容  如果切片的容量小于 1024 个元素，那么扩容的时候 slice的 cap就翻番，乘以 2；一旦元素个数超过 1024 个元素，增长因子就变成 1.25，即每次增加原来容量的四分之一。  如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go 就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组  首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。  否则判断，如果旧切片的长度小于 1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），  否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）  如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。基本使用  定义方式  指定长度与容量：make([]Type, length, capacity)  指定长度：make([]Type, length)package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"func main() {\tvar slice1 []string\tlogs.Info(slice1)\tslice2 := make([]int, 1, 2)\tlogs.Info(len(slice2), cap(slice2))}2020/04/24 23:47:25.578 [I] [slice.go:7]  []2020/04/24 23:47:25.621 [I] [slice.go:9]  1 2  初始化以及切割a[2:]  // 等同于 a[2:len(a)]a[:3]  // 等同于 a[0:3]a[:]   // 等同于 a[0:len(a)]package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"func main() {\ts := []int{1, 2, 3}\tlogs.Info(s)\ts1 := s[:1]\tlogs.Info(s1)\ts2 := s[1:]\tlogs.Info(s2)\ts3 := s[1:2]\tlogs.Info(s3)}2020/04/24 23:55:30.339 [I] [slice2.go:7]  [1 2 3]2020/04/24 23:55:30.366 [I] [slice2.go:9]  [1]2020/04/24 23:55:30.366 [I] [slice2.go:11]  [2 3]2020/04/24 23:55:30.366 [I] [slice2.go:13]  [2]  len()和 cap()package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"func main() {\t// 定义长度为：1 ，容量为2\ts1 := make([]int, 1, 2)\tlogs.Info(len(s1), cap(s1))\ts2 := make([]int,6)\ts1 = append(s1, s2...)\tlogs.Info(len(s1), cap(s1))}2020/04/25 00:01:32.871 [I] [slice3.go:8]  1 22020/04/25 00:01:32.899 [I] [slice3.go:11]  7 8  append() 和 copy()package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"func main() {\tvar s []int\tlogs.Info(s, len(s), cap(s))\ts = append(s, 0)\tlogs.Info(s, len(s), cap(s))\ts = append(s, 612, 12, 3132, 1024)\tlogs.Info(s, len(s), cap(s))\ts2 := make([]int, len(s))\ts2[0] = 888\ts2[1] = 999\ts2[2] = 666\ts = append(s, s2 ...)\tlogs.Info(s, len(s), cap(s))\ts3 := make([]int,5)\tcopy(s3, s2)\tlogs.Info(s3, len(s3), cap(s3))}2020/04/25 00:14:53.179 [I] [slice4.go:7]  [] 0 02020/04/25 00:14:53.213 [I] [slice4.go:9]  [0] 1 12020/04/25 00:14:53.213 [I] [slice4.go:11]  [0 612 12 3132 1024] 5 62020/04/25 00:14:53.213 [I] [slice4.go:17]  [0 612 12 3132 1024 888 999 666 0 0] 10 122020/04/25 00:14:53.213 [I] [slice4.go:20]  [888 999 666 0 0] 5 5删除元素和 sort.Ints()排序  总结一下就是：要从切片 a 中删除索引为 index的元素，操作方法是 a = append(a[:index], a[index+1:]...)package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"\t\"sort\")// 删除索引为2func main() {\ta := []int{1, 2, 3,9, 5, 6, 7, 8}\ta = append(a[:2], a[3:]...)\tlogs.Info(a)\tsort.Ints(a)\tlogs.Info(a)}2020/04/25 00:21:05.501 [I] [slice5.go:12]  [1 2 9 5 6 7 8]2020/04/25 00:21:05.535 [I] [slice5.go:14]  [1 2 5 6 7 8 9]range  for遍历循环迭代 array、slice、channel、mapfor k ,v := range Type{    fmt.Println(k,v)}package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\t// array\tarray := []int{1, 2, 3, 4}\tfor k, v := range array {\t\tlogs.Info(k, v)\t}\tslice := make([]int, 3)\tfor k, v := range slice {\t\tlogs.Info(k, v)\t}\t// slice\tchannel := make(chan int, 2)\tgo func() {\t\tfor i := 1; i &lt;= 3; i++ {\t\t\tchannel &lt;- 8 * i\t\t}\t\tdefer close(channel)\t\t// !close(channel) --&gt; fatal error: all goroutines are asleep - deadlock!\t}()\t// channel\tfor k := range channel {\t\tlogs.Info(\"channel\", k)\t}\t// map\tmapType := make(map[string]interface{})\tmapType[\"name\"] = \"lcc\"\tmapType[\"age\"] = 18\tfor k, v := range mapType {\t\tlogs.Info(k, v)\t}}2020/04/25 09:47:23.485 [I] [range.go:11]  0 12020/04/25 09:47:23.510 [I] [range.go:11]  1 22020/04/25 09:47:23.510 [I] [range.go:11]  2 32020/04/25 09:47:23.510 [I] [range.go:11]  3 42020/04/25 09:47:23.510 [I] [range.go:15]  0 02020/04/25 09:47:23.510 [I] [range.go:15]  1 02020/04/25 09:47:23.510 [I] [range.go:15]  2 02020/04/25 09:47:23.510 [I] [range.go:28]  channel 82020/04/25 09:47:23.510 [I] [range.go:28]  channel 162020/04/25 09:47:23.511 [I] [range.go:28]  channel 242020/04/25 09:47:23.511 [I] [range.go:35]  name lcc2020/04/25 09:47:23.511 [I] [range.go:35]  age 18"
  },
  
  {
    "title": "Day07（指针和结构体）",
    "url": "/posts/7-PointerAndstruct/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:07 +0800",
    





    
    "snippet": "指针和结构体源码指针  Go 语言指针与 C 语言指针不一样理解,一个指针变量指向了一个值的内存地址。  类似于变量和常量，在使用指针前你需要声明指针示例      示例一：          func new(Type) *Type 说明 new()方法 返回值就是指针      package mainimport (\t\"github.com/Cc360428/HelpPackage/U...",
    "content": "指针和结构体源码指针  Go 语言指针与 C 语言指针不一样理解,一个指针变量指向了一个值的内存地址。  类似于变量和常量，在使用指针前你需要声明指针示例      示例一：          func new(Type) *Type 说明 new()方法 返回值就是指针      package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tintType := new(int)\tlogs.Info(intType)\tvar intType1 *int\tlogs.Info(intType1)\tvar intType2 int\tlogs.Info(intType2)}2020/04/23 22:21:59.542 [I] [pointer.go:9]  0xc0000123802020/04/23 22:21:59.566 [I] [pointer.go:11]  &lt;nil&gt;2020/04/23 22:21:59.566 [I] [pointer.go:13]  0  示例 2package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tvar a int = 20 // 声明实际变量\tvar ip *int    // 声明指针变量\tip = &amp;a        // 将变量 a 的指针复制给 ip\tlogs.Info(&amp;a)\tlogs.Info(ip)  // 指针变量的存储地址\tlogs.Info(*ip) // 使用指针访问值}2020/04/23 22:30:34.230 [I] [pointer2.go:11]  0xc0000882d02020/04/23 22:30:34.273 [I] [pointer2.go:12]  0xc0000882d02020/04/23 22:30:34.273 [I] [pointer2.go:13]  2结构体基础语法package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"// User 用户结构体type User struct {\tName   string `json:\"name\"`\tAge    int    `json:\"age\"`\tEmail  string `json:\"email\"`\tStatuc bool   `json:\"statuc\"`}func main() {\tvar user User\tlogs.Info(user)\tlogs.Info(User{\"lcc\", 18, \"lcc@lcc.com\", false})\tvar user2 User\tuser2.Age = 23\tuser2.Name = \"Cc\"\tuser2.Email = \"Cc@cc.com\"\tuser2.Statuc = true\tlogs.Info(user2)\tlogs.Info(user2.Age)\tlogs.Info(user2.Name)}2020/04/23 22:45:58.034 [I] [struct.go:15]  { 0  false}2020/04/23 22:45:58.061 [I] [struct.go:16]  {lcc 18 lcc@lcc.com false}2020/04/23 22:45:58.061 [I] [struct.go:22]  {Cc 23 Cc@cc.com true}2020/04/23 22:45:58.061 [I] [struct.go:23]  232020/04/23 22:45:58.061 [I] [struct.go:24]  Cc进阶package mainimport \"github.com/Cc360428/HelpPackage/UtilsHelp/logs\"// User 用户结构体type User struct {\tName   string `json:\"name\"`\tAge    int    `json:\"age\"`\tEmail  string `json:\"email\"`\tStatuc bool   `json:\"statuc\"`}// InitUser 获取Userfunc (u *User) InitUser(name string) (*User, error) {\tu.Name = name\treturn u, nil}func main() {\tuser := new(User)\tuser.Age = 6\tuser2, _ := user.InitUser(\"lcc\")\tlogs.Info(user2)}2020/04/23 22:51:45.282 [I] [struct2.go:22]  &amp;{lcc 6  false}"
  },
  
  {
    "title": "Day06（作用域与数组）",
    "url": "/posts/6-variableAndArray/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:06 +0800",
    





    
    "snippet": "作用域与数组源码变量作用域局部变量  函数内定义的变量package mainimport (\t\"fmt\")func main() {\tvar a, b, c = 1, 2, 3\tfmt.Println(a, b, c)}全局变量  函数外定义的变量package mainimport \"fmt\"// 定义全局变量var h intfunc main() {\tvar a, b int\ta =...",
    "content": "作用域与数组源码变量作用域局部变量  函数内定义的变量package mainimport (\t\"fmt\")func main() {\tvar a, b, c = 1, 2, 3\tfmt.Println(a, b, c)}全局变量  函数外定义的变量package mainimport \"fmt\"// 定义全局变量var h intfunc main() {\tvar a, b int\ta = 1\tb = 2\th = a + b\tfmt.Println(h)}形式参数  函数定义中的变量package mainimport \"fmt\"// 声明全局变量var a = 20func main() {\t// main 函数中声明局部变量\tvar a = 10\tvar b = 20\tvar c = 0\tfmt.Printf(\"main()函数中 a = %d\\n\", a)\tc = sum(a, b)\tfmt.Printf(\"main()函数中 c = %d\\n\", c)}// 函数定义-两数相加func sum(a, b int) int {\tfmt.Printf(\"sum() 函数中 a = %d\\n\", a)\tfmt.Printf(\"sum() 函数中 b = %d\\n\", b)\treturn a + b}main()函数中 a = 10sum() 函数中 a = 10sum() 函数中 b = 20main()函数中 c = 30数组  数组是 Go 语言中一个数据结构  数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推数组声明、初始化、访问元素package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\tvar array = [2]int{1, 2}\tlogs.Info(array)\tvar array1 = [...]int{1, 2, 2, 3, 4, 4, 3, 23, 6, 6, 2}\tlogs.Info(array1)\tvar n [10]int // n 是一个长度为 10 的数组\tvar i, j int\t// 为数组 n 初始化元素\tfor i = 0; i &lt; 10; i++ {\t\tn[i] = i + 100 /* 设置元素为 i + 100 */\t}\t// 输出每个数组元素的值\tfor j = 0; j &lt; 10; j++ {\t\tlogs.Info(\"Element[%d] = %d \", j, n[j])\t}}2020/04/07 23:26:07.885 [I] [array.go:10]  [1 2]2020/04/07 23:26:07.886 [I] [array.go:12]  [1 2 2 3 4 4 3 23 6 6 2]2020/04/07 23:26:07.886 [I] [array.go:23]  Element[0] = 1002020/04/07 23:26:07.886 [I] [array.go:23]  Element[1] = 1012020/04/07 23:26:07.886 [I] [array.go:23]  Element[2] = 1022020/04/07 23:26:07.886 [I] [array.go:23]  Element[3] = 1032020/04/07 23:26:07.886 [I] [array.go:23]  Element[4] = 1042020/04/07 23:26:07.886 [I] [array.go:23]  Element[5] = 1052020/04/07 23:26:07.886 [I] [array.go:23]  Element[6] = 1062020/04/07 23:26:07.886 [I] [array.go:23]  Element[7] = 1072020/04/07 23:26:07.886 [I] [array.go:23]  Element[8] = 1082020/04/07 23:26:07.886 [I] [array.go:23]  Element[9] = 109多维数组、向数组传递数组多维数组package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\t// 数组 - 5 行 2 列\tvar a = [5][2]int{ {0, 0}, {1, 2}, {2, 4}, {3, 6}, {4, 8}}\tvar i, j int\t// 输出数组元素\tfor i = 0; i &lt; 5; i++ {\t\tfor j = 0; j &lt; 2; j++ {\t\t\tlogs.Info(\"a[%d][%d] = %d\", i, j, a[i][j])\t\t}\t}}2020/04/07 23:28:47.448 [I] [array2.go:15]  a[0][0] = 02020/04/07 23:28:47.449 [I] [array2.go:15]  a[0][1] = 02020/04/07 23:28:47.449 [I] [array2.go:15]  a[1][0] = 12020/04/07 23:28:47.449 [I] [array2.go:15]  a[1][1] = 22020/04/07 23:28:47.449 [I] [array2.go:15]  a[2][0] = 22020/04/07 23:28:47.449 [I] [array2.go:15]  a[2][1] = 42020/04/07 23:28:47.449 [I] [array2.go:15]  a[3][0] = 32020/04/07 23:28:47.449 [I] [array2.go:15]  a[3][1] = 62020/04/07 23:28:47.449 [I] [array2.go:15]  a[4][0] = 42020/04/07 23:28:47.449 [I] [array2.go:15]  a[4][1] = 8向数组传递数组package mainimport (\t\"github.com/Cc360428/HelpPackage/UtilsHelp/logs\")func main() {\t//  数组长度为 5\tvar balance = [5]int{1000, 2, 3, 17, 50}\tvar avg float32\t// 数组作为参数传递给函数\tavg = getAverage(balance, 5)\t// 输出返回的平均值\tlogs.Info(\"平均值为: %f \", avg)}func getAverage(arr [5]int, size int) float32 {\tvar i, sum int\tvar avg float32\tfor i = 0; i &lt; size; i++ {\t\tsum += arr[i]\t}\tavg = float32(sum) / float32(size)\treturn avg}2020/04/07 23:31:06.475 [I] [array3.go:16]  平均值为: 214.399994"
  },
  
  {
    "title": "Day05（函数）",
    "url": "/posts/5-func/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:05 +0800",
    





    
    "snippet": "函数函数定义和调用在 Go 语言中，函数的定义方式如下：func functionName(parameter1 type1, parameter2 type2) returnType {    // 函数体    return value}例如，一个简单的加法函数可以这样定义和调用：package mainimport \"fmt\"func add(x int, y int) int {  ...",
    "content": "函数函数定义和调用在 Go 语言中，函数的定义方式如下：func functionName(parameter1 type1, parameter2 type2) returnType {    // 函数体    return value}例如，一个简单的加法函数可以这样定义和调用：package mainimport \"fmt\"func add(x int, y int) int {    return x + y}func main() {    result := add(3, 4)    fmt.Println(result)  // 输出: 7}多个返回值Go 语言支持函数返回多个值，这在处理错误时特别有用：func divide(dividend int, divisor int) (int, error) {    if divisor == 0 {        return 0, fmt.Errorf(\"division by zero\")    }    return dividend / divisor, nil}func main() {    result, err := divide(10, 2)    if err != nil {        fmt.Println(\"Error:\", err)    } else {        fmt.Println(\"Result:\", result)    }}命名返回值函数的返回值可以被命名，这使得函数体中的代码更为清晰：func addAndMultiply(x, y int) (sum int, product int) {    sum = x + y    product = x * y    return}func main() {    sum, product := addAndMultiply(3, 4)    fmt.Println(\"Sum:\", sum)          // 输出: Sum: 7    fmt.Println(\"Product:\", product)  // 输出: Product: 12}匿名函数和闭包Go 语言支持匿名函数和闭包，可以在函数内部定义一个匿名函数并调用：func main() {    // 匿名函数    result := func(x, y int) int {        return x + y    }(3, 4)    fmt.Println(result)  // 输出: 7    // 闭包    add := func(x int) int {        return x + 10    }    fmt.Println(add(5))  // 输出: 15}方法在 Go 语言中，函数可以附属于一个类型，这样的函数称为方法：type Rectangle struct {    width, height int}// 方法func (r Rectangle) Area() int {    return r.width * r.height}func main() {    rect := Rectangle{width: 10, height: 5}    fmt.Println(\"Area:\", rect.Area())  // 输出: Area: 50}递归函数函数可以调用自身，这就是递归：func factorial(n int) int {    if n == 0 {        return 1    }    return n * factorial(n-1)}func main() {    fmt.Println(factorial(5))  // 输出: 120}defer 语句defer语句用于延迟执行某个函数直到当前函数返回，这在资源清理等场景中很有用：func main() {    fmt.Println(\"Start\")    defer fmt.Println(\"Deferred\")    fmt.Println(\"End\")    // 输出顺序: Start, End, Deferred}函数传参方式值传递值传递是指在函数调用时，将实际参数的副本传递给函数。这样，函数内对参数的修改不会影响到函数外的变量。示例package mainimport \"fmt\"func modifyValue(val int) {    val = 10}func main() {    a := 5    modifyValue(a)    fmt.Println(a)  // 输出: 5}modifyValue函数修改了参数val的值，但这并不影响函数外的变量a。引用传递（通过指针实现）  引用传递的效果是通过传递指针来实现的。传递指针允许函数修改外部变量的值。  示例package mainimport \"fmt\"func modifyPointer(val *int) {    *val = 10}func main() {    a := 5    modifyPointer(&amp;a)    fmt.Println(a)  // 输出: 10}modifyPointer函数接收一个指向int类型的指针，并修改该指针指向的值。由于传递的是指针，函数内的修改会影响到外部变量a。      示例对比(为了更清楚地理解值传递和通过指针实现的引用传递)        值传递示例  package mainimport \"fmt\"type Point struct {    x, y int}func modifyPointVal(p Point) {    p.x = 10    p.y = 10}func main() {    p := Point{1, 2}    modifyPointVal(p)    fmt.Println(p)  // 输出: {1, 2}}modifyPointVal函数接收的是Point结构体的副本，因此对p的修改不会影响函数外的变量p。  引用传递（通过指针实现）示例package mainimport \"fmt\"type Point struct {    x, y int}func modifyPointPtr(p *Point) {    p.x = 10    p.y = 10}func main() {    p := Point{1, 2}    modifyPointPtr(&amp;p)    fmt.Println(p)  // 输出: {10, 10}}modifyPointPtr函数接收的是指向Point结构体的指针，因此对p的修改会影响函数外的变量p。总结  值传递：将参数的副本传递给函数。函数内部对参数的修改不会影响到外部变量。  引用传递（通过指针实现）：传递参数的指针，使得函数能够修改外部变量的值。特殊用法可变参数package mainimport \"fmt\"// 定义一个可变参数函数func sum(nums ...int) int {    total := 0    for _, num := range nums {        total += num    }    return total}func main() {    fmt.Println(sum(1, 2, 3))       // 输出: 6    fmt.Println(sum(1, 2, 3, 4, 5)) // 输出: 15}方法（附属于类型的函数）  方法是附属于某个类型的函数，方法可以有接收者，可以是值类型或指针类型package mainimport \"fmt\"type Rectangle struct {    width, height int}// 值接收者方法func (r Rectangle) Area() int {    return r.width * r.height}// 指针接收者方法func (r *Rectangle) Scale(factor int) {    r.width *= factor    r.height *= factor}func main() {    rect := Rectangle{width: 10, height: 5}    fmt.Println(\"Area:\", rect.Area())  // 输出: Area: 50    rect.Scale(2)    fmt.Println(\"Scaled Area:\", rect.Area())  // 输出: Scaled Area: 200}高阶函数  高阶函数是指接受函数作为参数或返回函数的函数package mainimport \"fmt\"// 高阶函数，返回一个函数func makeAdder(x int) func(int) int {    return func(y int) int {        return x + y    }}func main() {    add5 := makeAdder(5)    fmt.Println(add5(3))  // 输出: 8    fmt.Println(add5(10)) // 输出: 15}"
  },
  
  {
    "title": "Day04（循环语句）",
    "url": "/posts/4-LoopStatementFunc/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:04 +0800",
    





    
    "snippet": "  有几种常见的循环方式，主要包括 for 循环、range 循环以及带有 break 和 continue 关键字的循环。这些循环可以用来遍历数组、切片、映射（map）、字符串、通道（channel）等。下面详细介绍每种循环的用法和示例for基本的 for 循环package mainimport \"fmt\"func main() {  for i := 0; i &lt; 5; i++ ...",
    "content": "  有几种常见的循环方式，主要包括 for 循环、range 循环以及带有 break 和 continue 关键字的循环。这些循环可以用来遍历数组、切片、映射（map）、字符串、通道（channel）等。下面详细介绍每种循环的用法和示例for基本的 for 循环package mainimport \"fmt\"func main() {  for i := 0; i &lt; 5; i++ {    fmt.Println(i)  }}  这个示例中的 for 循环从 0 循环到 4，总共执行 5 次。省略初始和后置语句的 for 循环package mainimport \"fmt\"func main() {  i := 0  for i &lt; 5 {    fmt.Println(i)    i++  }}  这个示例中的 for 循环只包含条件语句，初始语句和后置语句都省略了。无限循环package mainimport \"fmt\"func main() {  i := 0  for {    fmt.Println(i)    i++    if i &gt;= 5 {      break    }  }}  这个示例展示了一个无限循环，通过 break 语句跳出循环。range 循环range 循环用于遍历数组、切片、映射、字符串和通道。遍历数组或切片package mainimport \"fmt\"func main() {  numbers := []int{1, 2, 3, 4, 5}  for index, value := range numbers {    fmt.Printf(\"Index: %d, Value: %d\\n\", index, value)  }}  这个示例使用 range 循环遍历一个切片，打印出每个元素的索引和值。遍历映射package mainimport \"fmt\"func main() {  personAge := map[string]int{\"Alice\": 30, \"Bob\": 25}  for name, age := range personAge {    fmt.Printf(\"Name: %s, Age: %d\\n\", name, age)  }}  这个示例使用 range 循环遍历一个映射，打印出每个键值对。遍历字符串package mainimport \"fmt\"func main() {  str := \"Hello, 世界\"  for index, runeValue := range str {    fmt.Printf(\"Index: %d, Rune: %c\\n\", index, runeValue)  }}  这个示例使用 range 循环遍历一个字符串，打印出每个字符的索引和值（以 Unicode 码点表示）。遍历通道package mainimport \"fmt\"func main() {  ch := make(chan int, 5)  ch &lt;- 1  ch &lt;- 2  ch &lt;- 3  close(ch)  for value := range ch {    fmt.Println(value)  }}  这个示例使用 range 循环遍历一个通道，直到通道被关闭。使用 break 和 continuebreak 语句break 语句用于立即退出循环。package mainimport \"fmt\"func main() {  for i := 0; i &lt; 10; i++ {    if i == 5 {      break    }    fmt.Println(i)  }}  这个示例中的循环会在 i 等于 5 时退出。continue 语句continue 语句用于跳过当前循环的剩余部分，立即开始下一次循环迭代。package mainimport \"fmt\"func main() {  for i := 0; i &lt; 10; i++ {    if i%2 == 0 {      continue    }    fmt.Println(i)  }}  这个示例中的循环会跳过所有偶数，只打印奇数。特殊用法  在 Go 语言的 for 循环中，可以使用一些特殊的语法和关键字来控制循环的执行流程，包括 goto、标签、break、continue 等。这些工具可以帮助我们更灵活地控制循环。下面介绍这些特殊用法并提供相应的示例。使用 goto 跳转goto 语句可以跳转到代码中的标签位置。标签是由标签名和冒号组成的一行代码。示例：使用 goto 跳转package mainimport \"fmt\"func main() {  i := 0Loop:  for i &lt; 10 {    if i == 5 {      i++      goto Loop    }    fmt.Println(i)    i++  }}  在这个例子中，当 i 等于 5 时，goto Loop 语句将控制权转移到标签 Loop 所在的位置，从而跳过了 i 等于 5 的情况。输出结果为：0 1 2 3 4 6 7 8 9。使用标签与 break 和 continue在 Go 中，break 和 continue 可以与标签一起使用，以便在多层嵌套循环中控制特定的循环。示例：带标签的 breakpackage mainimport \"fmt\"func main() {OuterLoop:  for i := 0; i &lt; 3; i++ {    for j := 0; j &lt; 3; j++ {      if i == 1 &amp;&amp; j == 1 {        break OuterLoop      }      fmt.Printf(\"i=%d, j=%d\\n\", i, j)    }  }}  在这个例子中，break OuterLoop 将跳出外层循环。输出结果为：i=0, j=0i=0, j=1i=0, j=2i=1, j=0示例：带标签的 continuepackage mainimport \"fmt\"func main() {OuterLoop:  for i := 0; i &lt; 3; i++ {    for j := 0; j &lt; 3; j++ {      if i == 1 &amp;&amp; j == 1 {        continue OuterLoop      }      fmt.Printf(\"i=%d, j=%d\\n\", i, j)    }  }}  在这个例子中，continue OuterLoop 将跳到外层循环的下一次迭代。输出结果为：i=0, j=0i=0, j=1i=0, j=2i=1, j=0i=2, j=0i=2, j=1i=2, j=2在 for 循环中使用 deferdefer 语句在函数结束时才会执行，但是在循环中，每次迭代都会注册一个新的 defer 调用，当函数结束时，所有的 defer 调用会按照逆序执行。示例：在循环中使用 deferpackage mainimport \"fmt\"func main() {  for i := 0; i &lt; 3; i++ {    defer fmt.Println(i)  }}  在这个例子中，循环中每次迭代都会注册一个 defer 调用。当 main 函数结束时，defer 调用按照逆序执行。输出结果为：210使用 return 退出函数在 for 循环中，可以使用 return 语句来直接退出整个函数。示例：使用 return 退出函数package mainimport \"fmt\"func main() {  for i := 0; i &lt; 10; i++ {    if i == 5 {      return    }    fmt.Println(i)  }}  在这个例子中，当 i 等于 5 时，return 语句将退出整个 main 函数。输出结果为：01234"
  },
  
  {
    "title": "Day03（运算符与条件语句）",
    "url": "/posts/3-OperatorCondition/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:03 +0800",
    





    
    "snippet": "运算符  在 Go 语言（又称 Golang）中，并没有直接列出所有可能的运算法种类，因为运算法（或称为运算符）是编程语言的内置特性，用于执行不同类型的计算或逻辑操作。但是，我们可以分类列出 Go 语言中常用的运算法种类：      算术运算符：          加法 (+)      减法 (-)      乘法 (*)      除法 (/)      整除（取整）(% 或 %%，在某...",
    "content": "运算符  在 Go 语言（又称 Golang）中，并没有直接列出所有可能的运算法种类，因为运算法（或称为运算符）是编程语言的内置特性，用于执行不同类型的计算或逻辑操作。但是，我们可以分类列出 Go 语言中常用的运算法种类：      算术运算符：          加法 (+)      减法 (-)      乘法 (*)      除法 (/)      整除（取整）(% 或 %%，在某些情况下）      自增 (++)      自减 (--)            关系运算符（或比较运算符）：          等于 (==)      不等于 (!=)      大于 (&gt;)      小于 (&lt;)      大于等于 (&gt;=)      小于等于 (&lt;=)            逻辑运算符：          逻辑与 (&amp;&amp;)      逻辑或 (||)      逻辑非 (!)            位运算符：          位与 (&amp;)      位或 (|)      位异或 (^)      位与非 (&amp;^)      左移 (&lt;&lt;)      右移 (&gt;&gt;)      无符号右移 (&gt;&gt;&gt;，但 Go 中没有无符号右移运算符）            赋值运算符：          赋值 (=)      复合赋值（例如 +=、-=、*=、/= 等）            其他运算符：          地址运算符 (&amp; 用于获取变量的地址，但在赋值上下文中作为位与运算符)      指针解引用 (* 用于解引用指针)      长度和容量运算符 (len() 和 cap()，它们不是真正的运算符，但常用于数组、切片、映射和通道)      索引和切片 ([]，用于数组、切片和字符串的索引或切片操作)      通道运算符 (&lt;-，用于发送和接收通道的数据)            类型断言和类型转换：          类型断言 (v, ok := i.(T)，用于接口到具体类型的断言)      类型转换 (T(v)，用于将一个类型的值转换为另一个类型)      算术运算符  算术运算符在 Go 语言中用于执行数学计算。以下是 Go 语言中算术运算符的列表，每个运算符都附有描述和示例：            运算符      描述      示例                  +      加法，将两个数相加      a := 5 + 3  // a = 8              -      减法，从第一个数中减去第二个数      b := 5 - 3  // b = 2              *      乘法，将两个数相乘      c := 5 * 3  // c = 15              /      除法，将第一个数除以第二个数      d := 10 / 3 // d = 3（整数除法，结果为整数部分）              %      取模（求余），返回两个数相除的余数      e := 10 % 3 // e = 1              ++      自增，将变量的值增加 1（前缀或后缀）      f := 5; f++; // f = 6  g := 5; ++g; // g = 6              --      自减，将变量的值减少 1（前缀或后缀）      h := 5; h--; // h = 4  i := 5; --i; // i = 4        请注意，在 Go 语言中，整数除法会向下取整（即”截断”小数部分），因此 10 / 3 的结果是 3 而不是 3.333...。如果你需要浮点数的除法结果，你应该至少有一个操作数是浮点数，如 10.0 / 3 或 float64(10) / 3。此外，++ 和 -- 运算符既可以作为前缀运算符（如 ++i），也可以作为后缀运算符（如 i++）。前缀运算符会先增加或减少变量的值，然后再返回新值；后缀运算符会先返回原始值，然后再增加或减少变量的值。这在循环和迭代中特别有用，但使用时需要小心以避免意外的副作用。  完整例子package mainimport \"fmt\"func main() {    // 定义两个整数变量    var num1, num2 int    // 初始化这两个变量    num1 = 10    num2 = 3    // 计算两个数的和    sum := num1 + num2    fmt.Println(\"Sum:\", sum) // 输出: Sum: 13    // 计算两个数的差    difference := num1 - num2    fmt.Println(\"Difference:\", difference) // 输出: Difference: 7    // 计算两个数的积    product := num1 * num2    fmt.Println(\"Product:\", product) // 输出: Product: 30    // 计算两个数相除的商（整数除法）    quotient := num1 / num2    fmt.Println(\"Quotient:\", quotient) // 输出: Quotient: 3    // 计算两个数相除的余数    remainder := num1 % num2    fmt.Println(\"Remainder:\", remainder) // 输出: Remainder: 1    // 使用自增运算符增加 num1 的值    num1++    fmt.Println(\"num1 after increment:\", num1) // 输出: num1 after increment: 11    // 使用自减运算符减少 num2 的值    num2--    fmt.Println(\"num2 after decrement:\", num2) // 输出: num2 after decrement: 2    // 合并使用算术运算符来计算一个表达式的值    // 这里我们计算 (num1 + num2) * num2 - num1 的值    combinedResult := (num1 + num2) * num2 - num1    fmt.Println(\"Combined Result:\", combinedResult) // 输出: Combined Result: 20}关系运算符（或比较运算符）  关系运算符（或比较运算符）用于比较两个操作数的大小或是否相等。以下是关系运算符的表格形式，以及每个运算符的示例：            运算符      描述      示例                  ==      等于      a := 5; b := 5; fmt.Println(a == b) // 输出: true              !=      不等于      a := 5; b := 3; fmt.Println(a != b) // 输出: true              &gt;      大于      a := 5; b := 3; fmt.Println(a &gt; b) // 输出: true              &lt;      小于      a := 3; b := 5; fmt.Println(a &lt; b) // 输出: true              &gt;=      大于或等于      a := 5; b := 5; fmt.Println(a &gt;= b) // 输出: true              &lt;=      小于或等于      a := 3; b := 5; fmt.Println(a &lt;= b) // 输出: true        示例package mainimport \"fmt\"func main() {    // 示例：使用 == 运算符    a := 5    b := 5    fmt.Println(\"a == b:\", a == b) // 输出: a == b: true    // 示例：使用 != 运算符    c := 5    d := 3    fmt.Println(\"c != d:\", c != d) // 输出: c != d: true    // 示例：使用 &gt; 运算符    e := 7    f := 5    fmt.Println(\"e &gt; f:\", e &gt; f) // 输出: e &gt; f: true    // 示例：使用 &lt; 运算符    g := 3    h := 7    fmt.Println(\"g &lt; h:\", g &lt; h) // 输出: g &lt; h: true    // 示例：使用 &gt;= 运算符    i := 5    j := 5    fmt.Println(\"i &gt;= j:\", i &gt;= j) // 输出: i &gt;= j: true    // 示例：使用 &lt;= 运算符    k := 3    l := 5    fmt.Println(\"k &lt;= l:\", k &lt;= l) // 输出: k &lt;= l: true}逻辑运算符  假定 A 值为 True，B 值为 False。            运算符      描述      实例                  &amp;&amp;      逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。      (A &amp;&amp; B) 为 False              ||      逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。      (A|| B) 为 True              !      逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。      !(A &amp;&amp; B) 为 True        例子以下是逻辑运算符的表格形式，以及每个运算符的示例：            运算符      描述      示例（假设 a 为 true，b 为 false）                                &amp;&amp;      逻辑与（AND）      如果 a &amp;&amp; b，则结果为 false（因为 b 为 false）                            `             `      逻辑或（OR）      如果 a |     | b，则结果为 true（因为 a为true）              !      逻辑非（NOT）      如果 !a，则结果为 false（因为 a 为 true，取反后为 false）                    示例代码package mainimport ( \"fmt\")func main() { a := true b := false // 逻辑与（AND） andResult := a &amp;&amp; b fmt.Println(\"a &amp;&amp; b:\", andResult) // 输出: a &amp;&amp; b: false // 逻辑或（OR） orResult := a || b fmt.Println(\"a || b:\", orResult) // 输出: a || b: true // 逻辑非（NOT） notResultA := !a notResultB := !b fmt.Println(\"!a:\", notResultA) // 输出: !a: false fmt.Println(\"!b:\", notResultB) // 输出: !b: true}在这个示例中，我们定义了两个布尔变量 a 和 b，分别赋值为 true 和 false。然后，我们使用逻辑运算符 &amp;&amp;、|| 和 ! 对这两个变量进行运算，并将结果打印出来。逻辑与 &amp;&amp; 的结果只有在两个操作数都为 true 时才为 true，逻辑或 || 的结果只要有一个操作数为 true 就为 true，逻辑非 ! 则是对一个布尔值取反。位运算符  直观例子            p      q      p &amp; q      p| q      p ^ q                  0      0      0      0      0              0      1      0      1      1              1      1      1      1      0              1      0      0      1      1            解释                            运算符          描述          示例（假设 a = 60, b = 13，均为二进制表示）                                      &amp;          位与（AND）          a = 0011 1100（60）b = 0000 1101（13）a &amp; b = 0000 1100（12）                          |          位或（OR）          a = 0011 1100（60）b = 0000 1101（13）a | b = 0011 1101（61）                          ^          位异或（XOR）          a = 0011 1100（60）b = 0000 1101（13）a ^ b = 0011 0001（49）                          &amp;^          位清零（AND NOT）          a = 0011 1100（60）b = 0000 1101（13）a &amp;^ b = 0011 0000（48）                          &lt;&lt;          左移          a = 0011 1100（60）a « 2 = 1111 0000（240）                          &gt;&gt;          右移          a = 0011 1100（60）a » 2 = 0000 1111（15）                            &amp;（位与）：对于每一个二进制位，只有当两个相应的二进制位都为 1 时，结果位才为 1。      |（位或）：对于每一个二进制位，只要两个相应的二进制位中有一个为 1 时，结果位就为 1。      ^（位异或）：对于每一个二进制位，当两个相应的二进制位相异时，结果位为 1。      &amp;^（位清零）：对于每一个二进制位，第一个操作数中与第二个操作数相应位为 1 的位清零。      &lt;&lt;（左移）：将第一个操作数的所有位向左移动指定的位数，右边用 0 填充。      &gt;&gt;（右移）：将第一个操作数的所有位向右移动指定的位数，对于无符号整数，左边用 0 填充；对于有符号整数，符号位（最高位）会被复制以保持符号不变。            例子  package mainimport \"fmt\"func main() { var a, b int = 60, 13    // 位与    fmt.Printf(\"a &amp; b = %d\\n\", a&amp;b) // 输出: a &amp; b = 12    // 位或    fmt.Printf(\"a | b = %d\\n\", a|b) // 输出: a | b = 61    // 位异或    fmt.Printf(\"a ^ b = %d\\n\", a^b) // 输出: a ^ b = 49    // 位清零    fmt.Printf(\"a &amp;^ b = %d\\n\", a&amp;^b) // 输出: a &amp;^ b = 48    // 左移    fmt.Printf(\"a &lt;&lt; 2 = %d\\n\", a&lt;&lt;2) // 输出: a &lt;&lt; 2 = 240    // 右移    fmt.Printf(\"a &gt;&gt; 2 = %d\\n\", a&gt;&gt;2) // 输出: a &gt;&gt; 2 = 15}赋值运算符  赋值运算符表格            运算符      描述      示例（Go 风格）                  =      简单的赋值运算符，将右侧操作数的值赋给左侧操作数      a = 5              +=      加法赋值运算符（Go 中需要显式写出）      a += 3 相当于 a = a + 3              -=      减法赋值运算符（Go 中需要显式写出）      b -= 2 相当于 b = b - 2              *=      乘法赋值运算符（Go 中需要显式写出）      c *= 4 相当于 c = c * 4              /=      除法赋值运算符（Go 中需要显式写出）      d /= 2 相当于 d = d / 2              %=      取模赋值运算符（Go 中需要显式写出）      e %= 3 相当于 e = e % 3        例子package mainimport \"fmt\"func main() {    // 使用基本赋值运算符    a := 5    fmt.Println(\"a =\", a) // 输出: a = 5    // 使用复合赋值运算符的Go风格（显式写出完整操作）    a += 3  // 相当于 a = a + 3    fmt.Println(\"a += 3, a =\", a) // 输出: a += 3, a = 8    b := 10    b -= 2  // 相当于 b = b - 2    fmt.Println(\"b -= 2, b =\", b) // 输出: b -= 2, b = 8    c := 2    c *= 4  // 相当于 c = c * 4    fmt.Println(\"c *= 4, c =\", c) // 输出: c *= 4, c = 8    d := 10    d /= 2  // 相当于 d = d / 2    fmt.Println(\"d /= 2, d =\", d) // 输出: d /= 2, d = 5    e := 9    e %= 3  // 相当于 e = e % 3    fmt.Println(\"e %= 3, e =\", e) // 输出: e %= 3, e = 0}其他运算符            运算符      描述      实例                  &amp;      返回变量存储地址      &amp;a; 将给出变量的实际地址。              *      指针变量。      *a; 是一个指针变量      条件语句if&amp; if-else在 Go 语言中，条件语句主要用于基于不同条件执行不同的代码块。最常用的条件语句是if语句，以及与之相关的else和else if子句。以下是条件语句的表格形式和例子：  条件语句            语句      描述      示例                  if      如果条件为真，则执行代码块      if a &gt; b { ... }              if ... else      如果条件为真，执行第一个代码块；否则执行第二个代码块      if a &gt; b { ... } else { ... }              if ... else if ... else      根据多个条件执行不同的代码块      if a &gt; b { ... } else if a &lt; b { ... } else { ... }        例子package mainimport \"fmt\"func main() {    a := 10    b := 5    // 基本的if语句    if a &gt; b {        fmt.Println(\"a大于b\")    }    // 输出: a大于b    // if ... else语句    if a &lt; b {        fmt.Println(\"a小于b\")    } else {        fmt.Println(\"a不小于b\")    }    // 输出: a不小于b    // if ... else if ... else语句    c := 3    if a &gt; b &amp;&amp; a &gt; c {        fmt.Println(\"a最大\")    } else if b &gt; a &amp;&amp; b &gt; c {        fmt.Println(\"b最大\")    } else if c &gt; a &amp;&amp; c &gt; b {        fmt.Println(\"c最大\")    } else {        fmt.Println(\"a、b和c相等或无法判断最大者\")    }    // 输出: a最大    // 可以在if语句中使用逻辑运算符组合多个条件    d := 15    if d%2 == 0 &amp;&amp; d%3 == 0 {        fmt.Println(\"d是6的倍数\")    } else {        fmt.Println(\"d不是6的倍数\")    }    // 输出: d不是6的倍数（因为15是3的倍数但不是6的倍数）}switch  switch 语句有多种写法，可以用来简化条件判断。以下是一些常见的写法及其示例：基本 switch 语句基本的 switch 语句用于依次检测表达式的值，匹配到的值执行对应的代码块。package mainimport \"fmt\"func main() {    x := 2    switch x {    case 1:        fmt.Println(\"One\")    case 2:        fmt.Println(\"Two\")    default:        fmt.Println(\"Other\")    }}解释：根据 x 的值，匹配相应的 case 并执行其代码块。如果 x 是 2，输出 “Two”。switch 语句带条件表达式switch 可以在每个 case 中使用条件表达式。package mainimport \"fmt\"func main() {    x := 10    switch {    case x &lt; 0:        fmt.Println(\"Negative\")    case x == 0:        fmt.Println(\"Zero\")    case x &gt; 0:        fmt.Println(\"Positive\")    }}解释：switch 不带表达式，通过 case 条件来匹配，输出 “Positive”。switch 语句带初始化语句switch 语句可以包含一个初始化语句，在 switch 表达式之前执行。package mainimport \"fmt\"func main() {    switch x := 2 * 3; x {    case 1, 2, 3:        fmt.Println(\"One, Two, or Three\")    case 4, 5, 6:        fmt.Println(\"Four, Five, or Six\")    default:        fmt.Println(\"Other\")    }}解释：先执行初始化语句 x := 2 * 3，然后根据 x 的值进行匹配并执行相应的代码块，输出 “Four, Five, or Six”。switch 语句的 fallthrough 关键字fallthrough 关键字用于强制执行下一个 case 块。package mainimport \"fmt\"func main() {    x := 1    switch x {    case 1:        fmt.Println(\"One\")        fallthrough    case 2:        fmt.Println(\"Two\")        fallthrough    case 3:        fmt.Println(\"Three\")    default:        fmt.Println(\"Other\")    }}解释：x 是 1，先匹配到第一个 case 并输出 “One”，然后 fallthrough 强制执行下一个 case，输出 “Two” 和 “Three”。switch 语句的类型分支switch 语句可以用于类型分支，用于接口值的类型判断。package mainimport \"fmt\"func main() {    var i interface{} = 10    switch v := i.(type) {    case int:        fmt.Printf(\"Integer: %d\\n\", v)    case string:        fmt.Printf(\"String: %s\\n\", v)    default:        fmt.Printf(\"Other type: %T\\n\", v)    }}解释：i 是一个 interface{} 类型，switch 语句根据 i 的实际类型进行匹配，输出 “Integer: 10”。这些示例展示了 Go 语言中 switch 语句的多种用法，使得条件判断更加简洁和灵活。select  在 Go 语言中，select 语句用于处理多个 channel 的操作。select 语句会阻塞，直到其中的某个 case 可以继续执行，然后执行这个 case 的代码。以下是一些使用 select 语句的例子，展示了如何在不同情况下使用它。基本使用示例package mainimport (  \"fmt\"  \"time\")func main() {  // 创建两个 channel  ch1 := make(chan string)  ch2 := make(chan string)  // 启动两个 goroutine，向 channel 发送消息  go func() {    time.Sleep(1 * time.Second)    ch1 &lt;- \"Message from ch1\"  }()  go func() {    time.Sleep(2 * time.Second)    ch2 &lt;- \"Message from ch2\"  }()  // 使用 select 语句来等待消息  select {  case msg1 := &lt;-ch1:    fmt.Println(msg1)  case msg2 := &lt;-ch2:    fmt.Println(msg2)  }}在这个例子中，select 语句会阻塞，直到 ch1 或 ch2 中有消息到达。由于 ch1 的消息先到达，所以输出将会是 “Message from ch1”。带超时的 select 示例package mainimport (  \"fmt\"  \"time\")func main() {  ch := make(chan string)  go func() {    time.Sleep(3 * time.Second)    ch &lt;- \"Message\"  }()  select {  case msg := &lt;-ch:    fmt.Println(msg)  case &lt;-time.After(2 * time.Second):    fmt.Println(\"Timeout\")  }}  在这个例子中，select 语句包含一个超时 case。如果在 2 秒内没有收到消息，则会执行超时 case，输出 “Timeout”。循环中的 select 示例package mainimport (  \"fmt\"  \"time\")func main() {  ch1 := make(chan string)  ch2 := make(chan string)  go func() {    for {      time.Sleep(1 * time.Second)      ch1 &lt;- \"Message from ch1\"    }  }()  go func() {    for {      time.Sleep(2 * time.Second)      ch2 &lt;- \"Message from ch2\"    }  }()  for {    select {    case msg1 := &lt;-ch1:      fmt.Println(msg1)    case msg2 := &lt;-ch2:      fmt.Println(msg2)    case &lt;-time.After(3 * time.Second):      fmt.Println(\"Timeout\")      return    }  }}  这个例子展示了如何在循环中使用 select 语句。程序会持续从 ch1 和 ch2 接收消息并输出。如果 3 秒内没有消息到达，则输出 “Timeout” 并退出循环。带默认 case 的 select 示例package mainimport (  \"fmt\")func main() {  ch := make(chan string)  select {  case msg := &lt;-ch:    fmt.Println(\"Received:\", msg)  default:    fmt.Println(\"No message received\")  }}      在这个例子中，select 语句带有一个 default case。如果 ch 没有消息，则会执行 default case，输出 “No message received”。    通过这些示例，可以看出 select 语句在处理并发编程中的强大功能，能够简洁地处理多个 channel 的操作，并且可以通过超时和默认 case 来增强程序的健壮性。  "
  },
  
  {
    "title": "Day02（入门基础）",
    "url": "/posts/2-datatype/",
    "categories": "Language, Go, Base",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:02 +0800",
    





    
    "snippet": "数据类型整型  有符号整型（Signed Integer）和无符号整型（Unsigned Integer）是计算机编程中两种基本的整型数据类型，它们的主要区别在于如何解释存储在计算机中的二进制数值      有符号整型（Signed Integer）          表示范围：有符号整型可以表示正数、负数和零。因为它们需要表示正负，所以它们的取值范围是关于零对称的。例如，一个 8 位的有符...",
    "content": "数据类型整型  有符号整型（Signed Integer）和无符号整型（Unsigned Integer）是计算机编程中两种基本的整型数据类型，它们的主要区别在于如何解释存储在计算机中的二进制数值      有符号整型（Signed Integer）          表示范围：有符号整型可以表示正数、负数和零。因为它们需要表示正负，所以它们的取值范围是关于零对称的。例如，一个 8 位的有符号整型（int8），可以表示-128 到 127 之间的整数。      表示方法：在计算机内部，有符号整型的最高位（也称为符号位）用于表示数的正负。通常，如果符号位为 0，表示该数为正；如果符号位为 1，表示该数为负。剩下的位用于表示数值的大小。有符号整数的表示方法通常有两种：原码、反码和补码，其中补码是最常用的表示方法。      应用场景：当需要处理的数据可能为正数、负数或零时，应使用有符号整型。            无符号整型（Unsigned Integer）          表示范围：无符号整型只能表示正数和零，不能表示负数。因此，它们的取值范围是从 0 到某个最大值。例如，一个 8 位的无符号整型（uint8），可以表示 0 到 255 之间的整数。      表示方法：无符号整型的所有位都用于表示数值的大小，没有专门的符号位。因此，对于相同位数的整型，无符号整型能够表示的数值范围是有符号整型的两倍（仅考虑正数部分）。              应用场景：当处理的数据只可能为正数或零时，如表示像素值、颜色分量、数量、大小等，应使用无符号整型。此外，在网络通信和硬件编程中，无符号整型也经常被用来表示数据的大小、地址偏移等。                                            类型名称              位大小              最小值              最大值                                                          int8              8 位              -128              127                                      int16              16 位              -32,768              32,767                                      int32（或 rune）              32 位              -2,147,483,648              2,147,483,647                                      int64              64 位              -9,223,372,036,854,775,808              9,223,372,036,854,775,807                                      uint8（或 byte）              8 位              0              255                                      uint16              16 位              0              65,535                                      uint32              32 位              0              4,294,967,295                                      uint64              64 位              0              18,446,744,073,709,551,615                                          浮点型  浮点型分为float32和float64两种，分别表示 32 位和 64 位的浮点数值。以下是这两种浮点型的范围，以表格形式呈现：            类型名称      位大小      最小值      最大值                  float32      32 位      约等于 -3.4028235e+38      约等于 3.4028235e+38              float64      64 位      约等于 -1.7976931348623157e+308      约等于 1.7976931348623157e+308        通常推荐使用float64类型，因为它提供了更高的精度和更大的取值范围。然而，在需要节省内存空间或对性能有严格要求的场景下，可以考虑使用float32类型布尔型  布尔型使用 bool 类型表示，布尔型只有两个取值  true  false(默认)字符串类型  在 Go 语言中，字符串类型（string）是一种内置的数据类型，用于表示文本数据。字符串是由零个或多个字符组成的序列，这些字符可以是字母、数字、标点符号、特殊字符等。      字符串在 Go 语言中的表示方式是用双引号（\"\"）或反引号（``）括起来的一系列字符。例如    s1 := \"Hello, World!\"s2 := `This is a raw string literal.`            在 Go 语言中，字符串是不可变的（immutable），即一旦创建了一个字符串，就不能再修改它的内容。如果需要修改字符串，通常需要创建一个新的字符串。        字符串在 Go 语言中的功能特点包括：          数据存储与序列化：字符串类型常用于数据的存储和序列化。例如，可以将数据转换为 JSON 格式的字符串进行存储和传输，或者将字符串解析为数据结构进行反序列化。      网络通信与数据交互：在网络通信和数据交互中，字符串类型用于表示和传输各种信息。例如，HTTP 请求和响应中的数据通常以字符串的形式进行传输，API 接口也常使用字符串表示参数和返回值。      文件读写与日志记录：字符串类型用于文件读写和日志记录，例如读取文本文件的内容、写入日志信息等。在文件读写和日志记录过程中，字符串类型能够有效地处理和操作文本数据。            字符串在 Go 语言中的内部表示通常是一个字符数组（byte slice）的引用，其中每个字符可能是一个字节（对于 ASCII 字符）或多个字节（对于 UTF-8 编码的多字节字符）。在 Go 语言中，字符串类型提供了许多内置的方法来操作和处理字符串，例如连接、拆分、查找、替换等。        此外，Go 语言还提供了两种特殊的字符类型来处理字符串中的字符：          byte 类型（等价于 uint8）：用于表示 ASCII 字符集中的字符，每个字符占用一个字节。      rune 类型（等价于 int32）：用于表示 Unicode 字符集中的字符，可以表示包括中文、日文等任何 Unicode 字符。在处理包含多字节字符的字符串时，通常使用 rune 类型来遍历和访问字符串中的每个字符。      其他在 Go 语言中，除了整型（integer types）、浮点型（floating-point types）、布尔型（bool）和字符串类型（string）之外，还有其他几种基本数据类型。以下是 Go 语言中的一些主要数据类型：复合类型  数组（Array）：一种具有固定长度的序列，其中每个元素都是相同的数据类型。  切片（Slice）：一种动态大小的、灵活的、可变的序列，底层是数组的引用。  映射（Map）：一种无序的键值对集合，其中键是唯一的，并且可以是任何可比较的类型（如整数、字符串等）。  通道（Channel）：一种类型安全的、阻塞的、先进先出的数据结构，用于在 Go 语言的 goroutine 之间进行通信。接口类型  接口（Interface）：一种抽象的类型，它定义了一组方法的集合。任何实现了这些方法的类型都满足这个接口。函数类型  函数（Function）：在 Go 语言中，函数也是一种类型，可以被赋值给变量或作为参数传递给其他函数。指针类型  指针（Pointer）：一个变量的地址。在 Go 语言中，可以使用指针来直接访问和操作内存中的数据。其他基本类型  字节切片（Byte Slice）：通常用于处理字节数据，如读取文件或网络数据时。虽然字节切片不是一种独立的数据类型，但它在 Go 编程中非常常见。  rune：rune 是 int32 的别名，用于表示一个 Unicode 码点。它通常用于处理包含多字节字符的文本数据。  复数类型（Complex Types）：Go 语言支持两种复数类型：complex64 和 complex128，分别对应 float32 和 float64 的实部和虚部。示例以下是一些基本数据类型的示例：var i int     // 整型var f float64 // 浮点型var b bool    // 布尔型var s string  // 字符串类型var arr [5]int     // 数组类型var slc []int      // 切片类型var m map[string]int // 映射类型var ch chan int     // 通道类型func myFunc() {} // 函数类型var ptr *int       // 指针类型var c complex128   // 复数类型var runeVar rune   // rune 类型，用于表示Unicode码点变量基本介绍  在 Go 语言（通常被称为 Golang）中，变量是用于存储数据的标识符。变量有一个名称（也称为标识符），一个类型和一个值。下面是一些关于 Golang 变量的基本介绍：变量声明  在 Golang 中，变量在使用之前必须先声明。可以使用关键字var来声明变量，或者可以使用短变量声明操作符:=（这会自动推断变量的类型）。      使用var声明    var name stringvar age intvar isStudent bool            使用短变量声明操作符:=（也称为类型推导）    name := \"Alice\"age := 30isStudent := true              注意：使用:=声明的变量是自动初始化的，并且只能在函数内部使用（即它们是函数作用域的局部变量）。      变量类型  Golang 是一种静态类型语言，这意味着变量的类型在声明后不能更改。Golang 中的基本类型包括整数（如int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, byte等）、浮点数（如float32, float64）、复数（如complex64, complex128）、布尔值（bool）、字符串（string）等。此外，还有数组、切片、映射、通道和结构体等复合类型。      变量初始化          在声明变量时，可以使用赋值操作符=来初始化变量。如果声明了变量但没有初始化，那么它的值将是该类型的零值（例如，对于整数类型为 0，对于布尔类型为 false，对于字符串类型为空字符串”“等）。            变量作用域和生命周期：          作用域：变量可以在其声明的代码块（例如函数或循环）中访问。在函数内部声明的变量是局部变量，它们在该函数执行完毕后将不再存在。在函数外部声明的变量是全局变量，可以在整个包（package）中访问。      生命周期：变量的生命周期从它声明时开始，到其所在的代码块执行完毕时结束（对于局部变量）或程序结束时结束（对于全局变量）。在垃圾收集器运行期间，不再使用的变量所占用的内存将被自动释放。            命名规范：变量名应遵循一定的命名规范以提高代码的可读性和可维护性。通常，变量名应该使用驼峰命名法（camelCase），并且应该具有描述性以反映其用途。避免使用与 Golang 关键字或内置函数名相同的变量名。  完整例子package mainimport \"fmt\"func main() {    // 使用 var 关键字声明变量    var name string    var age int    var isStudent bool    // 初始化变量    name = \"Alice\"    age = 30    isStudent = false    // 使用 fmt 包打印变量值    fmt.Println(\"Name:\", name)    fmt.Println(\"Age:\", age)    fmt.Println(\"Is Student:\", isStudent)    // 使用短变量声明操作符 :=    grade := 90.5    fmt.Println(\"Grade:\", grade)    // 声明并初始化一个字符串切片    fruits := []string{\"apple\", \"banana\", \"cherry\"}    fmt.Println(\"Fruits:\", fruits)    // 遍历切片    for _, fruit := range fruits {        fmt.Println(fruit)    }    // 声明并初始化一个映射（map）    person := map[string]int{        \"Alice\":   25,        \"Bob\":     30,        \"Charlie\": 35,    }    // 访问映射中的值    fmt.Println(\"Bob's age from map:\", person[\"Bob\"])    // 如果键不存在，返回该类型的零值    fmt.Println(\"David's age from map (if exists):\", person[\"David\"])}在上面的示例中，我们展示了如何：  使用 var 关键字声明变量，并后续初始化它们。  使用短变量声明操作符 := 来声明并初始化变量（在这种情况下，Go 语言会自动推断变量的类型）。  声明和初始化一个字符串切片（slice）并遍历它。  声明和初始化一个映射（map），并访问其中的值。注意，当我们尝试访问映射中不存在的键时（如 “David”），Go 语言会返回该类型的零值（在这种情况下是 int 类型的零值，即 0）。iota  iota是一个预定义的标识符，用于创建自增的无类型整数常量。它通常用于枚举类型，为每个枚举值生成一个唯一的常量。iota的行为类似于一个计数器，每次在常量声明中出现时都会自增一次。基本用法iota在每个const关键字出现时被重置为 0，并在每个const块中为每个新声明的常量自增。如果在同一行声明了多个常量，则它们将共享相同的iota值，除非显式地给其中一个常量赋值。使用示例以下是一个使用iota来定义星期几的枚举类型的示例：package mainimport \"fmt\"func main() {    const (        Sunday = iota // iota 初始化为 0        Monday        // iota 自增为 1        Tuesday       // iota 自增为 2        Wednesday     // iota 自增为 3        Thursday      // iota 自增为 4        Friday        // iota 自增为 5        Saturday      // iota 自增为 6    )    fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday) // 输出: 0 1 2 3 4 5 6}在这个例子中，iota从 0 开始，并在每个新的常量声明中自动递增。因此，Sunday的值为 0，Monday的值为 1，依此类推。递增规则  iota从 0 开始递增。  每个const块中的iota值都会自动递增，不需要显式操作。  在同一个const块中，每次遇到iota都会自增。  在不同的const块中，iota会重新从 0 开始递增。通过使用iota，可以简洁地定义一系列有序的常量，提高代码的可读性和可维护性。特殊例子  展示iota的特殊情况，包括在同一行声明多个常量时如何共享相同的iota值，以及如何显式地给某个常量赋值以改变iota的自动递增。特殊情况示例package mainimport \"fmt\"func main() {    const (        // iota 在这里初始化为 0        Sunday = iota // iota 值为 0        Monday        // iota 值为 1        Tuesday       // iota 值为 2        // 显式赋值会改变 iota 的值        WeekdayStart = Monday // WeekdayStart 值为 1，但 iota 仍然为 2        // 同一行声明的常量共享相同的 iota 值        Wednesday, Thursday = iota + 2, iota + 3 // Wednesday 值为 4，Thursday 值为 5        // iota 继续自增        Friday        // iota 值为 6        Saturday      // iota 值为 7        // 可以在新的 const 块中重置 iota        const (            firstQuarter = iota // iota 被重置为 0            secondQuarter       // iota 值为 1        )    )    fmt.Println(Sunday, Monday, Tuesday, WeekdayStart) // 输出: 0 1 2 1    fmt.Println(Wednesday, Thursday, Friday, Saturday) // 输出: 4 5 6 7    fmt.Println(firstQuarter, secondQuarter)          // 输出: 0 1}在这个例子中，首先定义了星期几的常量，并使用iota进行自动递增。然后，我们显式地将Monday的值赋给了WeekdayStart，但请注意，这并不会改变iota的自动递增行为，iota的值在赋值之后继续递增。接下来，在同一行声明了Wednesday和Thursday，并为它们分别赋了iota + 2和iota + 3的值。由于它们在同一行声明，所以它们都使用了同一个iota值（此时为 2），但加上了不同的偏移量。最后，在一个新的const块中再次使用了iota，它会被重置为 0，并在该块中继续递增。通过这个示例，可以看到iota的灵活性和在定义枚举或常量序列时的强大功能。常量  在 Go 语言中，常量（Constants）是固定不变的值，它们在程序编译时被确定，并且在整个程序的执行过程中都不能被修改。常量可以是布尔值、数字（整数或浮点数）、字符串或枚举值。常量的声明和初始化在 Go 语言中，常量可以使用const关键字进行声明。你可以在同一行声明多个常量，如果它们具有相同的类型。如果常量的类型没有明确指定，那么 Go 编译器会根据常量的值来推断其类型。以下是一些常量声明的例子：package mainimport \"fmt\"func main() {    // 声明并初始化单个常量    const Pi = 3.14159    // 在同一行声明多个相同类型的常量    const (        StatusOK    = 200        StatusFound = 302        StatusBad   = 400    )    // 使用 iota 进行递增的常量声明    const (        x = iota // x == 0        y        // y == 1        z        // z == 2        wp       // 如果在这一行前没有显式赋值，则 wp 也会自增，wp == 3    )    // 显式赋值会改变 iota 的自增行为    const (        v = iota     // v == 0        u = 100      // u == 100, iota 的自增被这个显式赋值打断了        vv = iota    // vv == 1, iota 继续从上一个显式值开始自增        ww = \"hello\" // ww 是字符串类型，iota 的自增被打断        xx           // xx 在这里会是一个新的 iota 值，但它不会被使用（因为没有赋值给它）    )    fmt.Println(Pi)    fmt.Println(StatusOK, StatusFound, StatusBad)    fmt.Println(x, y, z, wp)    // 注意：vv 和 ww 不会被打印，因为它们没有在这段代码中被使用}常量的类型  数值常量：可以是整数或浮点数。  布尔常量：可以是true或false。  字符串常量：用双引号（\"）或反引号（```）括起来的字符序列。反引号中的字符串会原样输出，不进行转义。常量的特点  常量在声明时必须赋值。  常量一旦被声明，其值就不能再改变。  常量在编译时就已经确定，因此它们的值在运行时不会改变。  常量可以是任何基本数据类型，也可以是数组、结构体和切片的组合类型，但不能是函数、映射或通道类型。iota 枚举iota是 Go 语言中的一个特殊常量，用于创建枚举值。在const声明中，iota会被自动赋值为 0，然后在每次新的const声明中自增 1。iota通常用于生成一组递增的整数常量。如上面示例中所示，你可以在同一行使用iota为多个常量赋值，或者在不同的行中使用iota来生成连续的整数常量。"
  },
  
  {
    "title": "Day01（Golang 入门介绍）",
    "url": "/posts/1-go_base/",
    "categories": "Language, Go",
    "tags": "Server, Go, GoBase",
    "date": "2019-03-30 08:08:01 +0800",
    





    
    "snippet": "Golang 基础本章源码初步认识 Golang  Go 跨平台（linux、windows、mac），只要编写完代码之后 交叉编译即可  Go 语言单一、简洁、天生高并发、CGO  Go 应用广（web 应用、区块链、运维、云计算、大数据）Go 环境Linux &amp; MacOs  下载 Golang 安装包：在 Golang 官方网站上下载适合自己 Linux 发行版和架构的 Gol...",
    "content": "Golang 基础本章源码初步认识 Golang  Go 跨平台（linux、windows、mac），只要编写完代码之后 交叉编译即可  Go 语言单一、简洁、天生高并发、CGO  Go 应用广（web 应用、区块链、运维、云计算、大数据）Go 环境Linux &amp; MacOs  下载 Golang 安装包：在 Golang 官方网站上下载适合自己 Linux 发行版和架构的 Golang 安装包      解压安装包：将下载的安装包解压到系统的某个目录下，如 /usr/local。    sudo tar -C /usr/local -xzf go*.tar.gz            配置环境变量：编辑 ~/.bashrc 或者 ~/.profile 文件，添加以下内容：    export PATH=$PATH:/usr/local/go/bin            使环境变量生效：执行以下命令使环境变量生效    source ~/.bashrc        或者    source ~/.profile        检查安装：打开命令行终端，输入 go version 命令，如果输出 Golang 的版本号，则说明 Golang 安装成功  注意：不同的 Linux 发行版可能有所不同，以上是一个基本的安装步骤，具体步骤可以根据自己的情况进行调整Windows  下载 Golang 安装包：在 Golang 官方网站 官方网站上下载适合自己 Windows 版本和架构的 Golang 安装包。  运行安装程序：运行下载的 Golang 安装包，按照提示进行安装，通常只需要选择安装路径和确认安装即可      配置环境变量：将 Golang 的 bin 目录添加到系统的 PATH 环境变量中，这样才能在命令行中使用 Golang 的命令          打开”控制面板” -&gt; “系统和安全” -&gt; “系统” -&gt; “高级系统设置” -&gt; “环境变量”      在”系统变量”中找到”Path”变量，点击”编辑”      在编辑系统变量窗口中，点击”新建”，输入 Golang 的 bin 目录，例如 C:\\Go\\bin      点击”确定”保存修改。        检查安装：打开命令行终端，输入 go version 命令，如果输出 Golang 的版本号，则说明 Golang 安装成功。  注意：在 Windows 环境下，如果出现权限问题，需要使用管理员权限运行命令行终端环境变量  注：GOROOT、GOPATH、GOOS、GOHOSTARCH 、GO111MODULE、GOPROXY 重要Git 工具安装  go get 下载代码需要 依赖 gitGolang 开发工具  推荐开发工具  Goland  vs code  vimGolang HelloWorld在某个目录下面创建 main.gopackage mainimport \"fmt\"func main() {  fmt.Println(\"Hello World!\")}编译运行D:\\file\\gopath\\src\\Cc360428\\helloWorld&gt;go build -o helloWorld.exeD:\\file\\gopath\\src\\Cc360428\\helloWorld&gt;helloWorld.exeHello World!D:\\file\\gopath\\src\\Cc360428\\helloWorld&gt;基础语法分隔符一行代表一个结束，每一句不需要与其他语言一行 ;来表示结束，Go 语言在编译时 i 自动会完成注释// 单行注释/**多行注释*/标识符  标识符用来命名变量、常量、实体  不能以数字开头  Go 语言关键字不能使用  运算符不能使用关键字  25 个关键保留字          包管理-2                  import          package                    程序实体声明与定义-8                  chan          const          func          interface          map          struct          type          var                    程序流程控制-16                  break          case          continue          default          defer          else          fallthrough          for          go          goto          if          range          return          select          switch                      36 个预定义标识符          append      bool      byte      cap      close      copy      recover      false      TRUE      panic      print      println      iota      len      make      new      nil      real      int      int8      int16      int32      int64      string      uint      uint8      uint16      uint32      uint64      uintprt      complex      complex64      complex128      float32      float64      imag      常见  变量的声明必须使用空格隔开  运算符之间加空格，一定时候加空格会跟好看，不要怕会占空间、go 语言编译时候可以去掉空格和换行  未使用的变量会编译不通过  写完代码之后常见使用 go fmt [*.go]格式化代码      pubulic And private          不管变量名或者是方法名，如果首字母大写就是(pubulic) ，首字母小写就是(private)      基础学习路线  数据类型  变量  常量  运算符  条件语句  循环语句  函数  变量作用域  数组  指针  结构体  切片（Slice）  range 使用  Map（集合）  Container  接口  错误处理  并发基础概括  语言特性和语法：Golang 是一门静态类型、编译型、并发型、垃圾回收的编程语言。它的语法简洁、清晰，具有自动垃圾回收、内置并发机制等特性，使得开发人员可以更快速、高效地开发应用程序。  变量和常量：在 Golang 中，变量必须显式声明，可以使用 var 或 := 来声明变量。常量则使用 const 关键字声明。  基本数据类型：Golang 中的基本数据类型包括整型、浮点型、布尔型、字符串等。其中整型又包括 int、int8、int16、int32、int64 等类型，浮点型则包括 float32 和 float64 两种类型。  控制流程语句：Golang 中的控制流程语句包括条件语句、循环语句和跳转语句。其中条件语句包括 if 和 switch 语句，循环语句则包括 for 和 range 语句，跳转语句则包括 break、continue 和 goto 语句。  数组、切片和映射：Golang 中的数组是固定长度的，而切片则是可变长度的，它们都可以用来存储同一种类型的数据。映射则是一种键值对的数据结构，也称为字典或哈希表。  函数和方法：在 Golang 中，函数是独立的代码块，可以被多次调用。方法则是属于某个类型的函数，它可以通过该类型的实例来调用。  结构体和接口：Golang 中的结构体是一种自定义类型，由多个字段组成。接口则是一种抽象类型，定义了一组方法，用来描述一种行为。  并发编程：Golang 内置了 goroutine 和 channel，它们是 Golang 并发编程的核心。goroutine 是一种轻量级的线程，通过关键字 go 来启动。channel 则是一种通信机制，用来在 goroutine 之间传递数据。本教程代码所有都会公开到 gitee.com  为什么不使用 github.com 因为 github 下载会受到网络影响，所以 go 教程代码会使用 gitee 代码管理，在此也谢谢 giteegitee 仓库地址gitee 地址"
  },
  
  {
    "title": "Flutter HelloWorld",
    "url": "/posts/Flutter-HelloWorld/",
    "categories": "Language, Dart",
    "tags": "Client, Dart, Flutter",
    "date": "2019-02-12 22:58:36 +0800",
    





    
    "snippet": "Android Studio 环境搭建查看 Android SDK  安装 Android Studio 查看安装 Android SDK 位置File-&gt;other Settings -&gt; Defaylt Project Structure  可以看到 Android SDK locationAndroid Studio 中安装 Flutter 插件Android Studio...",
    "content": "Android Studio 环境搭建查看 Android SDK  安装 Android Studio 查看安装 Android SDK 位置File-&gt;other Settings -&gt; Defaylt Project Structure  可以看到 Android SDK locationAndroid Studio 中安装 Flutter 插件Android Studio-&gt;Perfernces-&gt;Plugins-&gt;Marketplace(See flutter)-&gt;install-&gt;Restart IDE编写第一个 Flutter  https://flutterchina.club/get-started/test-drive/使用终端  flutter create myapp  cd myApp  flutter devices1 connected device:COL AL10 • 9YEDU18427028281 • android-arm64 • Android 10 (API 29)使用 Android StudioError Build Tools revision 28.0.3FAILURE: Build failed with an exception.* What went wrong:Could not determine the dependencies of task ':app:compileDebugJavaWithJavac'.&gt; Failed to find Build Tools revision 28.0.3* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 1m 10sException: Gradle task assembleDebug failed with exit code 1  解决方案  再开启一个 Android Stucio  打开 flutter 中 Android 文件为一个项目(项目初始化 ok 后)Tools-&gt;SDK Manager-&gt;SDK Tools(点击[Show Package Details])-&gt;☑️28.0.3-&gt;Apply(ok) 即可AVD 安装Create Virtual Device -&gt;Phone-&gt;选择规格"
  },
  
  {
    "title": "环境搭建",
    "url": "/posts/Flutter-Base/",
    "categories": "Language, Dart",
    "tags": "Client, Dart, Flutter",
    "date": "2019-02-12 22:58:36 +0800",
    





    
    "snippet": "Dart环境安装  下载 DartSDK  添加环境变量export DART_HOME=/usr/local/dart/dart-sdk/binexport PATH=\"${DART_HOME}:${PATH}\"Flutter环境搭建  获取 SDK          zip                  https://flutter.dev/docs/development/too...",
    "content": "Dart环境安装  下载 DartSDK  添加环境变量export DART_HOME=/usr/local/dart/dart-sdk/binexport PATH=\"${DART_HOME}:${PATH}\"Flutter环境搭建  获取 SDK          zip                  https://flutter.dev/docs/development/tools/sdk/releases?tab=macos#macos          https://github.com/flutter/flutter/releases                    git        设置环境变量export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATHexport PATH=/Users/用户名/Documents/flutter/flutter/bin:$PATHexport ANDROID_HOME=\"/Users/用户名/Documents/android_sdk\" //android sdk目录，替换为你自己的即可export PATH=${PATH}:${ANDROID_HOME}/toolsexport PATH=${PATH}:${ANDROID_HOME}/platform-toolsexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn  搭建 ok 环境# dart_flutterexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/usr/local/dart/flutter/bin:$PATH测试  flutter -h(是否环境 ok)$ flutter -hManage your Flutter app development.Common commands:  flutter create &lt;output directory&gt;    Create a new Flutter project in the specified directory.  flutter run [options]    Run your Flutter application on an attached device or in an emulator.Usage: flutter &lt;command&gt; [arguments]Global options:-h, --help                  Print this usage information.-v, --verbose               Noisy logging, including all shell commands executed.                            If used with --help, shows hidden options.-d, --device-id             Target device id or name (prefixes allowed).    --version               Reports the version of this tool.    --suppress-analytics    Suppress analytics reporting when this command runs.    --packages              Path to your \".packages\" file.                            (required, since the current directory does not contain a \".packages\" file)Available commands:  analyze                  Analyze the project's Dart code.  assemble                 Assemble and build flutter resources.  attach                   Attach to a running application.  bash-completion          Output command line shell completion setup scripts.  build                    Flutter build commands.  channel                  List or switch flutter channels.  clean                    Delete the build/ and .dart_tool/ directories.  config                   Configure Flutter settings.  create                   Create a new Flutter project.  devices                  List all connected devices.  doctor                   Show information about the installed tooling.  downgrade                Downgrade Flutter to the last active version for the current channel.  drive                    Runs Flutter Driver tests for the current project.  emulators                List, launch and create emulators.  format                   Format one or more dart files.  generate                 run code generators.  install                  Install a Flutter app on an attached device.  logs                     Show log output for running Flutter apps.  make-host-app-editable   Moves host apps from generated directories to non-generated directories so that they can be edited by developers.  precache                 Populates the Flutter tool's cache of binary artifacts.  pub                      Commands for managing Flutter packages.  run                      Run your Flutter app on an attached device.  screenshot               Take a screenshot from a connected device.  symbolize                Symbolize a stack trace from an AOT compiled flutter application.  test                     Run Flutter unit tests for the current project.  upgrade                  Upgrade your copy of Flutter.  version                  List or switch flutter versions.Run \"flutter help &lt;command&gt;\" for more information about a command.Run \"flutter help -v\" for verbose help output, including less commonly used options.  flutter devices(校验连接设备)1 connected device:COL AL10 • 9YEDU18427028281 • android-arm64 • Android 10 (API 29)  flutter doctor(校验开发环境)$ flutter doctorDoctor summary (to see all details, run flutter doctor -v):[✓] Flutter (Channel stable, v1.17.5, on Mac OS X 10.15.4 19E287, locale zh-Hans-HK)[✓] Android toolchain - develop for Android devices (Android SDK version 30.0.1)[✗] Xcode - develop for iOS and macOS    ✗ Xcode installation is incomplete; a full installation is necessary for iOS development.      Download at: https://developer.apple.com/xcode/download/      Or install Xcode via the App Store.      Once installed, run:        sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer        sudo xcodebuild -runFirstLaunch    ✗ CocoaPods not installed.        CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to your plugin usage on the Dart side.        Without CocoaPods, plugins will not work on iOS or macOS.        For more info, see https://flutter.dev/platform-plugins      To install:        sudo gem install cocoapods[✓] Android Studio (version 4.0)[!] IntelliJ IDEA Ultimate Edition (version 2020.1.2)    ✗ Flutter plugin not installed; this adds Flutter specific functionality.    ✗ Dart plugin not installed; this adds Dart specific functionality.[✓] VS Code (version 1.47.0)[✓] Connected device (1 available)! Doctor found issues in 2 categories.配置国内 package 环境  在操作系统下面添加国内源地址即可export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn  依赖包flutter packages getflutter pub get"
  },
  
  {
    "title": "手机推送",
    "url": "/posts/Error/",
    "categories": "Language, Dart",
    "tags": "Client, Dart, Flutter",
    "date": "2019-02-12 22:58:36 +0800",
    





    
    "snippet": "Error获取包错误Waiting for another flutter command to release the startup lock...  解决办法cd /usr/local/dart/flutter/bin/cacherm -rf lockfile拉依赖包This is taking an unexpectedly long time.Error:FAILURE: Buil...",
    "content": "Error获取包错误Waiting for another flutter command to release the startup lock...  解决办法cd /usr/local/dart/flutter/bin/cacherm -rf lockfile拉依赖包This is taking an unexpectedly long time.Error:FAILURE: Build failed with an exception"
  },
  
  {
    "title": "手机推送",
    "url": "/posts/appOffLinePush/",
    "categories": "Dev, Utils",
    "tags": "Client",
    "date": "2019-02-12 22:58:36 +0800",
    





    
    "snippet": "手机推送IOSgithub 方法https://www.jianshu.com/p/c90204ef6e4agithub Test1方法https://blog.csdn.net/jeffasd/article/details/69950979https://www.jb51.cc/go/188684.htmlhttp://docs-im.easemob.com/im/300iosclien...",
    "content": "手机推送IOSgithub 方法https://www.jianshu.com/p/c90204ef6e4agithub Test1方法https://blog.csdn.net/jeffasd/article/details/69950979https://www.jb51.cc/go/188684.htmlhttp://docs-im.easemob.com/im/300iosclientintegration/75apnshttps://blog.csdn.net/u014633966/article/details/82771486Android 推送华为华为开发者文档开发者  开发者          Developer ID：100—-      验证公钥：      MIIBojANBgkqhkiG9----  项目          数据存储位置：中国      Client ID：362838----      Client 密钥： 371E318A5F3AED5----        应用          包名： —-.dy.im      APP ID：102—-      API key： CV7lyqFutKCl8VQ----      APP SECRET： c221a0513d9a27127----        Client Token086938403----  agconnect-services.json{  \"agcgw\": {    \"backurl\": \"connect-drcn.dbankcloud.cn\",    \"url\": \"connect-drcn.hispace.hicloud.com\"  },  \"client\": {    \"cp_id\": \"1008600----\",    \"product_id\": \"736430----\",    \"client_id\": \"362838645----\",    \"client_secret\": \"371E318A5F3AED59E7----\",    \"app_id\": \"102---\",    \"package_name\": \"---.dy.im\",    \"api_key\": \"CV7lyqFutK---+hFh28OSy---\"  },  \"service\": {    \"analytics\": {      \"collector_url\": \"datacollector-drcn.dt.hicloud.com,datacollector-drcn.dt.dbankcloud.cn\",      \"resource_id\": \"p1\",      \"channel_id\": \"\"    },    \"ml\": {      \"mlservice_url\": \"ml-api-drcn.ai.dbankcloud.com,ml-api-drcn.ai.dbankcloud.cn\"    }  },  \"region\": \"CN\",  \"configuration_version\": \"1.0\"}  应用信息          创建时间：2020-05-15 14:55:37      包名：—.dy.im      软件包类型：APK      支持设备：手机      APP ID：1022—      SecretKey：c221a0513---      小米ok魅族（测试 ok）开发者平台账号密码  182—  meizu—开发者  应用名称 dy  应用包名 ---.dy.im  App ID 13---  App Key 1003---  App Secret e776c---oppo  等待开通企业服务开发者平台服务端推送接口测试 demohttps://push.oppo.com/push/notificationvivo开通推送开发者服务开发者文档https://blog.csdn.net/weixin_42580207/article/details/87093895hys 提供网址账号密码账号：qi—密码：qi—名字重复逗呀驳回驳回原因：1、应用安装到手机上显示的名称（逗呀）需与在后台创建时填写的主标题一致，且不得增字、增符号；2、应用介绍需体现应用内容或功能，不得出现无关信息，如（dy 社交工具，测试阶段，测试消息推送测试阶段，测试消息推送测试阶段，测试消息推送测试阶段，）；3、应用截图可上传3-5张图片，不得出现重复图片；"
  },
  
  {
    "title": "Idea 快捷键",
    "url": "/posts/idea-use/",
    "categories": "Dev, Utils",
    "tags": "Tools",
    "date": "2019-01-26 12:48:54 +0800",
    





    
    "snippet": "Idea 快捷键编辑  Ctrl + X：剪切当前行或者选中的区域  Ctrl + C：复制当前行或者选中的区域  Ctrl + V：粘贴当前剪贴板中的内容  Ctrl + Z：撤销操作  Ctrl + Shift + Z：重做操作  Ctrl + D：复制当前行或者选中的区域到下一行  Ctrl + Delete：删除光标所在位置到单词结尾的文本  Ctrl + Backspace：删除光...",
    "content": "Idea 快捷键编辑  Ctrl + X：剪切当前行或者选中的区域  Ctrl + C：复制当前行或者选中的区域  Ctrl + V：粘贴当前剪贴板中的内容  Ctrl + Z：撤销操作  Ctrl + Shift + Z：重做操作  Ctrl + D：复制当前行或者选中的区域到下一行  Ctrl + Delete：删除光标所在位置到单词结尾的文本  Ctrl + Backspace：删除光标所在位置到单词开头的文本  Ctrl + Shift + Up/Down：上下移动当前行导航  Ctrl + N：根据类名查找并打开文件  Ctrl + Shift + N：根据文件名查找并打开文件  Ctrl + Alt + Shift + N：根据符号名查找并打开文件  Ctrl + F12：显示当前文件的结构（方法、属性等）列表  Ctrl + E：打开最近使用的文件列表  Ctrl + G：跳转到指定行数  Ctrl + Shift + Alt + T：弹出 Refactor This 菜单搜索  Ctrl + F：查找当前文件中的指定文本  Ctrl + Shift + F：全局查找指定文本  Ctrl + R：在当前文件中替换指定文本  Ctrl + Shift + R：全局替换指定文本代码  Ctrl + Space：自动完成代码  Ctrl + Shift + Enter：在当前行末自动添加分号、括号等  Ctrl + Shift + Space：显示参数信息  Ctrl + Alt + V：自动创建变量并赋值  Ctrl + Alt + N：自动创建匿名类  Ctrl + Alt + T：弹出 Surround With 菜单，包裹代码块  Ctrl + Shift + F7：高亮显示当前选中的文本在文件中的所有出现位置  Ctrl + Shift + F6：重命名当前变量、方法或者类调试  F8：单步执行（不进入函数）  F7：单步执行（进入函数）  Shift + F7：智能步入，会自动选择进入哪个子函数  Shift + F8：跳出当前函数  Alt + F9：运行到光标所在行  Alt + F10：从断点处恢复程序执行  Ctrl + Shift + F8：打开断点列表"
  },
  
  {
    "title": "Redis All",
    "url": "/posts/redis-all/",
    "categories": "Dev, Database, Redis",
    "tags": "Database, Nosql",
    "date": "2019-01-26 12:48:54 +0800",
    





    
    "snippet": "Redis（Remote Dictionary Server）什么是 Redis  是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。  Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。  与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，...",
    "content": "Redis（Remote Dictionary Server）什么是 Redis  是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。  Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。  与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的 Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA 脚本、LRU驱动事件、多种集群方案。Redis 优缺点优点  读写性能优异， Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。  支持数据持久化，支持 AOF 和 RDB 两种持久化方式。  支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。  数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。  支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。缺点  数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。  Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。  主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。  Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。为什么要使用 Redis高性能  假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！高并发  直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。Redis 为什么这么快1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；4、使用多路 I/O 复用模型，非阻塞 IO；5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；数据类型  5 种主要数据类型（string 、list、set、zset、hash）应用场景计数器可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。缓存将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。会话缓存可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。全页缓存（FPC）除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。查找表例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。消息队列(发布/订阅功能)List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。分布式锁实现在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的RedLock 分布式锁实现。其它Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。应用场景总结  string——适合最简单的 k-v 存储，类似于 memcached 的存储结构，短信验证码，配置信息等，就用这种类型来存储。  hash——一般 key 为 ID 或者唯一标示，value 对应的就是详情了。如商品详情，个人信息详情，新闻详情等。  list——因为 list 是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为 list是有序的，适合根据写入的时间来排序，如：最新的，消息队列等  set——可以简单的理解为 ID-List 的模式，如微博中一个人有哪些好友，set 最牛的地方在于，可以对两个 set提供交集、并集、差集操作。例如：查找两个人共同的好友等。  Sorted Set——是 set 的增强版本，增加了一个 score 参数，自动会根据 score 的值进行排序。比较适合类似于 top 10等不根据插入的时间来排序的数据。持久化  提供两种持久化机制 RDB（默认） 和 AOF 机制RDB(Redis Data Base)  RDB 是默认持久化，按照一定时间将内存中数据把保存硬盘中，会产出数据文件 dump.rdb，时间可以通过配置文件 save参数配置  自动触发save 900 1：表示900 秒内如果至少有 1 个 key 的值变化，则保存save 300 10：表示300 秒内如果至少有 10 个 key 的值变化，则保存save 60 10000：表示60 秒内如果至少有 10000 个 key 的值变化，则保存      手动触发          save        该命令会阻塞当前 Redis 服务器，执行 save 命令期间，Redis 不能处理其他命令，直到 RDB 过程完成为止。    显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis 提供了第二种方式。          bgsave        执行该命令时，Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是 Redis 进程执行 fork 操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。          基本上 Redis 内部所有的 RDB 操作都是采用 bgsave 命令。      执行执行 flushall 命令，也会产生 dump.rdb 文件，但里面是空的      优点：1、只有一个文件 dump.rdb，方便持久化。2、容灾性好，一个文件可以保存到安全的磁盘。3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何IO 操作，保证了 redis 的高性能4.相对于数据集大时，比 AOF 的启动效率更高。缺点：1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)2、AOF（Append-only file)持久化方式：是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件AOF (Append Only File)  每次写命令记录到单独文件日志文件中，当重启讲持久化日志中文件恢复数据优点：1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)缺点：1、AOF 文件比 RDB 文件大，且恢复速度慢。2、数据集大的时候，比 rdb 启动效率低。RDB and AOF  AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。  AOF 比 RDB 更安全也更大  RDB 性能比 AOF 好  如果两个都配了优先加载 AOF如何选择持久化方式  一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性，你应该同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。  如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。  有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。  如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式。事务127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET name lccQUEUED127.0.0.1:6379&gt; get nameQUEUED127.0.0.1:6379&gt; sadd tags \"java\" \"golang\"QUEUED127.0.0.1:6379&gt; smembers tagQUEUED127.0.0.1:6379&gt; exec1) OK2) \"lcc\"3) (integer) 24) (empty list or set)127.0.0.1:6379&gt;            序号      命令及描述                  1      DISCARD 取消事务，放弃执行事务块内的所有命令。              2      EXEC 执行所有事务块内的命令。              3      MULTI 标记一个事务块的开始。              4      UNWATCH 取消 WATCH 命令对所有 key 的监视。              5      WATCH key [key …]] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。      集群方案  哨兵模式缓存异常缓存雪崩  缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。解决方案  缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。  一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。  给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。缓存穿透  缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉      解决方案          接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截；      从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击      采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap拦截掉，从而避免了对底层存储系统的查询压力      缓存击穿Redis 与 Mysql 同步机制Mysql 同步到 Redis      在 redis 数据库设置缓存时间，当该条数据缓存时间过期之后自动释放，去数据库进行重新查询，但这样的话，我们放在缓存中的数据对数据的一致性要求不是很高才能放入缓存当中          缓存量大但又不常变化的数据，比如商品信息的评论            基于 binlog 使用 mysql_udf_redis，将数据库中的数据同步到 Redis          无论 MySQL 还是 Redis，自身都带有数据同步的机制，像比较常用的 MySQL 的 Master/Slave 模式，就是由 Slave 端分析 Master 的binlog 来实现的，这样的数据其实还是一个异步过程，只不过当服务器都在同一内网时，异步的延迟几乎可以忽略。      那么理论上我们也可以用同样方式，分析 MySQL 的 binlog 文件并将数据插入 Redis。但是这需要对 binlog 文件以及 MySQL有非常深入的理解，同时由于 binlog 存在 Statement/Row/Mixedlevel 多种形式，分析 binlog 实现同步的工作量是非常大的            通过 MySQL 自动同步刷新 Redis          当我们在业务层有数据查询需求时，先到 Redis 缓存中查询，如果查不到，再到 MySQL 数据库中查询，同时将查到的数据更新到 Redis里；当我们在业务层有修改插入数据需求时，直接向 MySQL 发起请求，同时更新 Redis 缓存。 就是 MySQL 的 CRUD 发生后自动地更新到Redis 里，这需要通过 MySQL UDF 来实现。具体来说，我们把更新 Redis 的逻辑放到 MySQL 中去做，即定义一个触发器 Trigger，监听CRUD 这些操作，当操作发生后，调用对应的 UDF 函数，远程写回 Redis，所以业务逻辑只需要负责更新 MySQL 就行了，剩下的交给 MySQLUDF 去完成。            在我们的实际开发当中往往采用如下方式实现实现 Mysql 和 Redis 数据同步：当我们在 MySQL 数据库中进行增删改的时候，我们在增删改的service 层将缓存中的数据清除，这个时候用户在此请求的时候我们缓存中没有数据了，直接去数据库中查询，查询回来之后将缓存中的数据放缓存当中，这个时候缓存中的数据就是最新的数据。  Redis 同步到 MySql  redis 读取速度快，也没有必要把所有的数据都放到 redis 里面，redis 里面只放使用频繁，用户操作量较大的数据，或者用户近期使用的数据  不是很重要可以设置定时器，在晚上用户访问少时候同步"
  },
  
  {
    "title": "MySQL Operate",
    "url": "/posts/mysql-operate/",
    "categories": "Dev, Database, Mysql",
    "tags": "Database, SQL",
    "date": "2018-12-09 22:21:48 +0800",
    





    
    "snippet": "数据库（Database）库阈值  MySQL 8.0 版本之前，一个数据库中最多可以有 65535 个表。因为 采用 16 位 最大值为 2^16 - 1 = 65535  MySQL 8.0 开始，采用 32 位整数来存储表的数量，因此最大值变成了 2^32 - 1数据库规范  命名规范          使用有意义且描述性强的名称，避免使用无意义的缩写或简写。      使用小写字母命...",
    "content": "数据库（Database）库阈值  MySQL 8.0 版本之前，一个数据库中最多可以有 65535 个表。因为 采用 16 位 最大值为 2^16 - 1 = 65535  MySQL 8.0 开始，采用 32 位整数来存储表的数量，因此最大值变成了 2^32 - 1数据库规范  命名规范          使用有意义且描述性强的名称，避免使用无意义的缩写或简写。      使用小写字母命名数据库，表和列名，可以提高可移植性和跨平台兼容性。      使用下划线或驼峰命名法作为命名的一种风格，保持一致性        使用字符集          指定数据库的字符集和校对规则，确保支持所需的语言和字符集。      常用的字符集包括 UTF-8 和 UTF-8mb4，它们支持更广泛的字符范围，适用于多语言环境。        选择存储引擎          根据应用需求选择合适的存储引擎，如 InnoDB、MyISAM、Memory 等。      InnoDB 是 MySQL 默认的存储引擎，支持事务和外键约束，适合大多数应用。        权限管理          对数据库的访问权限进行细化和管理，根据用户角色分配不同的权限。      避免使用 root 或具有过大权限的账户直接连接数据库。      数据库操作      远程登录数据库：    mysql -h 127.0.0.1 -P 3306 -u admin -p12345678            查询所有数据库：    SHOW DATABASES;            创建数据库，并设置字符集为 UTF-8：    CREATE DATABASE my_database CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;            查询数据库：    SHOW DATABASES;            选择数据库：    USE my_database;            查询当前数据库：    SELECT DATABASE();            删除数据库    DROP DATABASE my_database;            导出指定数据库（需要包含数据库密码）    mysqldump -h 127.0.0.1 -P 3306 -u admin -p12345678 my_database &gt; backup.sql            导入指定数据库（需要包含数据库密码）    mysql -h 127.0.0.1 -P 3306 -u admin -p12345678 my_database &lt; backup.sql            执行外部 SQL 文件    &lt;!-- login sql server --&gt;SOURCE /path/to/your_sql_file.sql;      表（Table）表阈值  5.7 版本以前的 InnoDB 存储引擎中，每个表的行数限制为约 5000 万行  5.7 版本以后的 InnoDB 存储引擎中，每个表的行数限制则提高到了约 2000 亿行  单表超过了 500 万行或者单表超过 2GB 建议分表表基础操作      创建表并指定引擎和字符集     CREATE TABLE my_table (   id INT AUTO_INCREMENT PRIMARY KEY,   name VARCHAR(50),   age INT ) ENGINE=InnoDB CHARSET=utf8mb4 COMMENT 'this my_table test';            删除表：          完全删除数据库对象，包括数据、结构和元数据信息        DROP TABLE my_table;              快速删除表中的所有数据，但保留表的结构和元数据信息        TRUNCATE TABLE my_table;            修改表名：    ALTER TABLE old_table_name RENAME TO new_table_name;            修改表的字符集：    ALTER TABLE my_table CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;            查询所有表：    SHOW TABLES;            查询某个表结构：          查询接单结构        DESCRIBE my_table;              查询 sql        SHOW CREATE TABLE my_table;            导出表数据    mysqldump -u your_username -p your_database_name your_table_name &gt; output_file.sql      表索引      创建索引 (CREATE INDEX)：创建一个新的索引以加速查询。    CREATE INDEX index_name ON table_name (column_name);            删除索引 (DROP INDEX)：删除现有的索引。    DROP INDEX index_name ON table_name;            查看索引 (SHOW INDEX)：查看表格的索引信息。    SHOW INDEX FROM table_name;            修改索引 (ALTER TABLE)：修改现有的索引，如添加、删除或修改索引字段。    ALTER TABLE table_name ADD INDEX index_name (column_name);ALTER TABLE table_name DROP INDEX index_name;ALTER TABLE table_name MODIFY COLUMN column_name INT, ADD INDEX index_name (column_name);            重命名索引 (RENAME INDEX)：重命名现有的索引。    ALTER TABLE table_name RENAME INDEX old_index_name TO new_index_name;            使用索引提示 (USE INDEX)：指定查询使用的索引。    SELECT * FROM table_name USE INDEX (index_name);      事务操作  事务（Transaction）是一组数据库操作，被视为一个逻辑单元，要么全部执行成功，要么全部失败回滚，以保持数据的一致性和完整性。      开始事务 (BEGIN 或 START TRANSACTION)：开始一个新的事务。    BEGIN;-- 或者START TRANSACTION;            提交事务 (COMMIT)：将事务中的所有操作永久保存到数据库。    COMMIT;            回滚事务 (ROLLBACK)：撤销事务中的所有操作，恢复到事务开始之前的状态。    ROLLBACK;            设置事务隔离级别 (SET TRANSACTION ISOLATION LEVEL)：设置当前会话的事务隔离级别。    SET TRANSACTION ISOLATION LEVEL isolation_level;            完整例子                  简单使用        START TRANSACTION;INSERT INTO table1 (column1, column2) VALUES (value1, value2);UPDATE table2 SET column1 = new_value WHERE condition;DELETE FROM table3 WHERE condition;COMMIT;                    表视图什么是视图  视图（View）是数据库中的一种虚拟表格，它是基于一个或多个实际表格的查询结果动态生成的。视图本身并不存储数据，而是根据定义的查询语句在查询时动态生成结果集。      视图可以看作是一个存储在数据库中的预定义查询，它将复杂的查询逻辑封装起来，以简化对数据的访问和操作。通过视图，用户可以以简单的方式访问和操作数据库中的数据，而无需了解复杂的数据库结构或编写复杂的查询语句。        视图的主要优点包括：                  简化查询：通过视图，用户可以使用简单的 SELECT 语句从视图中检索数据，而无需编写复杂的查询语句。                    隐藏复杂性：视图可以隐藏底层表格的复杂性和结构，用户只需关注视图的接口即可。                    安全性：通过视图可以控制用户对数据库中数据的访问权限，可以限制用户只能访问特定的数据子集。                    重用性：视图可以被多个查询和应用程序重复使用，提高了代码的重用性和可维护性。              视图在数据库中广泛应用于各种场景，包括报表生成、数据分析、权限控制等。使用视图可以使数据库更加灵活、易于管理，并提高应用程序的性能和可扩展性。视图操作      创建视图 (CREATE VIEW)：创建一个新的视图。    CREATE VIEW view_name ASSELECT column1, column2, ...FROM table_nameWHERE condition;            查询视图 (SELECT)：从视图中检索数据。    SELECT * FROM view_name;            更新视图 (UPDATE)：更新视图中的数据。在某些情况下，可以更新视图，但要注意视图的定义必须符合一定的规则。    UPDATE view_nameSET column1 = value1WHERE condition;            删除视图 (DROP VIEW)：删除现有的视图。    DROP VIEW view_name;            查看视图定义 (SHOW CREATE VIEW)：查看视图的定义。    SHOW CREATE VIEW view_name;            替换视图 (CREATE OR REPLACE VIEW)：如果视图已存在，则替换现有的视图。    CREATE OR REPLACE VIEW view_name ASSELECT column1, column2, ...FROM table_nameWHERE condition;            视图嵌套 (Nested Views)：可以在一个视图中引用另一个视图。        使用视图权限 (GRANT 和 REVOKE)：授予或撤销用户对视图的权限        完整例子          假设我们有一个表格 employees 存储员工信息，包含 employee_id、first_name 和 last_name 字段。我们要创建一个视图，显示员工的全名        initCREATE TABLE employees (    employee_id INT PRIMARY KEY,    first_name VARCHAR(50),    last_name VARCHAR(50));INSERT INTO employees (employee_id, first_name, last_name)VALUES (1, 'John', 'Doe'),      (2, 'Jane', 'Smith'),      (3, 'Alice', 'Johnson');  然后，我们创建一个视图来显示员工的全名CREATE VIEW employee_names ASSELECT employee_id, CONCAT(first_name, ' ', last_name) AS full_nameFROM employees;  现在，我们可以从 employee_names 视图中检索员工的全名：SELECT * FROM employee_names;  结果+-------------+--------------+| employee_id | full_name    |+-------------+--------------+|           1 | John Doe     ||           2 | Jane Smith   ||           3 | Alice Johnson|+-------------+--------------+表字段操作      最后面添加字段：    ALTER TABLE table_name ADD column_name INT;            最前面添加字段：    ALTER TABLE table_name ADD column_name INT FIRST;            某个字段后面添加字段：    ALTER TABLE table_name ADD column_name INT AFTER existing_column_name;            删除字段：    ALTER TABLE table_name DROP COLUMN column_name;            修改字段名和类型：    ALTER TABLE table_name CHANGE old_column_name new_column_name INT;            修改字段类型和位置：    ALTER TABLE table_name MODIFY column_name VARCHAR(100) AFTER existing_column_name;      字段约束      主键约束（PRIMARY KEY）：          确保字段的唯一性，每个表只能有一个主键，并且主键字段不能为 NULL。        CREATE TABLE users (    user_id INT PRIMARY KEY,    username VARCHAR(50) UNIQUE,    email VARCHAR(100) NOT NULL);            唯一约束（UNIQUE）：          确保字段的唯一性，但允许字段为 NULL。          CREATE TABLE products (      product_id INT,      product_name VARCHAR(100),      UNIQUE (product_id)  );            非空约束（NOT NULL）：          确保字段不允许为空值。        CREATE TABLE orders (    order_id INT PRIMARY KEY,    customer_id INT NOT NULL,    order_date DATE DEFAULT CURRENT_DATE);            默认值约束（DEFAULT）：          指定字段的默认值，在插入数据时如果没有指定值，则自动使用默认值。        CREATE TABLE employees (    employee_id INT PRIMARY KEY,    first_name VARCHAR(50) NOT NULL,    last_name VARCHAR(50) NOT NULL,    hire_date DATE DEFAULT '2024-01-01');            检查约束（CHECK）：          对字段的取值进行条件检查，确保满足指定的条件。        CREATE TABLE students (    student_id INT PRIMARY KEY,    age INT CHECK (age &gt;= 18),    grade VARCHAR(2) CHECK (grade IN ('A', 'B', 'C', 'D', 'F')));      属性设置      数据类型 (Data Types)：指定字段可以存储的数据类型，如整数、字符、日期等。        NULL / NOT NULL：指定字段是否允许为空值。如果设置为 NOT NULL，则该字段在插入新行时必须有值。        默认值 (Default)：为字段指定默认值，在插入新行时如果未指定该字段的值，则将使用默认值。        主键 (Primary Key)：唯一标识表中的每一行，并确保其唯一性。        自增 (Auto Increment)：当插入新行时，自动为字段生成唯一的递增值。        唯一键 (Unique Key)：确保字段的值在表中是唯一的，但允许字段为 NULL。        外键 (Foreign Key)：建立表格之间的关系，确保参考另一个表中存在的值。        索引 (Index)：为字段创建索引，加快查询速度。        自定义约束 (Check Constraint)：定义字段值必须满足的条件。        自定义注释 (Comment)：为字段添加描述性注释，以便其他人理解字段的用途。  例子      依赖表      CREATE TABLE departments (      department_id INT AUTO_INCREMENT PRIMARY KEY  );            完整例子  CREATE TABLE employees (    employee_id INT AUTO_INCREMENT PRIMARY KEY COMMENT 'Employee unique identifier',    first_name VARCHAR(50) NOT NULL COMMENT 'Employee first name',    last_name VARCHAR(50) NOT NULL COMMENT 'Employee last name',    email VARCHAR(100) UNIQUE COMMENT 'Employee email address',    hire_date DATE NOT NULL COMMENT 'Employee hire date',    salary DECIMAL(10, 2) DEFAULT 0.00 COMMENT 'Employee salary',    department_id INT COMMENT 'Foreign key referencing department table',    CONSTRAINT fk_department FOREIGN KEY (department_id) REFERENCES departments(department_id),    INDEX idx_last_name (last_name)) COMMENT 'Table to store employee information';在这个例子中：  employee_id 是主键，使用 AUTO_INCREMENT 自增，有注释说明。  first_name 和 last_name 是必填字段，有注释说明。  email 是唯一字段，有注释说明。  hire_date 是必填字段，有注释说明。  salary 有默认值，默认为 0.00，有注释说明。  department_id 是外键，参考另一个表格中的值，有注释说明。  last_name 字段有索引，以提高查询效率。  整个表格有一个注释，说明了该表格的用途。"
  },
  
  {
    "title": "Web JavaScript Advanced",
    "url": "/posts/web-javascript-advanced/",
    "categories": "Language, Web",
    "tags": "Web, Javascript",
    "date": "2018-12-01 11:10:13 +0800",
    





    
    "snippet": "基础输出            输出方式      描述      示例                  console.log()      将输出内容打印到浏览器开发者工具的控制台      console.log(\"Hello, World!\");              alert()      弹出警告框,显示输出内容      alert(\"This is an alert!...",
    "content": "基础输出            输出方式      描述      示例                  console.log()      将输出内容打印到浏览器开发者工具的控制台      console.log(\"Hello, World!\");              alert()      弹出警告框,显示输出内容      alert(\"This is an alert!\");              document.write()      将输出内容直接写入当前 HTML 文档      document.write(\"&lt;h1&gt;Hello, World!&lt;/h1&gt;\");              innerHTML      将输出内容插入到 HTML 元素的内部      javascript&lt;br&gt;var element = document.getElementById(\"myDiv\");&lt;br&gt;element.innerHTML = \"This is some new content.\";              textContent      将输出内容插入到 HTML 元素,但只显示纯文本,不解析 HTML 标签      javascript&lt;br&gt;var element = document.getElementById(\"myDiv\");&lt;br&gt;element.textContent = \"This is some new text.\";      数据类型  原始数据类型            数据类型      描述      示例                  Number      包括整数和浮点数      42, 3.14, NaN, Infinity              String      文本数据      \"hello\", 'world', `template literal`              Boolean      表示真值或假值      true, false              Undefined      未定义的值      undefined              Null      空值      null              Symbol      唯一标识符      Symbol(\"id\")        复合数据类型            数据类型      描述      示例                  Object      键值对的集合      { name: \"John\", age: 30 }              Array      有序的值的集合      [1, 2, 3]              Function      可执行的代码块      function() { ... }              Date      日期和时间      new Date()              RegExp      正则表达式      /pattern/        同样需要注意的是  typeof 操作符可用于检查变量的基本数据类型。  instanceof 操作符可用于检查对象是否是某个构造函数的实例。  Object.prototype.toString.call() 可以返回更精确的类型字符串。      例子    // 原始数据类型let x = 42; // Numberlet y = \"hello\"; // Stringlet z = true; // Booleanlet a; // Undefinedlet b = null; // Nulllet c = Symbol(\"id\"); // Symbol// 非原始数据类型let obj = { name: \"John\", age: 30 }; // Objectlet arr = [1, 2, 3]; // Arraylet func = function () {  console.log(\"Hello\");}; // Functionlet date = new Date(); // Datelet regex = /\\d+/; // RegExplet bigNum = 9007199254740991n; // BigInt            typeof 检查数据类型    let x = 42;console.log(typeof x); // \"number\"x = \"hello\";console.log(typeof x); // \"string\"      变量声明      var:          var 是最传统的声明变量的方式。      使用 var 声明的变量具有函数作用域或全局作用域。      如果没有初始化,变量的值将为 undefined。      例如: var x = 5;            let:          let 是 ES6 (ECMAScript 2015) 引入的新语法。      let 声明的变量具有块级作用域,比 var 更加局部化。      使用 let 声明的变量可以被重新赋值,但不能被重复声明。      例如: let y = 10;            const:          const 也是 ES6 引入的新语法。      const 声明的变量是常量,其值不能被修改。      const 声明的变量必须在声明时初始化,且初始化后不能被重新赋值。      常量通常用于定义不会变化的值,如配置项。      例如: const PI = 3.14159;        var 是较旧的方式,let 和 const 是较新的方式,具有更好的作用域控制和安全性  开发中,通常建议使用 let 和 const 来声明变量,除非您有特定的需要使用 var 的场景三者区别            特性      var      let      const                  作用域      函数作用域/全局作用域      块级作用域      块级作用域              变量提升      被提升到作用域顶部,初始化为 undefined      不会被提升,使用前必须声明      不会被提升,使用前必须声明              可重复声明      允许在同一作用域内重复声明      不允许在同一作用域内重复声明      不允许在同一作用域内重复声明              可重新赋值      可以      可以      不可以              默认值      undefined      undefined      必须初始化,否则报错      从上表可以看出,let 和 const 相比 var 有以下优势:  更好的作用域控制,避免变量污染全局命名空间。  更安全的使用,避免无意中覆盖变量的问题。  const 声明常量,可以使代码更加明确和安全。运算符算术运算符            运算符      描述      示例                  +      加      5 + 3 // 结果为 8              -      减      10 - 4 // 结果为 6              *      乘      7 * 6 // 结果为 42              /      除      15 / 3 // 结果为 5              %      取余      17 % 5 // 结果为 2              ++      自增      let x = 5; x++; // x 的值变为 6              --      自减      let y = 8; y--; // y 的值变为 7      赋值运算符            运算符      描述      示例                  =      赋值      let a = 10;              +=      加赋值      let b = 5; b += 3; // b 的值变为 8              -=      减赋值      let c = 12; c -= 4; // c 的值变为 8              *=      乘赋值      let d = 6; d *= 4; // d 的值变为 24              /=      除赋值      let e = 20; e /= 5; // e 的值变为 4              %=      取余赋值      let f = 13; f %= 4; // f 的值变为 1      比较运算符            运算符      描述      示例                  &gt;      大于      7 &gt; 3 // 结果为 true              &lt;      小于      2 &lt; 9 // 结果为 true              &gt;=      大于等于      10 &gt;= 10 // 结果为 true              &lt;=      小于等于      4 &lt;= 6 // 结果为 true              ==      等于      \"5\" == 5 // 结果为 true              !=      不等于      10 != '10' // 结果为 true              ===      严格等于      5 === 5 // 结果为 true              !==      严格不等于      \"hello\" !== 'hello' // 结果为 true      逻辑运算符            运算符      描述      示例                  &amp;&amp;      逻辑与      (5 &gt; 3) &amp;&amp; (2 &lt; 4) // 结果为 true              \\|\\|      逻辑或      (7 == 7)\\|\\|(3 &gt; 5) // 结果为 true              !      逻辑非      !(4 === 4) // 结果为 false      其他运算符            运算符      描述      示例                  ?:      三元运算符      let age = 18; let canVote = age &gt;= 18 ? \"Yes\" : \"No\";              in      检查属性是否存在      let obj = { a: 1, b: 2 }; \"a\" in obj // 结果为 true              instanceof      检查对象是否是某个构造函数的实例      let arr = []; arr instanceof Array // 结果为 true              typeof      检查变量的数据类型      typeof 3.14 // 结果为 \"number\"              delete      删除对象的属性      let person = { name: \"Alice\", age: 30 }; delete person.age;      流程控制if-else 语句if (condition) {  // 如果条件为 true，执行这里的代码} else {  // 如果条件为 false，执行这里的代码}switch 语句switch (expression) {  case value1:    // 如果 expression 的值等于 value1，执行这里的代码    break;  case value2:    // 如果 expression 的值等于 value2，执行这里的代码    break;  ...  default:    // 如果 expression 的值不等于任何一个 case 的值，执行这里的代码}for 循环for (initialization; condition; increment) {  // 循环体，重复执行这里的代码}while 循环while (condition) {  // 循环体，重复执行这里的代码}do-while 循环do {  // 循环体，先执行这里的代码} while (condition);break 和 continue 语句  break 用于跳出循环  continue 用于跳过当前循环，进入下一次循环流程控制例子// 定义一个函数，用于计算给定数字的阶乘function calculateFactorial(num) {  // 使用 if-else 语句检查输入是否合法  if (num &lt; 0) {    return \"输入不能是负数\";  } else if (num === 0) {    return 1;  }  // 使用 for 循环计算阶乘  let factorial = 1;  for (let i = 1; i &lt;= num; i++) {    factorial *= i;  }  return factorial;}// 测试函数console.log(calculateFactorial(5)); // 输出: 120console.log(calculateFactorial(0)); // 输出: 1console.log(calculateFactorial(-3)); // 输出: 输入不能是负数// 使用 switch 语句判断一个数字的奇偶性function checkOddEven(num) {  switch (num % 2) {    case 0:      return `${num} 是偶数`;    case 1:      return `${num} 是奇数`;    default:      return \"输入不合法\";  }}// 测试函数console.log(checkOddEven(7)); // 输出: 7 是奇数console.log(checkOddEven(12)); // 输出: 12 是偶数console.log(checkOddEven(\"hello\")); // 输出: 输入不合法// 使用 while 循环打印 1 到 5 的数字let i = 1;while (i &lt;= 5) {  console.log(i);  i++;}// 输出:// 1// 2// 3// 4// 5// 使用 do-while 循环打印 a 到 e 的字母let letter = \"a\";do {  console.log(letter);  letter++;} while (letter &lt;= \"e\");// 输出:// a// b// c// d// e作用域（Scope）      全局作用域(Global Scope):          在代码中任何地方都能访问的作用域。      在浏览器中,全局作用域挂载在 window 对象上。在 Node.js 中,全局作用域挂载在 global 对象上。              例如:        var globalVariable = \"Hello, World!\";function globalFunction() {  console.log(globalVariable); // 可以访问全局变量}globalFunction(); // 输出 'Hello, World!'                          函数作用域(Function Scope):          在函数内部定义的变量和函数只能在该函数内部访问。              例如:        function outerFunction() {  var localVariable = \"Hello\";  function innerFunction() {    var anotherLocalVariable = \"World\";    console.log(localVariable + \", \" + anotherLocalVariable); // 可以访问函数内部的变量  }  innerFunction();}outerFunction(); // 输出 'Hello, World'console.log(localVariable); // 报错,无法访问函数内部的变量                          块级作用域(Block Scope):          在 {} 内部定义的变量和函数只能在该块内部访问。      在 ES6 引入的 let 和 const 关键字创建了块级作用域。              例如:        if (true) {  var varVariable = \"Hello\";  let letVariable = \"World\";  const constVariable = \"!\";  console.log(varVariable); // 可以访问  console.log(letVariable); // 可以访问  console.log(constVariable); // 可以访问}console.log(varVariable); // 可以访问console.log(letVariable); // 报错,无法访问console.log(constVariable); // 报错,无法访问                          模块作用域(Module Scope):          在 ES6 引入的 import 和 export 语句创建的作用域。      模块内部定义的变量和函数只能在该模块内部访问,除非通过 export 导出。              例如:        // module1.jsexport const message = \"Hello, World!\";export function sayHello() {  console.log(message);}// app.jsimport { message, sayHello } from \"./module1.js\";console.log(message); // 可以访问导出的变量sayHello(); // 可以访问导出的函数                    函数常见函数            分类      函数                  控制台函数      console.log()console.error()console.warn()console.info()console.time() / console.timeEnd()              对话框函数      alert()prompt()confirm()              定时器函数      setTimeout()setInterval()clearTimeout()clearInterval()              DOM 操作函数      document.getElementById()document.getElementsByTagName()document.getElementsByClassName()document.querySelector()document.querySelectorAll()              数学函数      Math.round()Math.ceil()Math.floor()Math.random()              数组函数      Array.push()Array.pop()Array.shift()Array.unshift()Array.slice()Array.concat()              字符串函数      String.charAt()String.concat()String.indexOf()String.replace()String.slice()String.split()String.toLowerCase()String.toUpperCase()              对象函数      Object.keys()Object.values()Object.assign()Object.freeze()Object.seal()              JSON 函数      JSON.parse()JSON.stringify()              其他常用函数      isNaN()parseInt()parseFloat()encodeURIComponent()decodeURIComponent()            例子    // 控制台函数console.log(\"Hello, world!\");console.error(\"This is an error message.\");console.warn(\"This is a warning message.\");console.info(\"This is an informational message.\");console.time(\"Timer\");// do some time-consuming operationconsole.timeEnd(\"Timer\");// 对话框函数alert(\"This is an alert dialog.\");let userInput = prompt(\"Please enter your name:\");let confirmation = confirm(\"Are you sure you want to continue?\");// 定时器函数setTimeout(function () {  console.log(\"This message will be logged after 2 seconds.\");}, 2000);setInterval(function () {  console.log(\"This message will be logged every 5 seconds.\");}, 5000);// DOM 操作函数let element = document.getElementById(\"myElement\");let elements = document.getElementsByTagName(\"p\");let classElements = document.getElementsByClassName(\"myClass\");let singleElement = document.querySelector(\"#myElement\");let allElements = document.querySelectorAll(\".myClass\");// 数学函数let rounded = Math.round(3.14);let ceilinged = Math.ceil(3.14);let floored = Math.floor(3.14);let random = Math.random();// 数组函数let myArray = [1, 2, 3];myArray.push(4);let lastElement = myArray.pop();let firstElement = myArray.shift();myArray.unshift(0);let slicedArray = myArray.slice(1, 3);let concatenatedArray = myArray.concat([5, 6, 7]);// 字符串函数let myString = \"Hello, world!\";let char = myString.charAt(0);let concatString = myString.concat(\" How are you?\");let index = myString.indexOf(\"world\");let replacedString = myString.replace(\"world\", \"JavaScript\");let slicedString = myString.slice(0, 5);let splitString = myString.split(\", \");let lowercaseString = myString.toLowerCase();let uppercaseString = myString.toUpperCase();// 对象函数let myObject = { name: \"John\", age: 30 };let keys = Object.keys(myObject);let values = Object.values(myObject);let mergedObject = Object.assign({}, myObject, { city: \"New York\" });let frozenObject = Object.freeze(myObject);let sealedObject = Object.seal(myObject);// JSON 函数let jsonString = '{\"name\":\"John\",\"age\":30}';let jsonObject = JSON.parse(jsonString);let stringifiedObject = JSON.stringify(myObject);// 其他常用函数let isNumber = isNaN(myString);let parsedInt = parseInt(\"42\");let parsedFloat = parseFloat(\"3.14\");let encodedString = encodeURIComponent(\"https://example.com?q=hello world\");let decodedString = decodeURIComponent(encodedString);      自定义函数      JavaScript 函数定义:          函数声明: function functionName(parameters) { // function body }      函数表达式: let functionName = function(parameters) { // function body }      箭头函数: let functionName = (parameters) =&gt; { // function body }            JavaScript 函数参数:          形参: 在函数定义时指定的参数      实参: 在函数调用时传递的参数      默认参数: 可以为参数指定默认值,当没有传递实参时使用默认值      不定参数: 使用 ... 语法可以创建接受任意数量参数的函数            JavaScript 函数调用:          直接调用: functionName(arguments)      方法调用: object.methodName(arguments)      构造函数调用: new FunctionName(arguments)      间接调用: 使用 call(), apply(), bind()            JavaScript 闭包:          闭包是一个函数,它可以访问其外部函数作用域中的变量。      闭包可以在函数外部访问函数内部的变量,即使外部函数已经执行完毕。      闭包的主要用途包括:                  创建私有变量和方法          实现回调函数          柯里化(Currying)                          代码例子    // 函数定义function add(a, b) {  return a + b;}let subtract = function (a, b) {  return a - b;};let multiply = (a, b) =&gt; a * b;// 函数参数function greet(name, greeting = \"Hello\") {  console.log(`${greeting}, ${name}!`);}function sum(...numbers) {  return numbers.reduce((acc, curr) =&gt; acc + curr, 0);}// 函数调用console.log(add(2, 3)); // 5console.log(subtract(5, 3)); // 2console.log(multiply(4, 6)); // 24greet(\"Alice\"); // Hello, Alice!greet(\"Bob\", \"Hi\"); // Hi, Bob!console.log(sum(1, 2, 3, 4, 5)); // 15// 闭包示例function createAdder(x) {  return function (y) {    return x + y;  };}let add5 = createAdder(5);console.log(add5(3)); // 8console.log(add5(10)); // 15      对象1. 对象字面量let person = {  name: \"John Doe\",  age: 30,  occupation: \"Software Engineer\",};2. 使用 new Object()let person = new Object();person.name = \"John Doe\";person.age = 30;person.occupation = \"Software Engineer\";3. 使用构造函数function Person(name, age, occupation) {  this.name = name;  this.age = age;  this.occupation = occupation;}let john = new Person(\"John Doe\", 30, \"Software Engineer\");      对象的属性可以使用点符号或方括号符号访问    console.log(person.name); // \"John Doe\"console.log(person[\"age\"]); // 30            方括号符号允许使用变量作为属性名,这在动态属性访问时很有用。          对象还支持一些常用的方法,如:              Object.keys(obj): 返回对象所有可枚举属性的键。      Object.values(obj): 返回对象所有可枚举属性的值。      Object.entries(obj): 返回对象所有可枚举属性的键值对数组。      obj.hasOwnProperty(key): 检查对象是否有指定的属性。            这些方法可以用于遍历和操作对象。          此外,对象也可以包含方法,即函数类型的属性:        let person = {  name: \"John Doe\",  age: 30,  occupation: \"Software Engineer\",  greet: function () {    console.log(`Hello, my name is ${this.name}.`);  },};person.greet(); // \"Hello, my name is John Doe.\"            在方法内部,this 关键字引用当前对象实例。  数组1. 数组字面量let fruits = [\"apple\", \"banana\", \"orange\"];2. 使用 new Array()let numbers = new Array(1, 2, 3, 4, 5);      数组元素可以通过索引访问和修改:    console.log(fruits[0]); // \"apple\"fruits[1] = \"pear\";console.log(fruits); // [\"apple\", \"pear\", \"orange\"]      数组提供了许多有用的方法  array.push(item): 在数组末尾添加一个或多个元素。  array.pop(): 删除并返回数组的最后一个元素。  array.shift(): 删除并返回数组的第一个元素。  array.unshift(item): 在数组开头添加一个或多个元素。  array.indexOf(item): 返回元素在数组中的第一个索引,如果不存在则返回 -1。  array.slice(start, end): 返回一个新的数组,包含从 start 到 end-1 的元素。  array.concat(item1, item2, ...): 合并两个或多个数组,返回一个新数组。  array.forEach(function(item, index, array) { ... }): 遍历数组,对每个元素执行提供的函数。数组高阶函数  此外,数组还支持许多高阶函数,如 map()、filter()、reduce()、some()、every() 等,用于对数组进行转换、过滤和聚合操作。      map():                  作用: 对数组的每个元素应用一个函数,并返回一个新数组。        let numbers = [1, 2, 3, 4, 5];let doubledNumbers = numbers.map(function (num) {  return num * 2;});console.log(doubledNumbers); // [2, 4, 6, 8, 10]                          filter():                  作用: 根据提供的条件函数,返回一个新数组,包含满足条件的元素。        let numbers = [1, 2, 3, 4, 5];let evenNumbers = numbers.filter(function (num) {  return num % 2 === 0;});console.log(evenNumbers); // [2, 4]                          reduce():                  作用: 通过迭代数组元素,将其简化为单个值。        let numbers = [1, 2, 3, 4, 5];let sum = numbers.reduce(function (accumulator, currentValue) {  return accumulator + currentValue;}, 0);console.log(sum); // 15                          some():                  作用: 如果数组中至少有一个元素满足条件函数,则返回 true。        let numbers = [1, 2, 3, 4, 5];let hasEven = numbers.some(function (num) {  return num % 2 === 0;});console.log(hasEven); // true                          every():                  作用: 如果数组中所有元素都满足条件函数,则返回 true。        let numbers = [2, 4, 6, 8, 10];let areAllEven = numbers.every(function (num) {  return num % 2 === 0;});console.log(areAllEven); // true                    数组操作完整例子// 创建一个水果数组let fruits = [\"apple\", \"banana\", \"orange\"];// 使用 push 和 pop 方法fruits.push(\"grape\");console.log(fruits); // [\"apple\", \"banana\", \"orange\", \"grape\"]let lastFruit = fruits.pop();console.log(lastFruit, fruits); // \"grape\" [\"apple\", \"banana\", \"orange\"]// 使用 shift 和 unshift 方法let firstFruit = fruits.shift();console.log(firstFruit, fruits); // \"apple\" [\"banana\", \"orange\"]fruits.unshift(\"pear\");console.log(fruits); // [\"pear\", \"banana\", \"orange\"]// 使用 indexOf 方法let bananaIndex = fruits.indexOf(\"banana\");console.log(bananaIndex); // 1// 使用 slice 方法let somefruits = fruits.slice(1, 3);console.log(somefruits); // [\"banana\", \"orange\"]// 使用 concat 方法let moreFruits = fruits.concat([\"kiwi\", \"mango\"]);console.log(moreFruits); // [\"pear\", \"banana\", \"orange\", \"kiwi\", \"mango\"]// 使用 forEach 方法fruits.forEach(function (fruit) {  console.log(\"Fruit:\", fruit);});// Fruit: pear// Fruit: banana// Fruit: orange// 使用 map 方法let uppercasedFruits = fruits.map(function (fruit) {  return fruit.toUpperCase();});console.log(uppercasedFruits); // [\"PEAR\", \"BANANA\", \"ORANGE\"]// 使用 filter 方法let shortFruits = fruits.filter(function (fruit) {  return fruit.length &lt;= 5;});console.log(shortFruits); // [\"pear\", \"banana\"]// 使用 reduce 方法let totalLetters = fruits.reduce(function (total, fruit) {  return total + fruit.length;}, 0);console.log(totalLetters); // 14// 使用 some 方法let hasLongFruit = fruits.some(function (fruit) {  return fruit.length &gt; 6;});console.log(hasLongFruit); // false// 使用 every 方法let allShortFruits = fruits.every(function (fruit) {  return fruit.length &lt;= 6;});console.log(allShortFruits); // true事件处理      事件监听器:          事件监听器是一个函数,它会在特定的事件发生时被调用。      我们可以使用 addEventListener() 方法为 DOM 元素添加事件监听器。              示例:        let button = document.getElementById(\"myButton\");button.addEventListener(\"click\", function () {  console.log(\"Button was clicked!\");});                          常见的事件类型:          click: 当用户点击元素时触发。      mouseover/mouseout: 当鼠标移入/移出元素时触发。      keydown/keyup: 当用户按下/松开键盘按键时触发。      submit: 当表单提交时触发。      load: 当页面或资源加载完成时触发。            事件对象:          事件监听器函数会接收一个事件对象作为参数。      事件对象包含了关于事件的各种信息,如事件类型、目标元素、鼠标坐标等。              示例:        button.addEventListener(\"click\", function (event) {  console.log(\"Event type:\", event.type);  console.log(\"Target element:\", event.target);});                          事件传播:          事件从目标元素开始向上”冒泡”,一直到 document 对象。      可以使用 event.stopPropagation() 方法阻止事件继续传播。              示例:        let parent = document.getElementById(\"parent\");let child = document.getElementById(\"child\");parent.addEventListener(\"click\", function (event) {  console.log(\"Parent clicked\");});child.addEventListener(\"click\", function (event) {  console.log(\"Child clicked\");  event.stopPropagation();});                          事件委托:          事件委托是一种优化事件处理的技术。      我们可以将事件处理程序附加到父元素上,而不是每个子元素。      当事件在子元素上触发时,会冒泡到父元素,父元素可以处理该事件。              示例:        let container = document.getElementById(\"container\");container.addEventListener(\"click\", function (event) {  if (event.target.tagName === \"LI\") {    console.log(\"List item clicked:\", event.target.textContent);  }});                    事件处理例子  示例将涵盖 DOM 事件处理的各个方面,包括事件监听、事件对象、事件传播和事件委托等。&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Event Handling Example&lt;/title&gt;    &lt;style&gt;      #parent {        width: 300px;        height: 300px;        background-color: #f2f2f2;        padding: 20px;      }      #child {        width: 200px;        height: 200px;        background-color: #ddd;        margin: 0 auto;        padding: 20px;      }      button {        display: block;        margin-top: 20px;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"parent\"&gt;      &lt;div id=\"child\"&gt;        &lt;p&gt;Click me or my parent!&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;button id=\"myButton\"&gt;Click me&lt;/button&gt;    &lt;input type=\"text\" id=\"myInput\" placeholder=\"Type something\" /&gt;    &lt;form id=\"myForm\"&gt;      &lt;input type=\"text\" id=\"formInput\" placeholder=\"Form input\" /&gt;      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;    &lt;/form&gt;    &lt;script&gt;      // 1. Event Listener      let button = document.getElementById(\"myButton\");      button.addEventListener(\"click\", function (event) {        console.log(\"Button clicked!\");      });      // 2. Event Object      let input = document.getElementById(\"myInput\");      input.addEventListener(\"keyup\", function (event) {        console.log(\"Key released:\", event.key);      });      // 3. Event Propagation      let parent = document.getElementById(\"parent\");      let child = document.getElementById(\"child\");      parent.addEventListener(\"click\", function (event) {        console.log(\"Parent clicked\");      });      child.addEventListener(\"click\", function (event) {        console.log(\"Child clicked\");        event.stopPropagation(); // 阻止事件冒泡      });      // 4. Event Delegation      let container = document.getElementById(\"parent\");      container.addEventListener(\"click\", function (event) {        if (event.target.tagName === \"P\") {          console.log(\"Paragraph clicked:\", event.target.textContent);        }      });      // 5. Form Submission      let form = document.getElementById(\"myForm\");      form.addEventListener(\"submit\", function (event) {        event.preventDefault(); // 阻止表单默认提交行为        let formInput = document.getElementById(\"formInput\");        console.log(\"Form submitted:\", formInput.value);      });    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;      解释          事件监听器: 为按钮添加一个 click 事件监听器。      事件对象: 监听输入框的 keyup 事件,并使用事件对象获取按下的键。      事件传播: 监听父元素和子元素的 click 事件,并使用 stopPropagation() 阻止事件冒泡。      事件委托: 将点击处理程序添加到父元素上,当点击子元素时,事件会冒泡到父元素并被处理。      表单提交: 监听表单的 submit 事件,并使用 preventDefault() 阻止表单的默认提交行为。      报错  JavaScript 中,当出现问题时,会抛出错误。错误可能是由于代码逻辑错误、无效输入、资源不可用等原因引起的。      错误类型:          SyntaxError: 代码语法错误。      ReferenceError: 尝试访问不存在的变量。      TypeError: 对不正确类型的操作。      RangeError: 数值超出有效范围。      URIError: 使用不正确的编码或解码 URI 组件。      EvalError: eval() 函数使用不当。            错误处理:                  try-catch 语句:                  使用 try 块包裹可能会抛出错误的代码。          使用 catch 块捕获并处理抛出的错误。                      示例:            try {  // 可能会抛出错误的代码  let result = parseInt(\"abc\");} catch (error) {  console.error(\"Error occurred:\", error.message);}                                                  错误对象:                  捕获的错误对象包含有关错误的信息,如错误类型、错误消息和堆栈追踪。          可以使用 error.message、error.name 和 error.stack 属性访问错误信息。                          自定义错误:          可以使用 throw 语句抛出自定义错误。      自定义错误通常是 Error 对象的实例或者继承自 Error 的自定义错误类。              示例:        class InvalidInputError extends Error {  constructor(message) {    super(message);    this.name = \"InvalidInputError\";  }}function validateInput(input) {  if (input === \"\") {    throw new InvalidInputError(\"Input cannot be empty\");  }  // 其他验证逻辑}try {  validateInput(\"\");} catch (error) {  if (error instanceof InvalidInputError) {    console.error(error.message);  } else {    console.error(\"An unexpected error occurred\");  }}                          错误处理最佳实践:          始终使用 try-catch 块包裹可能抛出错误的代码。      在 catch 块中,根据错误类型提供适当的错误处理。      记录并显示有意义的错误信息,以便于调试和错误排查。      对于严重错误,可以考虑向用户显示友好的错误消息。      在生产环境中,可以使用全局错误处理机制捕获未处理的错误。      调试      浏览器开发者工具:          所有主流浏览器都提供了强大的开发者工具,如 Chrome 的 DevTools、Firefox 的 Developer Tools 和 Edge 的 F12 开发者工具。      这些工具提供了丰富的调试功能,包括断点调试、变量检查、网络监控、性能分析等。      使用这些工具可以帮助您快速定位和解决代码中的问题。            断点调试:          在代码中设置断点,可以在执行到该点时暂停程序的运行。      这样您就可以检查变量的值、观察执行流程,并逐步执行代码以找出问题所在。      大多数浏览器开发者工具都支持断点调试功能。            console 对象:          console 对象提供了各种调试和记录输出的方法,如 console.log()、console.error()、console.warn() 等。      通过在代码中添加 console.log() 语句,可以输出变量值、对象属性等信息,帮助您跟踪程序的执行过程。            Source Map:          当使用 JavaScript 构建工具(如 Webpack、Rollup 等)时,生成的 JavaScript 文件通常会被压缩/转换,使得调试变得困难。      Source Map 是一种映射关系,可以将压缩后的 JavaScript 代码与源代码进行关联,在开发者工具中显示原始的源代码。      使用 Source Map 可以大大提高调试体验。            debugger 关键字:          debugger 关键字可以在代码中设置一个断点,类似于在开发者工具中手动设置断点。      当程序执行到 debugger 语句时,它会自动暂停并进入调试模式。            异步调试:          调试异步代码(如 Promise、async/await)可能会更加复杂。      使用 async/await 配合断点调试可以帮助您更好地理解异步代码的执行过程。      一些调试工具,如 Chrome DevTools 的 “Pause on uncaught exceptions” 选项,也可以帮助您捕获异步代码中的错误。            日志记录和错误报告:          在生产环境中,使用日志记录工具(如 console.error())记录错误信息和堆栈追踪。      可以结合错误报告服务(如 Sentry、Rollbar 等)自动收集和分析应用程序中的错误,以便快速修复问题。            单元测试:          编写全面的单元测试可以帮助您提前发现并修复代码中的问题。      单元测试还可以作为一种回归测试,确保代码修改不会破坏原有的功能。      进阶异步  async 函数是 ECMAScript 2017 (ES8) 引入的一个特性,它允许我们使用同步编程的方式来编写异步代码。它的主要目的是简化异步代码的编写和读取,同时提供更好的错误处理机制。      下面是一个基本的 async 函数示例:    async function fetchData() {  try {    const response = await fetch(\"https://api.example.com/data\");    const data = await response.json();    console.log(\"Data:\", data);  } catch (error) {    console.error(\"Error:\", error.message);  }}fetchData();            解释          async 关键字标识 fetchData() 函数为异步函数。      在函数内部,await 关键字用于等待异步操作的结果,如 fetch() 调用和 response.json() 解析。      任何 await 表达式都会暂停函数的执行,直到相应的 Promise 被解决。      如果发生错误,try/catch 块会捕获并处理异常。            使用 async/await 的优势包括:          简化异步代码: 相比使用回调函数或 Promise 链,async/await 提供了一种更加同步和线性的编码方式,使代码更加易读和维护。      错误处理: try/catch 块可以优雅地处理异步操作中的错误,避免了嵌套回调函数或 Promise 链中的错误处理问题。      并发控制: 您可以在 async 函数内部并行执行多个异步操作,并使用 Promise.all() 等方法来协调它们的执行。      composition: async 函数可以被其他 async 函数调用,形成一个嵌套的异步操作流程。        需要注意的是,async 函数本身会返回一个 Promise。这意味着您可以在外部使用 .then() 和 .catch() 方法来处理 async 函数的结果和错误。fetchData()  .then(() =&gt; console.log(\"Data fetched successfully\"))  .catch((error) =&gt; console.error(\"Error:\", error.message));  总的来说,async/await 是 JavaScript 异步编程的一个重要工具,它简化了代码,提高了可读性和可维护性。通过结合使用 async 函数、Promise 和错误处理,您可以编写出更加优雅和健壮的异步代码类类基础  在 JavaScript 中,类是一种创建对象的蓝图或模板。它定义了对象应该具有的属性(数据)和方法(行为)。      Person 类开始    class Person {  // 构造函数  constructor(name, age) {    this.name = name;    this.age = age;  }  // 实例方法  greet() {    console.log(      `Hello, my name is ${this.name} and I'm ${this.age} years old.`    );  }}                      解释                  class Person 定义了一个名为 Person 的类。          constructor 是一种特殊的方法,用于初始化新创建的 Person 对象。它接受 name 和 age 参数,并将它们分别赋值给对象的 name 和 age 属性。          greet 是一个实例方法,它定义了 Person 对象可以执行的行为。当调用 greet() 时,它会打印出一个 greeting 消息。                          要创建 Person 类的实例(对象),可以使用 new 关键字:    const john = new Person(\"John\", 30);john.greet(); // 输出: Hello, my name is John and I'm 30 years old.                      解释                  new Person('John', 30) 创建了一个新的 Person 对象,并将其存储在变量 john 中。          调用 john.greet() 会执行 Person 类中定义的 greet 方法,输出 greeting 消息。                          类还支持继承,这意味着您可以创建一个新的类,并从现有的类中继承属性和方法    class Student extends Person {  constructor(name, age, grade) {    super(name, age); // 调用父类的构造函数    this.grade = grade;  }  study() {    console.log(`${this.name} is studying for grade ${this.grade}.`);  }}const alice = new Student(\"Alice\", 15, 10);alice.greet(); // 输出: Hello, my name is Alice and I'm 15 years old.alice.study(); // 输出: Alice is studying for grade 10.            解释          Student 类继承自 Person 类,使用 extends 关键字。      constructor 方法调用 super(name, age) 来初始化从父类 Person 继承的 name 和 age 属性。      Student 类新增了 grade 属性和 study 方法。      创建 Student 类的实例 alice，可以访问从 Person 继承的 greet 方法以及自己的 study 方法。      类的进阶      静态方法和属性          类中除了实例方法和属性,还可以定义静态方法和属性。静态成员属于类本身,而不是类的实例。        class Math {  static PI = 3.14159;  static add(a, b) {    return a + b;  }}console.log(Math.PI); // 3.14159console.log(Math.add(2, 3)); // 5              在这个例子中,PI 是一个静态属性,add 是一个静态方法。它们可以直接通过类名 Math 来访问,而不需要创建类的实例。            访问控制          JavaScript 类支持基本的访问控制修饰符,包括 public(默认)、private 和 protected        class BankAccount {  #balance = 0; // 私有属性  deposit(amount) {    this.#balance += amount; // 可以访问私有属性  }  getBalance() {    return this.#balance;  }}const account = new BankAccount();account.deposit(1000);console.log(account.getBalance()); // 1000console.log(account.#balance); // Error: Private field '#balance' must be declared in an enclosing class              在这个例子中,#balance 是一个私有属性,只能在类的内部访问。deposit 方法可以修改私有属性,而 getBalance 方法可以读取私有属性的值。            Getter 和 Setter          您可以在类中定义 getter 和 setter 方法,用于控制对属性的访问和赋值        class Person {  constructor(name) {    this._name = name;  }  get name() {    return this._name;  }  set name(newName) {    this._name = newName;  }}const john = new Person(\"John\");console.log(john.name); // 输出: Johnjohn.name = \"Jane\";console.log(john.name); // 输出: Jane              在这个例子中,name 属性有一个 getter 和 setter 方法。当读取 name 属性时,会调用 getter 方法返回 _name 的值。当设置 name 属性时,会调用 setter 方法更新 _name 的值            抽象类和接口          JavaScript 不支持原生的抽象类和接口,但可以通过约定和设计模式来实现类似的功能。例如,您可以定义一个抽象基类,并要求子类实现特定的方法。        class AbstractShape {  constructor(color) {    this.color = color;  }  // 抽象方法,子类必须实现  getArea() {    throw new Error(\"getArea() must be implemented in subclass.\");  }}class Circle extends AbstractShape {  constructor(color, radius) {    super(color);    this.radius = radius;  }  getArea() {    return Math.PI * this.radius ** 2;  }}const circle = new Circle(\"red\", 5);console.log(circle.getArea()); // 78.53981633974483              在这个例子中,AbstractShape 类定义了一个抽象的 getArea 方法,要求子类必须实现该方法。Circle 类继承自 AbstractShape 并提供了 getArea 的具体实现。      类的完整例子// 1. 静态方法和属性class MathUtils {  static PI = 3.14159;  static add(a, b) {    return a + b;  }  static subtract(a, b) {    return a - b;  }}console.log(MathUtils.PI); // 3.14159console.log(MathUtils.add(2, 3)); // 5console.log(MathUtils.subtract(5, 3)); // 2// 2. 访问控制 - 私有属性和方法class BankAccount {  #balance = 0; // 私有属性  #transactionHistory = []; // 私有属性  deposit(amount) {    this.#balance += amount;    this.#recordTransaction(\"deposit\", amount);  }  withdraw(amount) {    if (amount &lt;= this.#balance) {      this.#balance -= amount;      this.#recordTransaction(\"withdrawal\", amount);    } else {      console.log(\"Insufficient funds.\");    }  }  getBalance() {    return this.#balance;  }  #recordTransaction(type, amount) {    // 私有方法    this.#transactionHistory.push({ type, amount });  }}const account = new BankAccount();account.deposit(1000);account.withdraw(500);console.log(account.getBalance()); // 500// console.log(account.#balance); // Error: Private field '#balance' must be declared in an enclosing class// 3. Getter 和 Setterclass Person {  constructor(firstName, lastName) {    this._firstName = firstName;    this._lastName = lastName;  }  get fullName() {    return `${this._firstName} ${this._lastName}`;  }  set fullName(name) {    [this._firstName, this._lastName] = name.split(\" \");  }}const john = new Person(\"John\", \"Doe\");console.log(john.fullName); // 输出: John Doejohn.fullName = \"Jane Smith\";console.log(john.fullName); // 输出: Jane Smith// 4. 继承和多态class Animal {  constructor(name) {    this.name = name;  }  makeSound() {    console.log(\"The animal makes a sound.\");  }}class Dog extends Animal {  constructor(name) {    super(name);  }  makeSound() {    console.log(`${this.name} barks.`);  }}class Cat extends Animal {  constructor(name) {    super(name);  }  makeSound() {    console.log(`${this.name} meows.`);  }}const dog = new Dog(\"Buddy\");const cat = new Cat(\"Whiskers\");dog.makeSound(); // 输出: Buddy barks.cat.makeSound(); // 输出: Whiskers meows.      静态方法和属性:          MathUtils 类包含一个静态属性 PI 和两个静态方法 add 和 subtract。      静态成员属于类本身,可以直接通过类名访问,而不需要创建类的实例。            访问控制 - 私有属性和方法:          BankAccount 类包含两个私有属性 #balance 和 #transactionHistory。      类内部的 deposit、withdraw 和 #recordTransaction 方法可以访问这些私有属性。      通过 getBalance 方法可以读取 #balance 的值,但不能直接访问它。      私有属性和方法以 # 开头,只能在类内部访问。            Getter 和 Setter:          Person 类包含 _firstName 和 _lastName 作为私有属性。      fullName 属性是一个 getter 和 setter 方法,用于获取和设置全名。      当读取 fullName 时,会返回拼接后的全名。当设置 fullName 时,会更新 _firstName 和 _lastName。            继承和多态:          Animal 是父类,包含 name 属性和 makeSound 方法。      Dog 和 Cat 是 Animal 的子类,都重写了 makeSound 方法,实现了多态。      在创建 Dog 和 Cat 实例时,调用 makeSound 方法会根据对象的实际类型执行不同的行为。        通过这个例子,您可以看到 JavaScript 类的各种高级特性,包括静态方法和属性、访问控制、getter/setter 以及继承和多态。这些特性可以帮助您创建更加灵活、可扩展和可维护的代码JavaScript Work异步编程      回调函数:          回调函数是作为参数传递给另一个函数的函数      当某个事件发生或某个操作完成时,这个函数就会被调用      使用回调函数是 JavaScript 中实现异步编程的传统方式      回调函数可能会导致”回调地狱”的问题,代码嵌套层次过深            Promise 和 async/await:          Promise 是 JavaScript 中用于处理异步操作的一种语法糖      Promise 有三种状态:pending、fulfilled 和 rejected      Promise 提供了更优雅的异步编程方式,避免了回调地狱      async 函数返回一个 Promise,await 关键字用于等待 Promise 完成      async/await 使得异步代码看起来更加同步和易读            事件循环和事件队列:          JavaScript 是单线程语言,使用事件循环机制来处理异步操作      事件循环包括:栈、队列(任务队列)、微任务队列和 Web APIs      同步任务进入栈,异步任务进入任务队列或微任务队列      事件循环不断检查栈是否为空,然后执行队列中的任务      微任务队列中的任务优先于任务队列中的任务执行        定时器(setTimeout、setInterval):          setTimeout() 函数用于在指定延迟后执行回调函数      setInterval() 函数用于每隔指定时间就执行回调函数      定时器不会阻塞主线程,而是由浏览器的 Web API 处理      定时器的实际执行时间可能会晚于设定的时间      可以使用 clearTimeout()和 clearInterval() 取消定时器            完整例子    // 回调函数function fetchData(callback) {  // 模拟异步操作  setTimeout(() =&gt; {    const data = { name: \"John Doe\", age: 30 };    callback(data);  }, 2000);}fetchData((data) =&gt; {  console.log(\"Callback data:\", data);});// Promisefunction fetchDataPromise() {  return new Promise((resolve, reject) =&gt; {    // 模拟异步操作    setTimeout(() =&gt; {      const data = { name: \"Jane Smith\", age: 25 };      resolve(data);    }, 3000);  });}fetchDataPromise()  .then((data) =&gt; {    console.log(\"Promise data:\", data);  })  .catch((error) =&gt; {    console.error(\"Promise error:\", error);  });// async/awaitasync function fetchDataAsync() {  try {    const data = await fetchDataPromise();    console.log(\"Async/await data:\", data);  } catch (error) {    console.error(\"Async/await error:\", error);  }}fetchDataAsync();// 事件循环和事件队列console.log(\"Start\");setTimeout(() =&gt; {  console.log(\"Timeout callback\");}, 0);Promise.resolve(\"Promise resolved\").then((data) =&gt; {  console.log(\"Microtask:\", data);});console.log(\"End\");// 定时器console.log(\"Start\");setTimeout(() =&gt; {  console.log(\"Timeout 1 callback\");}, 2000);setTimeout(() =&gt; {  console.log(\"Timeout 2 callback\");}, 0);console.log(\"End\");                      解释                  使用回调函数处理异步操作。          使用 Promise 和 async/await 的方式处理异步操作。          演示了事件循环和事件队列的运行机制。          展示了使用 setTimeout() 和 setInterval() 实现的定时器。                    模块化      ES6 模块系统 (import/export):          ES6 引入了原生的模块化系统,使用 import 和 export 关键字      export 用于导出模块中的变量、函数、类等      import 用于导入其他模块中导出的内容      ES6 模块是静态的,在编译时确定依赖关系      ES6 模块支持命名导出、默认导出等多种导出方式            CommonJS 模块 (require/exports):          CommonJS 是 Node.js 中使用的模块化规范      使用 require() 函数导入模块,exports 对象导出模块      CommonJS 模块是动态的,在运行时确定依赖关系      CommonJS 模块系统广泛应用于 Node.js 生态圈            模块打包工具 (Webpack、Rollup 等):          Webpack 和 Rollup 是常见的 JavaScript 模块打包工具      它们可以将多个模块打包成一个或多个文件,优化代码      Webpack 支持多种模块化规范(ES6、CommonJS、AMD 等)      Rollup 主要优化 ES6 模块,生成更小更高效的 bundle      这些工具还提供许多其他功能,如代码分割、热更新等      这三个知识点涵盖了 JavaScript 模块化的核心内容:  ES6 模块系统使用 import 和 export 进行模块化,是原生的模块化方案。  CommonJS 模块系统使用 require() 和 exports 对象进行模块化,广泛用于 Node.js。  Webpack 和 Rollup 等模块打包工具可以将多个模块打包成一个或多个文件,优化代码。模块化例子      math.js    // 导出函数export function add(a, b) {  return a + b;}export function subtract(a, b) {  return a - b;}// 默认导出export default function multiply(a, b) {  return a * b;}            utils.js（CommonJS 模块）    // 导出对象exports.capitalize = function (str) {  return str.charAt(0).toUpperCase() + str.slice(1);};exports.reverse = function (str) {  return str.split(\"\").reverse().join(\"\");};            使用 Webpack 将这些模块打包                  安装 Webpack 和必要的依赖:        npm install --save-dev webpack webpack-cli                            创建 Webpack 配置文件 webpack.config.js:        module.exports = {  entry: \"./index.js\",  output: {    filename: \"bundle.js\",    path: __dirname + \"/dist\",  },};                            创建 index.js 文件,导入并使用这些模块:        // 导入 ES6 模块import multiply, { add, subtract } from \"./math\";// 导入 CommonJS 模块const { capitalize, reverse } = require(\"./utils\");console.log(add(2, 3)); // 输出: 5console.log(subtract(5, 3)); // 输出: 2console.log(multiply(4, 5)); // 输出: 20console.log(capitalize(\"hello\")); // 输出: Helloconsole.log(reverse(\"world\")); // 输出: dlrow                            运行 Webpack 打包:        npx webpack                            完成以上步骤后,Webpack 会将 index.js 中导入的所有模块打包成一个 bundle.js 文件,放在 dist 文件夹中。            解释          使用 ES6 模块系统导入导出函数。      使用 CommonJS 模块系统导入导出对象。      使用 Webpack 将这些模块打包成一个 bundle 文件。      Web API 和浏览器环境  浏览器 API(Fetch API、Web Storage API、Canvas API 等)  事件处理(鼠标、键盘、滚动等事件)  浏览器存储(Cookie、Web Storage)  网络请求(Ajax、Fetch)现代 JavaScript 特性  ES6+(let/const、模板字面量、解构赋值等)  类(class 关键字)  模块(import/export)  承诺(Promise)  异步/等待(async/await)  箭头函数  扩展运算符和 rest 参数Web 应用开发  前端框架和库(React、Vue.js、Angular)  状态管理(Redux、Vuex)  路由管理  构建工具(Webpack、Gulp、Rollup)  测试框架(Jest、Enzyme、Cypress)其他高级主题  函数式编程  元编程(Proxy、Reflect)  装饰器  Web Workers  服务器端 JavaScript(Node.js)"
  },
  
  {
    "title": "Web JavaScript Base",
    "url": "/posts/web-javascript-base/",
    "categories": "Language, Web",
    "tags": "Web, Javascript",
    "date": "2018-12-01 11:10:12 +0800",
    





    
    "snippet": "什么是 JavaScript  JavaScript 是一种高级编程语言,主要用于 Web 开发领域。它是一种动态类型、解释型的脚本语言,广泛应用于前端 Web 开发、服务端开发、移动开发、游戏开发等多个领域。JavaScript 的主要特点包括  基于原型的面向对象编程: JavaScript 是基于原型继承的面向对象语言,与基于类的面向对象语言如 Java 和 C++ 有所不同。  动态...",
    "content": "什么是 JavaScript  JavaScript 是一种高级编程语言,主要用于 Web 开发领域。它是一种动态类型、解释型的脚本语言,广泛应用于前端 Web 开发、服务端开发、移动开发、游戏开发等多个领域。JavaScript 的主要特点包括  基于原型的面向对象编程: JavaScript 是基于原型继承的面向对象语言,与基于类的面向对象语言如 Java 和 C++ 有所不同。  动态类型: JavaScript 是一种动态类型语言,变量可以保存任意类型的数据,无需事先声明变量的类型。  事件驱动: JavaScript 可以用来定义事件处理程序,从而实现事件驱动的程序设计。  函数式编程: JavaScript 支持函数式编程范式,函数是一等公民,可以作为参数传递、赋值给变量等。  异步编程: JavaScript 通过回调函数、Promises 和 Async/Await 等机制支持异步编程模型。  浏览器端脚本语言: JavaScript 最初是作为客户端脚本语言使用,用于增强网页的交互性和动态性。  跨平台性: JavaScript 可以运行在各种环境中,如浏览器、Node.js 服务器、移动端等。JavaScript 与 ECMAScript (ES)      关系:          JavaScript 是 ECMAScript 的一种实现和扩展。ECMAScript 是一种语言规范,而 JavaScript 是符合这种规范的一种编程语言实现。            历史:          ECMAScript 由 Ecma International 制定和维护,最早的版本是 ES1,发布于 1997 年。      JavaScript 最初由 Netscape 公司的 Brendan Eich 开发,于 1995 年首次发布。            版本:          ECMAScript 有多个版本,从 ES1 到最新的 ES13。JavaScript 也会随着 ECMAScript 标准的更新而不断发展。      常见的 ECMAScript 版本包括 ES5、ES6(ES2015)、ES7(ES2016)、ES8(ES2017)等。            特点:          ECMAScript 只定义语法规范,而 JavaScript 则是一种基于 ECMAScript 规范的完整的编程语言实现。      JavaScript 在 ECMAScript 规范之上增加了一些浏览器相关的 API,如 DOM、BOM 等。        ECMAScript 是一种语言标准或规范,JavaScript 是符合这种标准的一种编程语言实现。  JavaScript 在 ECMAScript 的基础上增加了丰富的 Web 浏览器相关功能,使其成为一种功能更加强大的编程语言。  随着 ECMAScript 标准的不断更新,JavaScript 也在不断发展和完善。开发者需要关注 ECMAScript 的最新版本,以使用 JavaScript 的新特性。在 HTML 中用法      内联 JavaScript:          可以将 JavaScript 代码直接写在 HTML 标签的 onclick、onmouseover 等事件属性中。      例如: &lt;button onclick=\"alert('Hello, world!')\"&gt;Click me&lt;/button&gt;            嵌入式 JavaScript:                  将 JavaScript 代码写在 &lt;script&gt; 标签中,放置在 HTML 文档的 &lt;head&gt; 或 &lt;body&gt; 部分        &lt;script&gt;  console.log(\"This is a JavaScript code block.\");&lt;/script&gt;                          外部 JavaScript 文件:                  将 JavaScript 代码写在独立的 .js 文件中,并使用 &lt;script&gt; 标签引入        &lt;script src=\"my-script.js\"&gt;&lt;/script&gt;                          DOM 操作:                  可以使用 JavaScript 选择和操作 HTML 元素。        &lt;p id=\"message\"&gt;Hello&lt;/p&gt;&lt;script&gt;  document.getElementById(\"message\").textContent = \"Hello, world!\";&lt;/script&gt;                          事件处理:                  可以为 HTML 元素绑定事件处理函数,实现交互效果。        &lt;button onclick=\"showAlert()\"&gt;Click me&lt;/button&gt;&lt;script&gt;  function showAlert() {    alert(\"Button clicked!\");  }&lt;/script&gt;                          例子    &lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Comprehensive JavaScript Example&lt;/title&gt;    &lt;script&gt;      // 内联 JavaScript      function showAlert() {        alert(\"This is an alert!\");      }    &lt;/script&gt;    &lt;style&gt;      .box {        width: 200px;        height: 200px;        background-color: #007bff;        margin: 50px auto;        transition: transform 0.5s;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Welcome to the Comprehensive JavaScript Example&lt;/h1&gt;    &lt;!-- 内联 JavaScript --&gt;    &lt;button onclick=\"showAlert()\"&gt;Click me for an alert&lt;/button&gt;    &lt;!-- 嵌入式 JavaScript --&gt;    &lt;script&gt;      console.log(\"This is a JavaScript code block.\");    &lt;/script&gt;    &lt;div id=\"myBox\" class=\"box\"&gt;&lt;/div&gt;    &lt;!-- 外部 JavaScript 文件 --&gt;    &lt;script src=\"script.js\"&gt;&lt;/script&gt;    &lt;!-- DOM 操作 --&gt;    &lt;p id=\"message\"&gt;Hello&lt;/p&gt;    &lt;button onclick=\"changeMessage()\"&gt;Change Message&lt;/button&gt;    &lt;!-- 事件处理 --&gt;    &lt;input      type=\"text\"      id=\"input\"      onkeyup=\"displayInput()\"      placeholder=\"Type something...\"    /&gt;    &lt;p id=\"inputDisplay\"&gt;&lt;/p&gt;  &lt;/body&gt;  &lt;script&gt;    // DOM 操作    function changeMessage() {      document.getElementById(\"message\").textContent = \"Hello, world!\";    }    // 事件处理    function displayInput() {      const inputValue = document.getElementById(\"input\").value;      document.getElementById(        \"inputDisplay\"      ).textContent = `You typed: ${inputValue}`;    }  &lt;/script&gt;&lt;/html&gt;            解释          内联 JavaScript: 在 &lt;button&gt; 元素的 onclick 属性中直接调用 showAlert() 函数      嵌入式 JavaScript: 在 &lt;script&gt; 标签中编写 JavaScript 代码块      外部 JavaScript 文件: 引入一个名为 script.js 的外部 JavaScript 文件      DOM 操作: 选择 id 为 message 的 &lt;p&gt; 元素,并修改其文本内容      事件处理: 为 id 为 input 的 &lt;input&gt; 元素绑定 keyup 事件,并在事件触发时调用 displayInput() 函数      "
  },
  
  {
    "title": "Web CSS",
    "url": "/posts/web-css/",
    "categories": "Language, Web",
    "tags": "Web, CSS",
    "date": "2018-12-01 11:10:11 +0800",
    





    
    "snippet": "CSS 简介什么是  CSS (Cascading Style Sheets) 是一种用于描述网页外观和格式的标记语言  样式控制:CSS 可以定义文本的字体、大小、颜色,图像的尺寸和位置等网页元素的样式  页面布局:CSS 可以控制网页元素的位置、大小、对齐方式等,从而实现复杂的页面布局  响应式设计:CSS 提供了媒体查询的功能,可以根据不同设备的屏幕尺寸和分辨率来自动调整页面样式,实现...",
    "content": "CSS 简介什么是  CSS (Cascading Style Sheets) 是一种用于描述网页外观和格式的标记语言  样式控制:CSS 可以定义文本的字体、大小、颜色,图像的尺寸和位置等网页元素的样式  页面布局:CSS 可以控制网页元素的位置、大小、对齐方式等,从而实现复杂的页面布局  响应式设计:CSS 提供了媒体查询的功能,可以根据不同设备的屏幕尺寸和分辨率来自动调整页面样式,实现响应式设计  性能优化:使用 CSS 可以将样式信息与内容分离,减少 HTML 文件的大小,提高网页加载性能CSS 与 CSS3 区别      版本更新:          CSS 是最初的版本,于 1996 年发布。      CSS3 是 CSS 规范的更新版本,于 2011 年发布。CSS3 在 CSS 的基础上引入了更多新特性。            新增功能:          CSS 相对来说功能较为简单和基础。      CSS3 添加了许多新的属性和功能,如圆角、阴影、渐变、动画、多列布局等。            浏览器支持:          CSS 相对来说有更好的浏览器兼容性。      CSS3 的新特性并非所有浏览器都完全支持,需要根据具体特性查看兼容性。            模块化设计:          CSS 的设计较为单一,没有模块化的概念。      CSS3 采用了模块化的设计方式,将规范分成了多个独立的模块。            性能和效率:          CSS 相对来说更加简洁和高效。      CSS3 提供了更丰富的样式控制手段,可以实现更复杂的视觉效果。      语法      选择器(Selector)          选择器用于选择需要应用样式的 HTML 元素。      常见的选择器类型包括元素选择器、类选择器、ID 选择器、属性选择器等。      选择器可以单独使用,也可以组合使用,如 h1, h2, p {color: red;}            声明块(Declaration Block)          声明块包含一个或多个样式声明(declaration)。      每条样式声明由属性(property)和值(value)组成,用冒号(:)分隔。      声明块用大括号{}包裹。            属性(Property)          属性描述了元素的样式特征,如字体、颜色、大小、位置等。      CSS 提供了大量的属性供开发者使用。            值(Value)          值是属性的具体设置,如颜色值、长度值、关键字等。      值与属性之间用冒号(:)分隔。      CSS 选择器1. 外部 CSS  外部 CSS 是将样式代码保存在单独的 CSS 文件中,然后在 HTML 文件中通过 &lt;link&gt; 标签引入。这种方式可以实现样式和内容的分离,利于代码的复用和维护。&lt;head&gt;  &lt;link rel=\"stylesheet\" href=\"styles.css\" /&gt;&lt;/head&gt;2. 内部 CSS  内部 CSS 是将样式代码直接嵌入到 HTML 文件的 &lt;style&gt; 标签中。这种方式适用于需要快速编辑样式或只在当前页面使用的情况。&lt;style&gt;  h1 {    color: blue;  }  p {    font-size: 16px;  }&lt;/style&gt;3. 行内 CSS  行内 CSS 是将样式直接写在 HTML 元素的 style 属性中。这种方式优先级最高,但不利于代码的维护和复用。&lt;h1 style=\"color: blue; font-size: 24px;\"&gt;Hello, World!&lt;/h1&gt;4. 多个样式表  在实际开发中,我们通常会使用多个样式表,比如一个全局样式表、一个布局样式表、一个组件样式表等。这样可以更好地组织和管理样式代码。&lt;head&gt;  &lt;link rel=\"stylesheet\" href=\"global.css\" /&gt;  &lt;link rel=\"stylesheet\" href=\"layout.css\" /&gt;  &lt;link rel=\"stylesheet\" href=\"components.css\" /&gt;&lt;/head&gt;5. CSS 选择器  CSS 选择器用于选择需要应用样式的 HTML 元素。常见的选择器类型包括:  元素选择器: h1, p, div  类选择器: .my-class  ID 选择器: #my-id  属性选择器: [type=\"text\"], [href^=\"https://\"]  组合选择器: h1, h2, p, div p, div &gt; p/* 元素选择器 */h1 {  color: blue;}/* 类选择器 */.my-class {  font-size: 16px;}/* ID 选择器 */#my-id {  position: absolute;}/* 属性选择器 */[type=\"text\"] {  border: 1px solid #ccc;}/* 组合选择器 */h1,h2,p {  margin-bottom: 10px;}函数            函数分类      描述                  颜色函数      用于定义颜色和调整颜色              尺寸函数      用于计算长度值              变换函数      进行位移、缩放、旋转、倾斜等变换              渐变函数      生成线性渐变、径向渐变、锥形渐变              资源函数      用于引入外部资源              属性函数      用于获取元素属性值              变量函数      用于引用 CSS 自定义属性(变量)      颜色函数            颜色函数      描述                  rgb()rgba()      使用红绿蓝三原色定义颜色,rgba() 还可以设置透明度              hsl()hsla()      使用色相、饱和度、亮度定义颜色,hsla() 还可以设置透明度              lighten()darken()      调整颜色的亮度              saturate()desaturate()      调整颜色的饱和度              opacify()transparentize()      调整颜色的透明度      color: rgb(255, 0, 0); /* 纯红色 */background-color: rgba(0, 0, 255, 0.5); /* 半透明蓝色 */color: hsl(120, 100%, 50%); /* 纯绿色 */color: lighten(#333, 20%); /* 浅一些的灰色 */background-color: saturate(#ccc, 50%); /* 更饱和的灰色 */尺寸函数            尺寸函数      描述                  calc()      用于计算长度值,可以混合使用不同的长度单位进行运算      calc() 函数允许我们在 CSS 中使用表达式来动态计算长度值,这为创建更灵活的布局提供了可能。width: calc(100% - 20px); /* 宽度为容器宽度减去 20px */height: calc(50vh - 2em); /* 高度为视口高度的 50% 减去 2em */margin: calc(10% + 5px) auto; /* 上下边距为 10% 加 5px，左右边距居中 */  使用 calc() 函数,我们可以根据页面上下文动态计算元素的尺寸,而不需要提前确定固定的值。这对于响应式设计和自适应布局非常有帮助。变换函数            变换函数      描述                  translate()translateX()translateY()      进行位移变换              scale()scaleX()scaleY()      进行缩放变换              rotate()      进行旋转变换              skew()skewX()skewY()      进行倾斜变换      这些变换函数可以用于对元素进行各种形变操作,包括位移、缩放、旋转和倾斜。例如:/* 向右平移 50px，向下平移 30px */transform: translate(50px, 30px);/* 沿 X 轴缩放 1.5 倍 */transform: scaleX(1.5);/* 顺时针旋转 45 度 */transform: rotate(45deg);/* 沿 X 轴倾斜 30 度 */transform: skewX(30deg);这些变换函数可以单独使用,也可以组合使用来实现更复杂的变换效果。变换函数通常会和 transform-origin 属性一起使用,以控制变换的基准点。渐变函数            渐变函数      描述                  linear-gradient()      创建线性渐变              radial-gradient()      创建径向渐变              conic-gradient()      创建锥形渐变            linear-gradient():          定义从一个点到另一个点的渐变      可以指定渐变方向、起始点、终点、颜色节点等      示例: background-image: linear-gradient(to right, red, yellow, green);            radial-gradient():          定义从一个中心点向四周辐射的渐变      可以指定渐变形状、大小、起始点、颜色节点等      示例: background-image: radial-gradient(circle, blue, white);            conic-gradient():          定义从一个中心点围绕 360 度绘制的锥形渐变      可以指定渐变起始角度、颜色节点等      示例: background-image: conic-gradient(from 90deg, red, yellow, green);      这些渐变函数可以用来创建丰富多彩的背景,增加网页的视觉吸引力。渐变也可以用作遮罩、边框等的样式。资源函数            资源函数      描述                  url()      用于引入外部资源,如图片、字体等              image()      用于引入可缩放的图像资源              cross-fade()      用于创建两个图像资源的交叉淡化效果              element()      用于引用页面上的其他 HTML 元素              paint()      用于引用自定义的 CSS 绘图函数            url(): 这是最常用的资源引入函数,可以引入图片、字体、SVG 等各种资源文件。          示例: background-image: url('image.jpg')            image(): 这个函数可以引入可以根据不同环境自动调整大小的图像资源。          示例: background-image: image(url('image.svg'), url('image.png'))            cross-fade(): 这个函数可以创建两个图像资源之间的交叉渐变效果。          示例: background-image: cross-fade(url('image1.jpg'), url('image2.jpg'), 50%)            element(): 这个函数可以引用页面上的其他 HTML 元素,例如用于创建动态背景。          示例: background-image: element(#my-element)            paint(): 这个函数可以引用自定义的 CSS 绘图函数,用于创建复杂的图形效果。          示例: background-image: paint(my-gradient, #333, #666)      属性函数            属性函数      描述                  var()      用于引用自定义属性(CSS 变量)              env()      用于引用环境变量              attr()      用于引用 HTML 元素的属性值            var(): 这个函数用于引用自定义 CSS 属性(也称为 CSS 变量)。    :root {  --main-color: #333;}div {  color: var(--main-color);}            env(): 这个函数用于引用操作系统或浏览器提供的环境变量。    body {  padding-bottom: env(safe-area-inset-bottom);}            attr(): 这个函数用于引用 HTML 元素的属性值。    a::after {  content: \"(\" attr(href) \")\";}      变量函数      var(): 这个函数用于引用自定义 CSS 属性(也称为 CSS 变量)。    :root {  --main-color: #333;}div {  color: var(--main-color);}            env(): 这个函数用于引用操作系统或浏览器提供的环境变量。    body {  padding-bottom: env(safe-area-inset-bottom);}      var() 函数:  允许我们定义可重复使用的值,提高 CSS 的可维护性和可扩展性  变量可以定义在任何 CSS 选择器中,包括 :root 伪类  变量的值可以是任何有效的 CSS 值,如颜色、长度、字体等  变量可以嵌套使用,也可以在媒体查询中使用env() 函数:  允许我们访问操作系统或浏览器提供的环境变量  常见的环境变量包括 safe-area-inset-*、color-scheme 等  使用环境变量可以帮助我们更好地适应不同的设备和环境"
  },
  
  {
    "title": "Web HTML",
    "url": "/posts/web-client-base/",
    "categories": "Language, Web",
    "tags": "Web, HTML",
    "date": "2018-12-01 11:10:10 +0800",
    





    
    "snippet": "什么是 HTML  HTML，全称为 HyperText Markup Language（超文本标记语言）  是一种用于创建和设计网页的标准标记语言。HTML 的主要功能是定义网页的结构和内容，它通过一系列的标签（tags）来描述文本、图像、链接、表格、表单等页面元素      基本概念          标记语言：HTML 是一种标记语言，它使用标签来标记不同类型的内容。这些标签告诉浏览器...",
    "content": "什么是 HTML  HTML，全称为 HyperText Markup Language（超文本标记语言）  是一种用于创建和设计网页的标准标记语言。HTML 的主要功能是定义网页的结构和内容，它通过一系列的标签（tags）来描述文本、图像、链接、表格、表单等页面元素      基本概念          标记语言：HTML 是一种标记语言，它使用标签来标记不同类型的内容。这些标签告诉浏览器如何显示网页内容      超文本：超文本是一种包含链接的文本，可以通过点击链接从一个文档跳转到另一个文档            HTML 与 XHTML          HTML (Hypertext Markup Language) 和 XHTML (Extensible Hypertext Markup Language) 之间有以下几个主要区别:                      语法规则:                  HTML 语法相对宽松,允许一些错误的标记。          XHTML 严格遵循 XML 语法规则,要求所有标签都必须正确闭合,属性值必须用引号括起来等。                            大小写规范:                  HTML 标签和属性名可以是大写或小写。          XHTML 标签和属性名必须使用小写。                            空元素的书写:                  HTML 中的空元素(如 &lt;br&gt; 和 &lt;img&gt;)可以使用开始标签和结束标签,也可以仅使用开始标签。          XHTML 中的空元素必须使用自闭合标签,如 &lt;br /&gt; 和 &lt;img /&gt;。                            文档结构:                  HTML 文档可以省略一些必需的元素,如 &lt;html&gt; 和 &lt;body&gt; 等。          XHTML 文档必须包含 &lt;html&gt; 根元素,并且 &lt;head&gt; 和 &lt;body&gt; 元素也是必需的。                            MIME 类型:                  HTML 文档的 MIME 类型通常为 text/html。          XHTML 文档的 MIME 类型通常为 application/xhtml+xml。                            兼容性:                  HTML 被所有浏览器广泛支持。          XHTML 在某些较老的浏览器上可能不太兼容,需要特殊的处理。                    总的来说, XHTML 相比 HTML 更加严格和规范,这有助于提高代码的可读性和可维护性,但同时也增加了开发的复杂度。随着 HTML5 的普及,XHTML 的使用已经逐渐减少,大多数现代网页都采用 HTML5 标准。&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"UTF-8\" /&gt;    &lt;title&gt;页面标题&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;这是一个主标题&lt;/h1&gt;    &lt;p&gt;这是一个段落。&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;      解释          &lt;!DOCTYPE html&gt;：声明文档类型，告诉浏览器这是一个 HTML5 文档      &lt;html&gt;：根元素，包含所有的 HTML 内容      &lt;head&gt;：头部元素，包含页面的元数据（metadata），如文档的字符集、标题、链接到 CSS 样式表等      &lt;title&gt;：定义网页标题，会显示在浏览器的标签上      &lt;body&gt;：主体元素，包含页面的主要内容，如文本、图像、链接等      标签分类            类型      主要作用                  结构性标签      定义文档的基本结构和布局              文本格式标签      用于文本的格式化和排版              列表标签      定义各种类型的列表结构              表格标签      创建和管理表格结构              表单标签      创建和处理用户输入的表单              媒体标签      嵌入和管理媒体内容，如图像、音频和视频              元数据标签      提供关于文档的元数据，如描述、关键词、样式和链接等              脚本和编程标签      嵌入脚本和编程代码，提供动态行为              内联框架标签      在页面内嵌入其他文档或内容              样式标签      定义文档的样式和外观              交互标签      提供用户交互功能，如可展开的详细信息和对话框              语义标签      提供清晰的语义信息，帮助搜索引擎和开发者理解内容结构      结构性标签            结构性标签      示例      作用                  &lt;html&gt;      &lt;html&gt;...&lt;/html&gt;      定义 HTML 文档的根元素              &lt;head&gt;      &lt;head&gt;...&lt;/head&gt;      包含文档的元数据，如标题、样式、脚本等              &lt;title&gt;      &lt;title&gt;Page Title&lt;/title&gt;      定义文档的标题，显示在浏览器标签页上              &lt;body&gt;      &lt;body&gt;...&lt;/body&gt;      包含文档的主要内容              &lt;header&gt;      &lt;header&gt;...&lt;/header&gt;      定义文档或节的头部内容，通常包含导航链接和标题              &lt;footer&gt;      &lt;footer&gt;...&lt;/footer&gt;      定义文档或节的底部内容，通常包含版权信息和联系信息              &lt;section&gt;      &lt;section&gt;...&lt;/section&gt;      定义文档中的一个节，通常包含主题相关的一组内容              &lt;article&gt;      &lt;article&gt;...&lt;/article&gt;      定义文档中的独立内容单元，适用于博客文章、新闻等              &lt;nav&gt;      &lt;nav&gt;...&lt;/nav&gt;      定义导航链接的部分              &lt;main&gt;      &lt;main&gt;...&lt;/main&gt;      定义文档的主体内容，主要内容部分              &lt;aside&gt;      &lt;aside&gt;...&lt;/aside&gt;      定义页面内容之外的侧边栏内容，通常包含相关信息或广告              &lt;div&gt;      &lt;div&gt;...&lt;/div&gt;      定义文档中的一个通用容器，无特定语义意义，用于布局和样式      文本格式标签            文本格式标签      示例      作用                  &lt;h1&gt; - &lt;h6&gt;      &lt;h1&gt;This is a heading&lt;/h1&gt;      定义标题的级别，&lt;h1&gt; 表示最高级标题，&lt;h6&gt; 表示最低级标题。              &lt;p&gt;      &lt;p&gt;This is a paragraph.&lt;/p&gt;      定义段落，用于组织文本内容。              &lt;a&gt;      &lt;a href=\"https://example.com\"&gt;Link&lt;/a&gt;      定义超链接，允许用户点击跳转到指定的 URL。              &lt;span&gt;      &lt;span style=\"color:red;\"&gt;Text&lt;/span&gt;      定义行内文本样式，可以通过 CSS 或内联样式设置。              &lt;em&gt;      &lt;em&gt;This text is emphasized.&lt;/em&gt;      强调文本，通常以斜体显示，表示语气或重要性的强调。              &lt;strong&gt;      &lt;strong&gt;This text is strong.&lt;/strong&gt;      重要文本，通常以粗体显示，表示比周围文本更为重要。      列表标签            列表标签      示例      作用                  &lt;ul&gt;      &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;      创建无序列表，列表项将显示为项目符号或其他符号。              &lt;ol&gt;      &lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ol&gt;      创建有序列表，列表项将按照数字或字母顺序排列。              &lt;li&gt;      &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;      定义列表中的一个项目，通常嵌套在&lt;ul&gt; 或&lt;ol&gt; 中。              &lt;dl&gt;      &lt;dl&gt; &lt;dt&gt;Term 1&lt;/dt&gt; &lt;dd&gt;Description 1&lt;/dd&gt; &lt;dt&gt;Term 2&lt;/dt&gt; &lt;dd&gt;Description 2&lt;/dd&gt; &lt;/dl&gt;      创建描述列表，用于表示术语及其相应的描述。              &lt;dt&gt;      &lt;dl&gt; &lt;dt&gt;Term 1&lt;/dt&gt; &lt;dd&gt;Description 1&lt;/dd&gt; &lt;dt&gt;Term 2&lt;/dt&gt; &lt;dd&gt;Description 2&lt;/dd&gt; &lt;/dl&gt;      定义描述列表中的术语。              &lt;dd&gt;      &lt;dl&gt; &lt;dt&gt;Term 1&lt;/dt&gt; &lt;dd&gt;Description 1&lt;/dd&gt; &lt;dt&gt;Term 2&lt;/dt&gt; &lt;dd&gt;Description 2&lt;/dd&gt; &lt;/dl&gt;      定义描述列表中术语的描述。      表格标签            表格标签      示例      作用                  &lt;table&gt;      &lt;table&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      创建表格，用于展示数据和信息。              &lt;tr&gt;      &lt;table&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格中的一行（行），必须嵌套在&lt;table&gt; 标签内。              &lt;td&gt;      &lt;table&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格中的一个单元格（列），必须嵌套在&lt;tr&gt; 标签内。              &lt;th&gt;      &lt;table&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格中的表头单元格，通常加粗居中显示。              &lt;thead&gt;      &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;      定义表格的头部内容，包含一组表头行，通常放置在表格内部的最前面。              &lt;tbody&gt;      &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;      定义表格的主体内容，包含一组表格行，用于显示实际数据。              &lt;tfoot&gt;      &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;Footer&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;      定义表格的尾部内容，通常包含一些总结或附加信息。              &lt;caption&gt;      &lt;table&gt; &lt;caption&gt;Table Caption&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格的标题，通常放置在表格之前或之后，并且只能出现一次。              &lt;col&gt;      &lt;table&gt; &lt;colgroup&gt; &lt;col span=\"2\"&gt; &lt;/colgroup&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格中一列或多列的属性，通常与&lt;colgroup&gt; 元素一起使用。              &lt;colgroup&gt;      &lt;table&gt; &lt;colgroup&gt; &lt;col span=\"2\"&gt; &lt;/colgroup&gt; &lt;tr&gt; &lt;td&gt;Row 1, Cell 1&lt;/td&gt; &lt;td&gt;Row 1, Cell 2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;      定义表格中一组列的属性，通常与&lt;col&gt; 元素一起使用。      表单标签            表单标签      示例      作用                  &lt;form&gt;      &lt;form action=\"/submit\" method=\"post\"&gt; ... &lt;/form&gt;      创建一个表单，用于收集用户输入。              &lt;input&gt;      &lt;input type=\"text\" name=\"username\"&gt;      定义一个输入控件，可以是文本框、单选框、复选框等。              &lt;textarea&gt;      &lt;textarea name=\"message\"&gt;Enter your message here.&lt;/textarea&gt;      定义一个多行文本输入框。              &lt;button&gt;      &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;      定义一个按钮，用于提交表单数据或执行其他操作。              &lt;select&gt;      &lt;select name=\"country\"&gt; &lt;option value=\"USA\"&gt;USA&lt;/option&gt; &lt;option value=\"UK\"&gt;UK&lt;/option&gt; &lt;/select&gt;      定义一个下拉菜单，供用户选择一个或多个选项。              &lt;option&gt;      &lt;select name=\"country\"&gt; &lt;option value=\"USA\"&gt;USA&lt;/option&gt; &lt;option value=\"UK\"&gt;UK&lt;/option&gt; &lt;/select&gt;      定义下拉菜单中的一个选项。              &lt;label&gt;      &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt;      定义一个标签，用于标识输入字段的含义。              &lt;fieldset&gt;      &lt;fieldset&gt; &lt;legend&gt;Personal Information&lt;/legend&gt; ... &lt;/fieldset&gt;      定义一个字段集，用于将相关表单元素组合在一起。              &lt;legend&gt;      &lt;fieldset&gt; &lt;legend&gt;Personal Information&lt;/legend&gt; ... &lt;/fieldset&gt;      定义字段集的标题，描述相关表单元素的目的或组合。              &lt;datalist&gt;      &lt;input list=\"browsers\"&gt; &lt;datalist id=\"browsers\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Firefox\"&gt; &lt;/datalist&gt;      定义一个输入框的预定义选项列表。              &lt;optgroup&gt;      &lt;select&gt; &lt;optgroup label=\"Group 1\"&gt; &lt;option value=\"Item 1\"&gt;Item 1&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt;      定义一个选项组，用于在下拉菜单中组织选项。      媒体标签            媒体标签      示例      作用                  &lt;img&gt;      &lt;img src=\"image.jpg\" alt=\"Image\"&gt;      嵌入图像，用于在网页中显示图片。              &lt;audio&gt;      &lt;audio src=\"audio.mp3\" controls&gt;&lt;/audio&gt;      嵌入音频，用于在网页中播放音频文件。              &lt;video&gt;      &lt;video src=\"video.mp4\" controls&gt;&lt;/video&gt;      嵌入视频，用于在网页中播放视频文件。              &lt;source&gt;      &lt;video controls&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;/video&gt;      定义多媒体文件的来源，为&lt;video&gt; 和&lt;audio&gt; 提供备选资源。              &lt;track&gt;      &lt;video controls&gt; &lt;track src=\"subtitles_en.vtt\" kind=\"subtitles\" srclang=\"en\" label=\"English\"&gt; &lt;/video&gt;      为&lt;audio&gt; 和&lt;video&gt; 元素定义外部文本轨道。              &lt;embed&gt;      &lt;embed src=\"flash.swf\" width=\"400\" height=\"300\"&gt;      嵌入外部应用程序或媒体资源，如 Flash 动画。              &lt;object&gt;      &lt;object data=\"movie.swf\" width=\"400\" height=\"300\"&gt;&lt;/object&gt;      嵌入外部资源，如插件、多媒体内容或其他资源。              &lt;param&gt;      &lt;object data=\"movie.swf\"&gt; &lt;param name=\"autoplay\" value=\"true\"&gt; &lt;/object&gt;      为&lt;object&gt; 元素指定参数。              &lt;iframe&gt;      &lt;iframe src=\"https://example.com\" width=\"600\" height=\"400\"&gt;&lt;/iframe&gt;      嵌入另一个 HTML 页面或媒体内容，通常用于显示第三方内容。      元数据标签            元数据标签      示例      作用                  &lt;meta&gt;      &lt;meta charset=\"UTF-8\"&gt;      定义 HTML 文档的元数据，如字符集、描述、关键词等。              &lt;link&gt;      &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;      定义文档与外部资源之间的关系，如链接到样式表、图标等。              &lt;title&gt;      &lt;title&gt;Page Title&lt;/title&gt;      定义文档的标题，显示在浏览器的标题栏或标签页上。              &lt;base&gt;      &lt;base href=\"https://www.example.com/\"&gt;      定义页面中所有相对链接的基本 URL，用于指定页面中的所有相对链接的基础 URL。              &lt;style&gt;      &lt;style&gt; body { color: red; } &lt;/style&gt;      定义文档的样式信息，通常放置在&lt;head&gt; 标签内部，用于设置文档的样式和布局。      脚本和编程标签            脚本和编程标签      示例      作用                  &lt;script&gt;      &lt;script src=\"script.js\"&gt;&lt;/script&gt;      嵌入客户端脚本，通常用于引入外部 JavaScript 文件或在页面内部编写 JavaScript 代码。              &lt;noscript&gt;      &lt;noscript&gt;Sorry, your browser does not support JavaScript.&lt;/noscript&gt;      提供在不支持 JavaScript 的情况下显示的备选内容。              &lt;template&gt;      &lt;template&gt; &lt;p&gt;This is a template.&lt;/p&gt; &lt;/template&gt;      定义一个 HTML 模板，用于客户端 JavaScript 代码中动态生成 HTML 内容。              &lt;canvas&gt;      &lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\"&gt;&lt;/canvas&gt;      定义一个画布，用于通过 JavaScript 绘制图形、动画或其他图像操作。      内联框架标签            内联框架标签      示例      作用                  &lt;iframe&gt;      &lt;iframe src=\"https://www.example.com\" width=\"600\" height=\"400\"&gt;&lt;/iframe&gt;      嵌入另一个 HTML 页面或媒体内容，通常用于显示第三方内容，如嵌入其他网页、广告、地图等。        &lt;iframe&gt; 标签允许在当前 HTML 文档中嵌入其他 HTML 文档或媒体内容，创建了一种内联的框架结构，使得内容可以在框架中独立显示样式标签            样式标签      示例      作用                  &lt;style&gt;      &lt;style&gt; body { color: red; } &lt;/style&gt;      定义文档的样式信息，通常放置在&lt;head&gt; 标签内部，用于设置文档的样式和布局。              &lt;link&gt;      &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;      将外部样式表链接到 HTML 文档，使得可以从外部导入样式定义，提高代码的可维护性和复用性。      交互标签            交互标签      示例      作用                  &lt;details&gt;      &lt;details&gt; &lt;summary&gt;Click me&lt;/summary&gt; &lt;p&gt;Details content goes here.&lt;/p&gt; &lt;/details&gt;      定义一个可展开的详细内容块，用户可以点击摘要部分来展开或收起详细内容。              &lt;summary&gt;      &lt;details&gt; &lt;summary&gt;Click me&lt;/summary&gt; &lt;p&gt;Details content goes here.&lt;/p&gt; &lt;/details&gt;      定义&lt;details&gt; 元素的摘要部分，通常为一个可点击的标题，用于触发详细内容的展开或收起。              &lt;dialog&gt;      &lt;dialog open&gt;This is a dialog.&lt;/dialog&gt;      定义一个对话框，用于显示提示、警告或需要用户输入的信息。      语义标签            语义标签      示例      作用                  &lt;header&gt;      &lt;header&gt;Header content goes here.&lt;/header&gt;      定义文档或节的头部，通常包含网站的标志、导航链接等。              &lt;footer&gt;      &lt;footer&gt;Footer content goes here.&lt;/footer&gt;      定义文档或节的底部，通常包含版权信息、联系信息等。              &lt;nav&gt;      &lt;nav&gt;Navigation links go here.&lt;/nav&gt;      定义导航链接的区域，用于包含页面的主要导航链接。              &lt;section&gt;      &lt;section&gt;Section content goes here.&lt;/section&gt;      定义文档中的一个节，通常包含一组相关的内容。              &lt;article&gt;      &lt;article&gt;Article content goes here.&lt;/article&gt;      定义文档中的一个独立内容单元，如博客文章、新闻等。              &lt;main&gt;      &lt;main&gt;Main content goes here.&lt;/main&gt;      定义文档的主要内容区域，通常包含页面的核心内容。              &lt;aside&gt;      &lt;aside&gt;Aside content goes here.&lt;/aside&gt;      定义文档中的附属内容，通常包含与主要内容相关的辅助信息，如侧边栏、广告等。              &lt;figure&gt;      &lt;figure&gt; &lt;img src=\"image.jpg\" alt=\"Image\"&gt; &lt;figcaption&gt;Figure caption goes here.&lt;/figcaption&gt; &lt;/figure&gt;      定义一组相关的媒体内容和它们的标题，如图片、图表、视频等。              &lt;figcaption&gt;      &lt;figure&gt; &lt;img src=\"image.jpg\" alt=\"Image\"&gt; &lt;figcaption&gt;Figure caption goes here.&lt;/figcaption&gt; &lt;/figure&gt;      定义&lt;figure&gt; 元素中媒体内容的标题，通常出现在图片、图表等媒体内容的下方。              &lt;details&gt;      &lt;details&gt; &lt;summary&gt;Click me&lt;/summary&gt; &lt;p&gt;Details content goes here.&lt;/p&gt; &lt;/details&gt;      定义一个可展开的详细内容块，用户可以点击摘要部分来展开或收起详细内容。              &lt;summary&gt;      &lt;details&gt; &lt;summary&gt;Click me&lt;/summary&gt; &lt;p&gt;Details content goes here.&lt;/p&gt; &lt;/details&gt;      定义&lt;details&gt; 元素的摘要部分，通常为一个可点击的标题，用于触发详细内容的展开或收起。              &lt;mark&gt;      &lt;p&gt;This is &lt;mark&gt;highlighted&lt;/mark&gt; text.&lt;/p&gt;      定义需要突出显示的文本内容，通常以黄色或其他醒目的颜色显示。              &lt;time&gt;      &lt;p&gt;Meeting is scheduled for &lt;time datetime=\"2022-05-01T08:30\"&gt;tomorrow&lt;/time&gt; at 8:30 AM.&lt;/p&gt;      定义日期或时间信息，使得浏览器和搜索引擎能够更好地理解并处理。              &lt;abbr&gt;      &lt;p&gt;This is an &lt;abbr title=\"abbreviation\"&gt;abbr&lt;/abbr&gt; tag.&lt;/p&gt;      定义缩写或首字母缩略词，title 属性用于提供完整的解释或含义。              &lt;blockquote&gt;      &lt;blockquote&gt; &lt;p&gt;This is a quotation.&lt;/p&gt; &lt;footer&gt;Author&lt;/footer&gt; &lt;/blockquote&gt;      定义长的引用内容，通常以缩进或其他样式显示，并包含引用的来源或作者。              &lt;cite&gt;      &lt;p&gt;&lt;cite&gt;Reference&lt;/cite&gt;&lt;/p&gt;      定义文本的引用来源，通常用于引用书籍、文章或其他作品的名称。              &lt;q&gt;      &lt;p&gt;&lt;q&gt;This is a short quotation.&lt;/q&gt;&lt;/p&gt;      定义短的内联引用，通常用于引用短语或一两句话的引用。              &lt;address&gt;      &lt;address&gt;Contact information goes here.&lt;/address&gt;      定义联系信息，通常用于包含作者、所有者或相关组织的联系信息。      标签完整例子&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;  &lt;head&gt;    &lt;meta charset=\"UTF-8\" /&gt;    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;    &lt;title&gt;Complete HTML Example&lt;/title&gt;    &lt;style&gt;      /* CSS样式 */      body {        font-family: Arial, sans-serif;      }      table {        width: 100%;        border-collapse: collapse;      }      th,      td {        border: 1px solid #ddd;        padding: 8px;        text-align: left;      }      th {        background-color: #f2f2f2;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 结构性标签 --&gt;    &lt;header&gt;      &lt;h1&gt;Header&lt;/h1&gt;    &lt;/header&gt;    &lt;!-- 文本格式标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Text Formatting&lt;/h2&gt;      &lt;p&gt;This is a paragraph.&lt;/p&gt;      &lt;em&gt;This text is emphasized.&lt;/em&gt;      &lt;strong&gt;This text is strong.&lt;/strong&gt;    &lt;/section&gt;    &lt;!-- 列表标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Lists&lt;/h2&gt;      &lt;ul&gt;        &lt;li&gt;Item 1&lt;/li&gt;        &lt;li&gt;Item 2&lt;/li&gt;      &lt;/ul&gt;      &lt;ol&gt;        &lt;li&gt;Item 1&lt;/li&gt;        &lt;li&gt;Item 2&lt;/li&gt;      &lt;/ol&gt;    &lt;/section&gt;    &lt;!-- 表格标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Table&lt;/h2&gt;      &lt;table&gt;        &lt;tr&gt;          &lt;th&gt;Header 1&lt;/th&gt;          &lt;th&gt;Header 2&lt;/th&gt;        &lt;/tr&gt;        &lt;tr&gt;          &lt;td&gt;Row 1, Cell 1&lt;/td&gt;          &lt;td&gt;Row 1, Cell 2&lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;    &lt;/section&gt;    &lt;!-- 表单标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Form&lt;/h2&gt;      &lt;form action=\"/submit\" method=\"post\"&gt;        &lt;label for=\"username\"&gt;Username:&lt;/label&gt;        &lt;input type=\"text\" id=\"username\" name=\"username\" /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;label for=\"password\"&gt;Password:&lt;/label&gt;        &lt;input type=\"password\" id=\"password\" name=\"password\" /&gt;&lt;br /&gt;&lt;br /&gt;        &lt;input type=\"submit\" value=\"Submit\" /&gt;      &lt;/form&gt;    &lt;/section&gt;    &lt;!-- 媒体标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Media&lt;/h2&gt;      &lt;img src=\"image.jpg\" alt=\"Image\" /&gt;      &lt;audio controls&gt;        &lt;source src=\"audio.mp3\" type=\"audio/mpeg\" /&gt;        Your browser does not support the audio element.      &lt;/audio&gt;      &lt;video width=\"320\" height=\"240\" controls&gt;        &lt;source src=\"movie.mp4\" type=\"video/mp4\" /&gt;        Your browser does not support the video element.      &lt;/video&gt;    &lt;/section&gt;    &lt;!-- 元数据标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Metadata&lt;/h2&gt;      &lt;meta name=\"description\" content=\"This is a description\" /&gt;      &lt;meta name=\"keywords\" content=\"HTML, CSS, JavaScript\" /&gt;    &lt;/section&gt;    &lt;!-- 脚本和编程标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Scripting and Programming&lt;/h2&gt;      &lt;script&gt;        document.write(\"This is JavaScript.\");      &lt;/script&gt;    &lt;/section&gt;    &lt;!-- 内联框架标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Inline Frames&lt;/h2&gt;      &lt;iframe src=\"https://www.example.com\" width=\"600\" height=\"400\"&gt;&lt;/iframe&gt;    &lt;/section&gt;    &lt;!-- 样式标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Styling&lt;/h2&gt;      &lt;p style=\"color: red;\"&gt;This text is red.&lt;/p&gt;    &lt;/section&gt;    &lt;!-- 交互标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Interactive Elements&lt;/h2&gt;      &lt;details&gt;        &lt;summary&gt;Click me&lt;/summary&gt;        &lt;p&gt;Details content goes here.&lt;/p&gt;      &lt;/details&gt;    &lt;/section&gt;    &lt;!-- 语义标签 --&gt;    &lt;section&gt;      &lt;h2&gt;Semantic Elements&lt;/h2&gt;      &lt;header&gt;        &lt;h1&gt;Header&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;ul&gt;          &lt;li&gt;&lt;a href=\"#\"&gt;Home&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"#\"&gt;About&lt;/a&gt;&lt;/li&gt;          &lt;li&gt;&lt;a href=\"#\"&gt;Contact&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;      &lt;/nav&gt;      &lt;main&gt;        &lt;article&gt;          &lt;h2&gt;Article Title&lt;/h2&gt;          &lt;p&gt;Article content goes here.&lt;/p&gt;        &lt;/article&gt;      &lt;/main&gt;      &lt;footer&gt;        &lt;p&gt;Footer&lt;/p&gt;      &lt;/footer&gt;    &lt;/section&gt;  &lt;/body&gt;&lt;/html&gt;标签属性            分类      属性                  基本属性      id, class, style, title              链接和导航属性      href, target, download              多媒体属性      src, alt, width, height              表单属性      value, name, type, placeholder, required, disabled, readonly, checked, selected              语义属性      lang, dir, translate              事件属性      onclick, onmouseover, onsubmit, onload              其他常用属性      draggable, hidden, contenteditable, spellcheck      基本属性            属性      描述      示例                  id      给元素设置唯一标识符      &lt;div id=\"main-content\"&gt;&lt;/div&gt;              class      给元素设置类名      &lt;p class=\"text-large text-bold\"&gt;这是一段加粗大号文本&lt;/p&gt;              style      在标签内部直接设置 CSS 样式      &lt;h1 style=\"color:red; font-size:36px;\"&gt;这是一个红色大标题&lt;/h1&gt;              title      设置元素的悬停提示文本      &lt;a href=\"https://www.example.com\" title=\"访问示例网站\"&gt;示例链接&lt;/a&gt;      链接和导航属性            属性      描述      示例                  href      指定链接地址      &lt;a href=\"https://www.example.com\"&gt;链接文本&lt;/a&gt;              target      指定链接打开方式      &lt;a href=\"https://www.example.com\" target=\"_blank\"&gt;在新标签页打开&lt;/a&gt;              download      指定下载文件名      &lt;a href=\"file.pdf\" download=\"example.pdf\"&gt;下载文件&lt;/a&gt;            href 属性:          用于指定链接的目标 URL 地址。      可以是绝对地址或相对地址。            target 属性:          用于指定链接在何处打开。      常用值有 _blank(在新标签页打开)、_self(在当前窗口打开)、_parent(在父框架打开)、_top(在最顶层框架打开)。            download 属性:          用于指定下载链接时保存的文件名。      当用户点击下载链接时,浏览器会自动下载并保存文件。      多媒体属性            属性      描述      示例                  src      指定图片或视频的来源路径      &lt;img src=\"image.jpg\" alt=\"示例图片\"&gt;              alt      提供图片的替代文本描述      &lt;img src=\"image.jpg\" alt=\"这是一张示例图片\"&gt;              width      设置图像或视频的宽度      &lt;img src=\"image.jpg\" width=\"400\"&gt;              height      设置图像或视频的高度      &lt;img src=\"image.jpg\" height=\"300\"&gt;            src 属性:          用于指定图像、视频或音频文件的来源路径。      可以是绝对路径或相对路径。            alt 属性:          用于提供图像的替代文本描述。      当图像无法显示时,浏览器会显示此替代文本。      对于无障碍访问也很重要。            width 和 height 属性:          用于设置图像或视频元素的宽度和高度。      可以使用像素或百分比等单位。      表单属性好的,下面我来介绍 HTML 表单标签的常用属性:            属性      描述      示例                  value      指定表单控件的初始值      &lt;input type=\"text\" value=\"请输入文本\"&gt;              name      指定表单控件的名称      &lt;input type=\"text\" name=\"username\"&gt;              type      指定表单控件的类型      &lt;input type=\"email\" name=\"email\"&gt;              placeholder      提供输入框的提示文本      &lt;input type=\"text\" placeholder=\"请输入用户名\"&gt;              required      指定表单控件为必填项      &lt;input type=\"text\" required&gt;              disabled      禁用表单控件      &lt;input type=\"text\" disabled&gt;              readonly      设置表单控件为只读      &lt;input type=\"text\" readonly&gt;              checked      设置单选框/复选框为选中状态      &lt;input type=\"checkbox\" checked&gt;              selected      设置下拉列表项为选中状态      &lt;option value=\"option1\" selected&gt;选项1&lt;/option&gt;      语义属性好的,下面我来介绍 HTML 常见的语义属性:            属性      描述      示例                  lang      指定元素的语言      &lt;html lang=\"zh-CN\"&gt;              role      指定元素的角色或用途      &lt;nav role=\"navigation\"&gt;              aria-label      提供元素的无障碍标签      &lt;button aria-label=\"关闭\"&gt;X&lt;/button&gt;              aria-describedby      关联元素的无障碍描述      &lt;div id=\"desc\"&gt;这是一个重要提示&lt;/div&gt;&lt;button aria-describedby=\"desc\"&gt;查看提示&lt;/button&gt;              alt      为图像提供替代文本      &lt;img src=\"logo.png\" alt=\"公司logo\"&gt;              figure 和 figcaption      定义含有图像的语义化区块      &lt;figure&gt;&lt;img src=\"image.jpg\" alt=\"示例图片\"&gt;&lt;figcaption&gt;这是一张示例图片&lt;/figcaption&gt;&lt;/figure&gt;            lang 属性:          用于指定元素的语言,有助于屏幕阅读器正确朗读内容。            role 属性:          用于指定元素的语义化角色,帮助无障碍工具理解页面结构。            aria-label 和 aria-describedby 属性:          用于提供元素的无障碍标签和描述,增强可访问性。            alt 属性:          为图像提供替代文本描述,当图像无法显示时提供备用内容。            figure 和 figcaption 元素:          定义含有图像的语义化区块,将图像和说明文字关联在一起。      事件属性            属性      描述      示例                  onclick      点击元素时触发      &lt;button onclick=\"alert('你点击了我!')\"&gt;点击我&lt;/button&gt;              onmouseover      鼠标移入元素时触发      &lt;div onmouseover=\"showTooltip()\"&gt;悬停显示提示&lt;/div&gt;              onkeydown      键盘按下时触发      &lt;input type=\"text\" onkeydown=\"validateInput(event)\"&gt;              onload      页面或图像加载完成时触发      &lt;body onload=\"initPage()\"&gt;              onsubmit      表单提交时触发      &lt;form onsubmit=\"validateForm(event)\"&gt;            onclick 属性:          当用户点击元素时触发。      通常用于绑定元素的点击事件处理函数。            onmouseover 和 onmouseout 属性:          当鼠标移入/移出元素时触发。      常用于实现悬停提示等交互效果。            onkeydown 和 onkeyup 属性:          当键盘按下/释放时触发。      可用于实现各种键盘交互功能。            onload 属性:          当页面或图像加载完成时触发。      通常用于初始化页面或执行加载后的操作。            onsubmit 属性:          当表单提交时触发。      可用于对表单数据进行验证和处理。      其他常用属性      class 属性:          用于为元素指定一个或多个类名,以便于应用 CSS 样式和 JavaScript 交互。      可以为一个元素指定多个类名,用空格分隔,如 &lt;div class=\"container main-content\"&gt;...&lt;/div&gt;。      在 CSS 中,可以使用类选择器 .class-name 来应用样式。      在 JavaScript 中,可以使用 document.getElementsByClassName() 或 element.classList 来查询和操作元素的类名。            id 属性:          为元素提供唯一标识符,可用于精确定位元素。      在 CSS 中,可以使用 ID 选择器 #id-name 来应用样式。      在 JavaScript 中,可以使用 document.getElementById() 来查找元素。      每个 HTML 文档中 id 属性的值应该是唯一的。            style 属性:          用于为元素设置内联 CSS 样式,格式为 属性: 值;。      示例: &lt;p style=\"color: red; font-size: 16px;\"&gt;...&lt;/p&gt;      内联样式具有最高优先级,但通常不建议过度使用,应该将样式定义在外部 CSS 文件中。            data-* 属性:          用于存储元素的自定义数据属性,以 data- 为前缀。      示例: &lt;div data-item-id=\"123\" data-item-price=\"9.99\"&gt;...&lt;/div&gt;      在 JavaScript 中,可以使用 element.dataset 属性来读取和操作这些自定义数据。            title 属性:          提供元素的附加说明信息,通常以工具提示的形式显示。      示例: &lt;a href=\"https://example.com\" title=\"这是一个链接\"&gt;示例链接&lt;/a&gt;      可以使用 CSS 的 ::before 或 ::after 伪元素来自定义工具提示的样式和行为。      "
  },
  
  {
    "title": "标题",
    "url": "/posts/readme/",
    "categories": "Cc, Left",
    "tags": "Blog",
    "date": "2018-08-08 14:10:00 +0800",
    





    
    "snippet": "博客笔记目录结构  在根目录下一般有以下文件夹和文件: (要是 github 想禁用 jekyll,建一个 .nojekyll )  _config.yml 配置文件,配置 jekyll 的一切以及变量  index.md/html 主页文件,必须的  .gitignore 被忽略上传到 github 的文件(夹)列表  .jekyll-metadata 用来记录追踪文件修改情况,以便更新....",
    "content": "博客笔记目录结构  在根目录下一般有以下文件夹和文件: (要是 github 想禁用 jekyll,建一个 .nojekyll )  _config.yml 配置文件,配置 jekyll 的一切以及变量  index.md/html 主页文件,必须的  .gitignore 被忽略上传到 github 的文件(夹)列表  .jekyll-metadata 用来记录追踪文件修改情况,以便更新.  _layout 模板文件夹,用来生成相应子页面的模板,在子页面中 layout: page 指定  _post 相应子页面(博客)所在位置,文件名规则:2015-07-24-name.md/html  _includes 用来包含一些常用需要的结构块文件,例如 comment.使用 {\\% include file.ext \\%} 来包含(\\去掉).非必须.  _site 如果使用 jekyll 本地版生成页面就会有该文件夹.一般会被判断为不上传到 github.非必须.  _drafts 草稿文件,不会被生成到网页中.非必须.  _data 格式化好的网站数据应放在这里。jekyll 的引擎会自动加载在该目录下所有的 yaml 文件（后缀是 .yml 或者 .yaml).作用不明..非必须文章标头---title: 标题date: 2018-08-08 14:10:00 +0800 # 时间draft: false # 是不是草稿tags: [Cc] # 分类categories: [Cc , Left] # 类别toc: falsecomments: false # 评论math: true # 数学mermaid: true # 图标pin: false # 顶置description: 解释image:  path: /assets/img/c/c.jpeg---"
  },
  
  {
    "title": "佳能入门",
    "url": "/posts/Canon/",
    "categories": "Cc, Left, Canon",
    "tags": "Left",
    "date": "2018-06-06 12:48:54 +0800",
    





    
    "snippet": "安装镜头与卸载安装  镜头上有个白色的正方快点  与机身上的白色点对应起来  向下旋转镜头  可以听到一声卡住的响声卸载  按住镜头上的白色对应的半椭圆形的按键按钮  按住同时向上旋转镜头镜头上 stabilizer 开关防抖开关，区别就是在快门速度较慢的情况下，辅助稳定画质AF 和 MF 区别  AF：自动对焦  MF：手动对焦          主要是在拍照的时候，摄影者是习惯手动对焦还...",
    "content": "安装镜头与卸载安装  镜头上有个白色的正方快点  与机身上的白色点对应起来  向下旋转镜头  可以听到一声卡住的响声卸载  按住镜头上的白色对应的半椭圆形的按键按钮  按住同时向上旋转镜头镜头上 stabilizer 开关防抖开关，区别就是在快门速度较慢的情况下，辅助稳定画质AF 和 MF 区别  AF：自动对焦  MF：手动对焦          主要是在拍照的时候，摄影者是习惯手动对焦还是自动对焦。      AF 代表自动对焦，由相机自动控制镜头进行对焦。      "
  },
  
  {
    "title": "Windows Java Install",
    "url": "/posts/windows-java-install/",
    "categories": "Language, Java",
    "tags": "Server, Java, Java Base",
    "date": "2018-01-06 09:08:09 +0800",
    





    
    "snippet": "环境介绍第一步  下载链接：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html第二步  选择刚刚下载 JDK 安装第三步  安装后, 到 Program Files\\Java 文件夹查看安装情况:第三步eclipse 环境安装下载地址",
    "content": "环境介绍第一步  下载链接：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html第二步  选择刚刚下载 JDK 安装第三步  安装后, 到 Program Files\\Java 文件夹查看安装情况:第三步eclipse 环境安装下载地址"
  },
  
  {
    "title": "Maven install",
    "url": "/posts/Windows-MavenAndTomcat/",
    "categories": "Language, Java",
    "tags": "Server, Java, Java Base",
    "date": "2018-01-06 09:08:09 +0800",
    





    
    "snippet": "Maven 安装配置下载地址：http://maven.apache.org/download.cgi配置&lt;mirror&gt;      &lt;id&gt;aliyun&lt;/id&gt;      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;      &lt;name&gt;aliyun Maven&lt;/name&gt;      &lt;url&...",
    "content": "Maven 安装配置下载地址：http://maven.apache.org/download.cgi配置&lt;mirror&gt;      &lt;id&gt;aliyun&lt;/id&gt;      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;      &lt;name&gt;aliyun Maven&lt;/name&gt;      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;&lt;/mirror&gt;  使用鼠标右键的 链接另存为 功能, 保存替换原有 Maven 配置文件即可.eclipse 配置eclipse 创建 maven 项目  因为这个步骤必须连接到 Maven 服务器获取相关信息, 如果配置和网络有故障则这个步骤就会出现错误! 如果出现错误请使用浏览器检测是否能够访问 Maven 服务器的 URL阿里云 Maven 内网镜像库: https://maven.aliyun.com/mvn/search添加  如果上面没有就操作下图Tomcat 环境搭建下载地址：https://tomcat.apache.org/解压下载文件"
  },
  
  {
    "title": "Java基础",
    "url": "/posts/Java_Base_SE/",
    "categories": "Language, Java",
    "tags": "Server, Java, Java Base",
    "date": "2018-01-06 09:08:09 +0800",
    





    
    "snippet": "Java 基础JDK、JRE、JVM 关系  JDK：java 开发工具包  JRE：java 运行环境  JVM：java 虚拟机Java 数据类型  基本数据类型（四类八种）          整型（byte、short、int、long）      浮点型（float、double）      字符型（char）      布尔型（boolean）        引用数据类型  类（c...",
    "content": "Java 基础JDK、JRE、JVM 关系  JDK：java 开发工具包  JRE：java 运行环境  JVM：java 虚拟机Java 数据类型  基本数据类型（四类八种）          整型（byte、short、int、long）      浮点型（float、double）      字符型（char）      布尔型（boolean）        引用数据类型  类（class）  接口（interface）  数组&amp;和&amp;&amp;的区别  &amp;和&amp;&amp;都可以用作逻辑与的运算符  表示逻辑与（and）  &amp;&amp;还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式重载（Overload ）和重写 （Override ）  重载          发生在一个类中，方法名相同，参数列表不同，方法体不同      编译器在编译时根据方法的签名自动绑定调用的方法        重写  发生在父子类中，方法名称相同，参数列表相同，方法体不同  重写方法被调用时，看对象的类型  重写遵循”两同两小一大”原则:          两同:                  方法名称相同          参数列表相同                    两小:                  派生类方法的返回值类型小于或等于超类方法的                          void 时，必须相等              基本类型时，必须相等              引用类型时，小于或等于                                派生类方法抛出的异常小于或等于超类方法的                    一大:                  派生类方法的访问权限大于或等于超类方法的                    重写与重载的区别  重写(Override):          发生在父子类中，方法名称相同，参数列表相同，方法体不同      遵循”运行期”绑定，看对象的类型来调用方法        重载(Overload):          发生在一个类中，方法名称相同，参数列表不同，方法体不同      遵循”编译期”绑定，看参数/引用的类型来绑定方法      访问修饰符，作用域是否可以继承 String  String 类是 final 类，不可以被继承抽象类(abstract class)和接口(interface)有什么异同不同  抽象类中可以有构造器，接口不能定义构造器  抽象类中可以有普通成员变量和常量，接口中只能有常量，而且只能是 public static final 不写默认  抽象类中可以有抽象方法，也可以由普通的方法，接口中只能有抽象的方法而且修饰符只能是 public abstract 不写默认  抽象类只能是单继承，多实现，接口是可以多继承其他接口，但是不能实现接口，和不能继承其他类  抽象类中可以有静态的方法，接口中不可以  抽象类继承 object 而接口不继承相同  不能够实例化  抽象类接口作为引用类型静态变量和实例变量区别  静态变量：称为类变量，归类所共有，不依赖某个对象们可以通过类名直接访问  实例变量：必须依存实例，只能通过对象访问到他面向对象的基本特征  封装：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口  继承：从已有类得到继承信息创建新类的过程，子类拥有父类一切非私有的属性和方法  多态：指允许不同子类型的对象对同一消息作出不同的响应，同一种事物的不同种表现形式  抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面  java 中实现多态的机制是什么重写、重载、父类的声明指向子类的对象==和 equals 的区别  ==：比较基本数据类型是比较数值是否相等，引用数据类型，则比较对象地址是否相等（= =是比较数值和地址相等才相等）  equals：比较两者内容是否相等String、StringBuffer、StringBuilder 的区别  String：是不可变的，对 string 的改变都会返回一个新的对象，线程安全的  StringBuffer：是可变的，可以对字符串修改，是线程安全的  StringBuilder：是可变的，可以对字符串修改，线程不安全的，性能上有所提升final, finally, finalize 的区别  final：是声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承  finally：是异常处理语句机构一部分，表示总是执行  finalize：是 Object 类的方法，GC 回收执行时候此方法异常处理Throwable 异常分类Error（错误）和 Exception（异常）  Error（错误）:是程序无法处理的错误  Exception（异常）:是程序本身可以处理的异常常见 RuntimeException  java.lang.NullPointerException 空指针异常；  java.lang.ClassNotFoundException 指定的类找不到；  java.lang.NumberFormatException 字符串转换为数字异常；  java.lang.IndexOutOfBoundsException 数组角标越界异常；  java.lang.IllegalArgumentException 方法传递参数错误;  java.lang.ClassCastException 数据类型转换异常；  java.lang.NoClassDefFoundException 未找到类定义错误；  SQLException SQL 异常  java.lang.InstantiationException 实例化异常  java.lang.NoSuchMethodException 方法不存在异常  异常和错误的区别：异常能被程序本身可以处理，错误是无法处理try、catch、finally  try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。  catch 块：用于处理 try 捕获到的异常。  finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。线程创造线程三种方式  继承 Thread 类创建线程  实现 Runnable 接口创建线程  使用 Callable 和 Future 创建线程线程的状态graph LR  A[就绪] --&gt; B[运行]  B --&gt; D[synchronize阻塞]  D --&gt; E[wait 和 sleep挂起]  E --&gt; F[结束]sleep() 和 wait()的区别最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。 wait 通常被用于线程间交互， sleep 通常被用于暂停执行synchronized是多个线程之间访问资源同步性，修饰的方法代码块在任意时刻只能有一个线程执行  修饰实例方法：实例加锁  修饰静态方法：对象加锁  修饰代码块：什么是线程池线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。线程池的优点  第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。  第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。  第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。悲观锁与乐观锁  悲观锁：假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。  乐观锁：是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现IO  方向：输出流（inputStream）和输出流（outputstream）  功能：节点流和处理流  单位：字节流和字符流集合Collection 和 Collections 的区别  Collection：是集合累的上级接口，继承与他的接口主要是 Set 和 List  Collections：是正对集合类的帮助类，他提供一系列静态方法实现对各种的搜索、排序、线程安全化操作。List  Collection 的子接口  底层是数组方式实现  有序可重复的      遍历方式：for-each、for、迭代器（Iterator）        实现类    ArrayList 底层结构是数组,底层查询快,增删慢  LinkedList 底层结构是链表型的,增删快,查询慢  voctor 底层结构是数组 线程安全的,增删慢,查询慢Set  Collection 的子接口  底层是散列表方式实现  无序不可重复的      遍历方式：for-each、for、迭代器（Iterator）        实现类    HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素  LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。  TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)Map  键值对方式呈现  Map 是有序，key 不重复，value 可重复      遍历方式：for-each、迭代器（Iterator）、通过键值遍历    实现  HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希 冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间  LinkedHashMap: LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和 链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以-保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑  HashTable: 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的  TreeMap: 红黑树（自平衡的排序二叉树）HashMap 和 HashTable 区别  HashMap 是非线程安全的，Hashtable 是线程安全的  HashMap 要比 Hashtable 性能高一点  HashMap 中 key 和 value 都可以可以为 null，HashTable 不可以 put 就会出异常List、 Set、Map 的区别  List 和 Set 是 Collection 的子接口,map 不是  List 的底层是数组的方式实现， Set 是散列表的方式实现， map 是键值对的方式  list 是有序可重复的， Set 是无序不可重复的， map 是有序， key 不重复， value 可重复  list 和 Set 可直接使用 iterator 来进行遍历， map 只能通过先遍历 Key 在遍历 value.内部类定义：指在一个外部类的内部再定义一个类分类：成员内部类、局部内部类、静态内部类、匿名内部类  匿名部类可以继承其他类或者实现其他接口作用：  可以实现多重继承  内部类拥有外围类的所有元素访问权限  内部类可以很好实现隐藏Java 反射通过方法获取类的字节码，得到字节码之后，通过反射来创建对象，获取私有属性和方法，在 Spring 中就是依赖反射注入的，在 jdbc 中，通过反射生成驱动对象实获取字节码的方式  class.forNam(className)  类名.class  this.getClass()"
  },
  
  {
    "title": "Resume",
    "url": "/posts/resume/",
    "categories": "Cc, Left",
    "tags": "Left",
    "date": "1997-05-08 23:30:21 +0800",
    





    
    "snippet": "ResumeTo Me  姓名：Cc  手机：18270681615  邮箱：li_chao_cheng@163.com  出生日期：1997 年 5 月 8 日  个人主页  Blog教育信息  毕业学校（第一学历）          学历：专科      专业：计算机网络技术      毕业院校：九江职业技术学院        自考中          学历：本科      专业：计算机...",
    "content": "ResumeTo Me  姓名：Cc  手机：18270681615  邮箱：li_chao_cheng@163.com  出生日期：1997 年 5 月 8 日  个人主页  Blog教育信息  毕业学校（第一学历）          学历：专科      专业：计算机网络技术      毕业院校：九江职业技术学院        自考中          学历：本科      专业：计算机科学与技术      院校：深圳大学      进度：[5/11] 科      技能清单  Go 语言基础知识：包括语法、数据类型、面向对象编程、并发和协程等  Go 常用包：如 fmt、net/http、io、bufio、os、time 等，能够熟练运用标准库编写程序  Go Web 框架：常用的 Gin、Echo、Beego、Iris 等，并掌握 RESTful API 开发规范  数据库：MySQL、PostgreSQL、MongoDB、Redis 等的使用和操作，以及熟悉至少一种数据库驱动的开发  微服务框架：了解 gRPC、Micro 等微服务框架的原理和应用  Linux 操作系统：熟悉 Linux 操作系统，能够使用命令行工具进行日常开发和维护  Docker 容器：熟悉 Docker 的基本使用和容器化部署  Kubernetes 集群：了解 Kubernetes 集群的部署与维护，以及能够在 Kubernetes 上部署应用程序  单元测试：熟悉 testing 包和 testify/assert 包的使用，能够编写高质量的单元测试代码  开发工具：Git 版本控制工具的使用，以及集成开发环境（如 GoLand、Visual Studio Code 等）的使用。工作经历南昌市润海通信息服务有限公司2018 年-2020 年Java 服务端程序员项目  物业管理后台公司责任描述  设计并开发物业管理系统的后端服务器，负责处理用户请求和数据存储。  使用 Java、Spring 等技术栈完成项目架构和设计，并负责实现与维护后端代码。  与前端团队合作，协调接口规范，编写 API 文档及文档注释。  优化代码性能和数据库访问效率，提高系统运行速度和稳定性。  对服务器进行监控、优化和维护，确保系统高可用性。  参与公司内部技术分享和开发流程改进，提升研发效率和团队协作。现公司 （2020 年 5 月 - 至今）  2020 年 5 月 - Today  独立完成          SanGong      QiuQiu      BandarQQ      LHD      Texas poker      责任描述 Online  参与公司核心业务系统的后端开发与维护  设计并实现了高可用性、高性能的微服务架构，提升了系统的稳定性和响应速度；  针对不同的业务需求，选择合适的存储和缓存方案，并优化了数据库访问性能；  利用 Docker 和 Kubernetes 等容器化技术，实现了快速部署和版本管理。  针对高并发业务场景，引入 Redis 集群，实现高效的缓存处理和分布式锁管理；  借助 Prometheus 和 Grafana 等监控工具，对系统进行性能监控和故障排查；  通过代码重构和服务治理等手段，降低代码复杂度和耦合度，提高了系统可维护性；  主导了团队内部的技术分享和培训活动，提高了团队整体技术水平；深圳智慧乐园科技有限公司  2019/2 ～ 2020/5监控识别管理系统  项目描述：系统为 App（管理端、用户端）和 后台管理          分布式管理服务      主要开发语言：Golang      Web 框架：beego      数据处理：mysql、redis      中间件：JWT、nginx、grpc、rpc、docker、eureka        App          管理端：管理目标监控下的同行记录，识别开门记录，用户端请求数据审核      用户端：添加楼宇可开门访客，区域公告接收，区域反馈功能        管理后台          监控实时视频管理      识别记录管理      注册人脸管理上传管理      系统管理（管理角色、权限，广告）      区域设置        个人负责          简单分布式系统      负责整合系统业务开发以及搭建架构      系统分为 8 个子系统分布式到不同的服务器      子系统使用 eureka 注册服务发现，实现 grpc 以及 rpc 联合管理      使用 redis 和 jwt 实现服务之间单点登录验证      负责项目部署，升级，测试，迭代      实物共享 App  项目描述：          Download      单体应用服务（App 接口和后台一体）      主要开发语言：Golang      Web 框架：beego      数据处理：mysql、redis      中间件：JWT、nginx        App          管理端：管理 App 展示、对用户管理、App 信息管理、交易管理等等      用户端：App 展示、用户对实物发布、领取，个人信息等等        个人负责：App 和管理后台服务端所有自我评价  对编程语言有深入的理解：不仅熟悉 Go 语言，还了解其他编程语言的特点和应用场景，能够灵活选择合适的工具和框架。  热衷于学习新技术：关注行业最新动态，主动学习新的技术和开发模式，保持技术优势。  具有良好的设计和架构能力：能够将业务需求转化为可靠、高效的软件架构，编写高质量的代码并保证系统的可扩展性和可维护性。  熟悉 DevOps 思想：理解 DevOps 的核心原则，了解持续集成和持续交付等实践，能够利用自动化工具实现快速部署和迭代。  能够与团队进行知识分享：善于分享自己的经验和知识，能够向同事讲解技术细节和开发实例，从而提高整个团队的技术水平。  具备良好的沟通能力：能够与其他团队成员进行高效的沟通，并及时解决问题。  具有责任心和自我驱动力：能够自我管理、自我激励，对工作负责并保证代码质量。  具有团队合作意识：能够主动帮助他人，并通过协作实现共同目标。  谦逊和开放：愿意接受他人的意见和建议，乐于分享自己的经验和知识，以促进整个团队的发展。"
  }
  
]

